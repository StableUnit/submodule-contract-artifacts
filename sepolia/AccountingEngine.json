{
  "address": "0x3E68C3978a21BBF317FbBf919F6154376Bba175A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "safeEngine_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "liquidationEngine_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "oracle_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "stablePro_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        }
      ],
      "name": "BadStablecoin",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "DisableContract",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "StableProSwapped",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "usr",
          "type": "address"
        }
      ],
      "name": "addAuthorization",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "authorizedAccounts",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "contractEnabled",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "debtQueue",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "disableContract",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidationEngine",
      "outputs": [
        {
          "internalType": "contract ILiquidationEngine",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oracle",
      "outputs": [
        {
          "internalType": "contract ISuOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "era",
          "type": "uint256"
        }
      ],
      "name": "popDebtFromQueue",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountToRaise",
          "type": "uint256"
        }
      ],
      "name": "pushDebtToQueue",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "usr",
          "type": "address"
        }
      ],
      "name": "removeAuthorization",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "safeEngine",
      "outputs": [
        {
          "internalType": "contract ISafeEngine",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stablePro",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "stablecoinToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "stableProAmountE18",
          "type": "uint256"
        }
      ],
      "name": "swapStableProToStablecoin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalQueuedDebt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "numDeployments": 2,
  "solcInputHash": "c51927dd277f1318ab9de6db4c2443ac",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeEngine_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stablePro_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"BadStablecoin\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DisableContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StableProSwapped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractEnabled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"debtQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationEngine\",\"outputs\":[{\"internalType\":\"contract ILiquidationEngine\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract ISuOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"}],\"name\":\"popDebtFromQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToRaise\",\"type\":\"uint256\"}],\"name\":\"pushDebtToQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeEngine\",\"outputs\":[{\"internalType\":\"contract ISafeEngine\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stablePro\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stablecoinToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stableProAmountE18\",\"type\":\"uint256\"}],\"name\":\"swapStableProToStablecoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalQueuedDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"disableContract()\":{\"details\":\"When we disable, the contract tries to settle as much debt as possible (if there's any) with any surplus that's left in the system. After erasing debt, the contract will either transfer any remaining surplus right away (if disableCooldown == 0) or will only record the timestamp when it was disabled*\"},\"popDebtFromQueue(uint256)\":{\"params\":{\"era\":\"Timestamp of the block of debt that should be popped out\"}},\"pushDebtToQueue(uint256)\":{\"details\":\"Debt is locked in a queue to give the system enough time to auction collateral      and gather surplus\",\"params\":{\"amountToRaise\":\"Amount of debt to push\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"disableContract()\":{\"notice\":\"Disable this contract (normally called by Global Settlement)\"},\"popDebtFromQueue(uint256)\":{\"notice\":\"A block of debt can be popped from the queue after popDebtDelay seconds passed since it was         added there\"},\"pushDebtToQueue(uint256)\":{\"notice\":\"Push debt (that the system tries to cover with collateral auctions) to a queue\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/makerdao/externalContracts/AccountingEngine.sol\":\"AccountingEngine\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\",\"keccak256\":\"0x9af98b0908c96320ca6d08b22f0efca864742f6adbe5794cafe2d1d2e808b0cd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/makerdao/externalContracts/AccountingEngine.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\n/// AccountingEngine.sol -- StablePro settlement module\\n\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\n\\nimport {Math} from \\\"../utils/Math.sol\\\";\\nimport \\\"../interfaces/ISafeEngine.sol\\\";\\nimport \\\"../interfaces/ILiquidationEngine.sol\\\";\\nimport \\\"../interfaces/IAccountingEngine.sol\\\";\\nimport \\\"../../periphery/contracts/interfaces/oracle/ISuOracle.sol\\\";\\n\\n// FIXME: This contract was altered compared to the production version.\\n// It doesn't use LibNote anymore.\\n// New deployments of this contract will need to include custom events (TO DO).\\n\\n// CHANGED: removed all methods about surplus and debt auctions. Need to be updated later to work with debt and surplus.\\n// Added swapStableProToStablecoin function, because after liquidation AccountingEngine receive stablecoin\\n// that can be changed for StablePro.\\n// Also moved Math behaviour into lib and added interface and moved struct there.\\n\\ncontract AccountingEngine is Math, IAccountingEngine {\\n    // --- Auth ---\\n    mapping (address => uint) public authorizedAccounts;\\n    function addAuthorization(address usr) external isAuthorized {\\n        require(contractEnabled == 1, \\\"AccountingEngine/not-contractEnabled\\\");\\n        authorizedAccounts[usr] = 1;\\n    }\\n    function removeAuthorization(address usr) external isAuthorized { authorizedAccounts[usr] = 0; }\\n    modifier isAuthorized {\\n        require(authorizedAccounts[msg.sender] == 1, \\\"AccountingEngine/not-authorized\\\");\\n        _;\\n    }\\n\\n    // --- Data ---\\n    ISafeEngine public safeEngine;\\n    ILiquidationEngine public liquidationEngine;\\n    ISuOracle public oracle;\\n    address public stablePro;\\n\\n    mapping (uint256 => uint256) public debtQueue;  // debt queue\\n    uint256 public totalQueuedDebt;   // Queued debt [rad]\\n    uint256 public contractEnabled;\\n\\n    // --- Init ---\\n    constructor(address safeEngine_, address liquidationEngine_, address oracle_, address stablePro_) public {\\n        authorizedAccounts[msg.sender] = 1;\\n        safeEngine = ISafeEngine(safeEngine_);\\n        liquidationEngine = ILiquidationEngine(liquidationEngine_);\\n        oracle = ISuOracle(oracle_);\\n        stablePro = stablePro_;\\n        contractEnabled = 1;\\n    }\\n\\n    /**\\n    * @notice Push debt (that the system tries to cover with collateral auctions) to a queue\\n     * @dev Debt is locked in a queue to give the system enough time to auction collateral\\n     *      and gather surplus\\n     * @param amountToRaise Amount of debt to push\\n     */\\n    function pushDebtToQueue(uint amountToRaise) external isAuthorized {\\n        debtQueue[block.timestamp] = _add(debtQueue[block.timestamp], amountToRaise);\\n        totalQueuedDebt = _add(totalQueuedDebt, amountToRaise);\\n    }\\n    /**\\n     * @notice A block of debt can be popped from the queue after popDebtDelay seconds passed since it was\\n     *         added there\\n     * @param era Timestamp of the block of debt that should be popped out\\n     */\\n    function popDebtFromQueue(uint era) external {\\n        // require(_add(era, popDebtDelay) <= block.timestamp, \\\"AccountingEngine/popDebtDelay-not-finished\\\");\\n        totalQueuedDebt = _sub(totalQueuedDebt, debtQueue[era]);\\n        debtQueue[era] = 0;\\n    }\\n\\n    // Debt settlement\\n//    /**\\n//     * @notice Destroy an equal amount of coins and debt\\n//     * @dev We can only destroy debt that is not locked in the queue and also not in a debt auction\\n//     * @param rad Amount of coins/debt to destroy (number with 45 decimals)\\n//    **/\\n//    function settleDebt(uint rad) external {\\n//        require(rad <= safeEngine.coinBalance(address(this)), \\\"AccountingEngine/insufficient-surplus\\\");\\n//        require(\\n//            rad <= _sub(_sub(safeEngine.debtBalance(address(this)), totalQueuedDebt), totalOnAuctionDebt),\\n//            \\\"AccountingEngine/insufficient-debt\\\"\\n//        );\\n//        safeEngine.settleDebt(rad);\\n//    }\\n\\n    /**\\n     * @notice Disable this contract (normally called by Global Settlement)\\n     * @dev When we disable, the contract tries to settle as much debt as possible (if there's any) with\\n            any surplus that's left in the system. After erasing debt, the contract will either transfer any\\n            remaining surplus right away (if disableCooldown == 0) or will only record the timestamp when\\n            it was disabled\\n    **/\\n    function disableContract() external isAuthorized {\\n        require(contractEnabled == 1, \\\"AccountingEngine/not-contractEnabled\\\");\\n        contractEnabled = 0;\\n        totalQueuedDebt = 0;\\n        safeEngine.settleDebt(min(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this))));\\n        emit DisableContract();\\n    }\\n\\n    // user need to approve StablePro\\n    function swapStableProToStablecoin(\\n        address stablecoinToken,\\n        uint256 stableProAmountE18\\n    ) external {\\n        if (!liquidationEngine.hasWhitelistStablecoin(stablecoinToken)) revert BadStablecoin(stablecoinToken);\\n\\n        uint256 stablecoinAmountEDecimal = stableProAmountE18 * 1e18 / oracle.getFiatPrice1e18(stablecoinToken);\\n\\n        TransferHelper.safeTransferFrom(stablePro, msg.sender, address(this), stableProAmountE18);\\n        TransferHelper.safeTransfer(stablecoinToken, msg.sender, stablecoinAmountEDecimal);\\n\\n        // middlewareDebt -= int256(stableProAmountE18);\\n        // TODO: should we settleDebt and do some manipulations in safeEngine?\\n\\n        emit StableProSwapped(stableProAmountE18);\\n    }\\n}\\n\",\"keccak256\":\"0x3206b1411f4e7f18376d8fac09d4543b392023ad652f8fa158edca496b22be8e\",\"license\":\"AGPL-3.0-or-later\"},\"contracts/makerdao/interfaces/IAccountingEngine.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IAccountingEngine\\n **/\\ninterface IAccountingEngine {\\n    /* ==================== EVENTS ===============-===== */\\n    event StableProSwapped(uint256 amount);\\n    event DisableContract();\\n\\n    /* ==================== ERRORS ===============-===== */\\n    error BadStablecoin(address asset);\\n\\n\\n    /* ==================== MUTABLE METHODS ==================== */\\n\\n    function pushDebtToQueue(uint amountToRaise) external;\\n\\n    function swapStableProToStablecoin(address stablecoinToken, uint256 stableProAmountE18) external;\\n}\\n\",\"keccak256\":\"0xc6ed749440490efa0df2bfb963005c707794dec7dbb5d650fd871be1b1f5bb87\",\"license\":\"UNLICENSED\"},\"contracts/makerdao/interfaces/ILiquidationEngine.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ITaxCollector\\n **/\\ninterface ILiquidationEngine {\\n    /* ==================== STRUCTS ==================== */\\n\\n    struct CollateralType {\\n        uint256 liquidationPenalty;  // Liquidation Penalty [wad]\\n        uint256 liquidationLimit;  // Max StablePro needed to cover debt+fees of active auctions per cType [rad]\\n        uint256 activeLiquidationAmount;  // Amt StablePro needed to cover debt+fees of active auctions per cType [rad]\\n    }\\n\\n    /* ==================== EVENTS ===============-===== */\\n\\n    event DisableContract();\\n\\n    event AddAuthorization(address indexed usr);\\n    event RemoveAuthorization(address indexed usr);\\n\\n    event ModifyParameters(bytes32 indexed what, uint256 data);\\n    event ModifyParameters(bytes32 indexed what, address data);\\n    event ModifyParameters(bytes32 indexed collateralType, bytes32 indexed what, uint256 data);\\n    event ModifyParameters(bytes32 indexed collateralType, bytes32 indexed what, address liquidator);\\n\\n    event LiquidateCDP(\\n        bytes32 indexed collateralType,\\n        address indexed cdp,\\n        uint256 lockedCollateral,\\n        uint256 generatedDebt,\\n        uint256 due,\\n        address liquidator,\\n        uint256 indexed id\\n    );\\n    event ReduceActiveLiquidationAmount(bytes32 indexed collateralType, uint256 rad);\\n\\n    /* ==================== MUTABLE METHODS ==================== */\\n\\n    // --- Administration ---\\n    function modifyParameters(bytes32 what, uint data) external;\\n    function modifyParameters(bytes32 what, address data) external;\\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\\n\\n    /**\\n      * @notice Liquidate a Vault and start a Dutch auction to sell its collateral for StablePro.\\n      * @dev The entire Vault will be liquidated except when the target amount of StablePro to be raised in\\n      * the resulting auction (debt of Vault + liquidation penalty) causes either ActiveLiquidationAmount to exceed\\n      * GlobalLiquidationLimit or collateralType.activeLiquidationAmount to exceed collateralType.liquidationLimit\\n      * by an economically significant amount. In that case, a partial liquidation is performed to respect the global\\n      * and per-collateralType limits on outstanding StablePro target. The one exception is if the resulting auction\\n      * would likely have too little collateral to be interesting to Keepers\\n      * (debt taken from Vault < collateralType.debtFloor),\\n      * in which case the function reverts. Please refer to the code and comments within if more detail is desired.\\n      * @param collateralType - collateral type\\n      * @param cdp - address of cdp position\\n      * @param incentivesReceiver - address that will receive the liquidation reward, if any.\\n      * @param collateralJoin - address of collateral adapter\\n    **/\\n    function liquidateCDP(\\n        bytes32 collateralType,\\n        address cdp,\\n        address incentivesReceiver,\\n        address collateralJoin\\n    ) external returns (uint256 id);\\n\\n    function reduceActiveLiquidationAmount(bytes32 collateralType, uint256 rad) external;\\n\\n    // --- Whitelist ---\\n    function addWhitelistStablecoin(address _stablecoin) external;\\n    function removeWhitelistStablecoin(address _stablecoin) external;\\n\\n    /* ==================== VIEW METHODS ==================== */\\n\\n    function liquidationPenalty(bytes32 collateralType) external view returns (uint256);\\n\\n    function hasWhitelistStablecoin(address _stablecoin) external view returns(bool);\\n}\\n\",\"keccak256\":\"0x607868c20372e60ac342472f563e48e5ff159974fc61ec7248427b8f5ac7ea3b\",\"license\":\"UNLICENSED\"},\"contracts/makerdao/interfaces/ISafeEngine.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// TODO: check how to operate with license and use one for all contracts\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title SafeEngine\\n * @notice The single source of truth for the Maker Protocol. It contains the accounting system of the core Vault,\\n * Internal StablePro balances, and collateral state. It houses the public interface for Vault management,\\n * allowing safe(= CDP or Vault) owners to adjust their Vault state balances. It also contains the public interface\\n * for Vault fungibility, allowing safe (Vault) owners to transfer, split, and merge Vaults.\\n * Excluding these interfaces, SAFEEngine is accessed through trusted smart contract modules.\\n **/\\ninterface ISafeEngine {\\n    /* ==================== EVENTS ==================== */\\n    event DisableContract();\\n\\n    /* ==================== METHODS ==================== */\\n\\n    // --- Data ---\\n    struct CollateralType {\\n        uint256 debtAmount;       // Total debt issued for this specific collateral type                          [wad]\\n        uint256 accumulatedRate;  // Accumulator for interest accrued on this collateral type                     [ray]\\n        uint256 safetyPrice;      // Floor price at which a CDP is allowed to generate debt                       [ray]\\n        uint256 debtCeiling;      // Maximum amount of debt that can be generated with this collateral type       [rad]\\n        uint256 debtFloor;        // Minimum amount of debt that must be generated by a CDP using this collateral [rad]\\n    }\\n    struct SAFE {\\n        uint256 lockedCollateral; // Total amount of collateral locked in a SAFE/CDP  [wad]\\n        uint256 generatedDebt;    // Total amount of debt generated by a SAFE/CDP     [wad]\\n    }\\n\\n    // --- VARS ---\\n\\n    function safes(bytes32, address) external view returns (uint, uint);\\n\\n    function collateralTypes(bytes32) external view returns (\\n        uint256 debtAmount,      // [wad]\\n        uint256 accumulatedRate, // [ray]\\n        uint256 safetyPrice,     // [ray]\\n        uint256 debtCeiling,     // [rad]\\n        uint256 debtFloor        // [rad]\\n    );\\n\\n    function tokenCollateral(bytes32, address) external view returns (uint256);\\n\\n    function coinBalance(address) external view returns (uint256);\\n\\n    function debtBalance(address) external view returns (uint256);\\n\\n    function cdpRights(address, address) external view returns (uint256);\\n\\n    // --- Auth ---\\n    /**\\n     * @notice Allow an address to modify your CDP.\\n     * For example coinAdapter should be able to modify your CDP to withdraw all correctly.\\n     * @param usr Account to give CDP permissions to\\n     */\\n    function approveSAFEModification(address usr) external;\\n\\n    /**\\n     * @notice Deny an address the rights to modify your CDP\\n     * @param usr Account to give CDP permissions to\\n     */\\n    function denySAFEModification(address usr) external;\\n\\n    // --- Administration ---\\n\\n    function initializeCollateralType(bytes32 collateralType) external;\\n    // TODO: check why not to use strings instead of bytes32\\n    /**\\n     * @notice Method to modify some global variables\\n     * @param what - name of variable we want to change\\n     * @param data - new value of this variable\\n     */\\n    function modifyParameters(bytes32 what, uint data) external;\\n    /**\\n     * @notice Method to modify values in struct of collateralTypes\\n     * @param collateralType - collateral type we wand to modify (collateralTypes[collateralType])\\n     * @param what - name of variable in struct we want to change\\n     * @param data - new value of this variable\\n     */\\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\\n\\n    // --- Fungibility ---\\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external;\\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external;\\n    function transferInternalCoins(address src, address dst, uint256 rad) external;\\n\\n    // --- CDP Manipulation ---\\n    /**\\n     * @notice Add/remove collateral or put back/generate more debt in a CDP\\n     * @param collateralType Type of collateral to withdraw/deposit in and from the CDP\\n     * @param cdp Target CDP\\n     * @param collateralSource Account we take collateral from/put collateral into\\n     * @param debtDestination Account from which we credit/debit coins and debt\\n     * @param deltaCollateral Amount of collateral added/extract from the CDP\\n     * @param deltaDebt Amount of debt to generate/repay\\n     */\\n    function modifySAFECollateralization(\\n        bytes32 collateralType,\\n        address cdp,\\n        address collateralSource,\\n        address debtDestination,\\n        int deltaCollateral,\\n        int deltaDebt\\n    ) external;\\n\\n    // --- CDP Fungibility ---\\n    /**\\n     * @notice Transfer collateral and/or debt between CDPs\\n     * @param collateralType Collateral type transferred between CDPs\\n     * @param src Source CDP\\n     * @param dst Destination CDP\\n     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst\\n     * @param deltaDebt Amount of debt to take/add into src and give/take from dst\\n     */\\n    function transferSAFECollateralAndDebt(\\n        bytes32 collateralType,\\n        address src,\\n        address dst,\\n        int deltaCollateral,\\n        int deltaDebt\\n    ) external;\\n\\n    // --- CDP Confiscation ---\\n    /**\\n     * @notice Normally used by the LiquidationEngine in order to confiscate collateral and\\n       debt from a CDP and give them to someone else\\n     * @param collateralType Collateral type the CDP has locked inside\\n     * @param cdp Target CDP\\n     * @param collateralCounterparty Who we take/give collateral to\\n     * @param debtCounterparty Who we take/give debt to\\n     * @param deltaCollateral Amount of collateral taken/added into the CDP\\n     * @param deltaDebt Amount of debt taken/added into the CDP\\n     */\\n    function confiscateSAFECollateralAndDebt(\\n        bytes32 collateralType,\\n        address cdp,\\n        address collateralCounterparty,\\n        address debtCounterparty,\\n        int deltaCollateral,\\n        int deltaDebt\\n    ) external;\\n\\n    // --- Settlement ---\\n    /**\\n     * @notice Nullify an amount of coins with an equal amount of debt\\n     * @param rad Amount of debt & coins to destroy (expressed as a number with 45 decimals)\\n     */\\n    function settleDebt(uint rad) external;\\n\\n    /**\\n     * @notice Usually called by CoinSavingsAccount in order to create unbacked debt\\n     * @param debtDestination Usually AccountingEngine that can settle decreaseSoldAmount with surplus\\n     * @param coinDestination Usually CoinSavingsAccount who passes the new coins to depositors\\n     * @param rad Amount of debt to create (expressed as a number with 45 decimals)\\n     */\\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external;\\n\\n    // --- Rates ---\\n    /**\\n     * @notice Usually called by TaxCollector in order to accrue interest on a specific collateral type\\n     * @param collateralType Collateral type we accrue interest for\\n     * @param surplusDst Destination for amount of surplus created by applying the interest rate\\n       to debt created by CDPs with 'collateralType'\\n     * @param accumulatedRate Multiplier applied to the debtAmount in order to calculate the surplus\\n     */\\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external;\\n}\\n\",\"keccak256\":\"0x11845dee83c9eff2f02955a03ada14f08538121841c83f8a5ff8f13e874f2a8d\",\"license\":\"UNLICENSED\"},\"contracts/makerdao/utils/Math.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract Math {\\n    uint256 constant WAD = 10 ** 18;\\n\\n    /**\\n    * @notice Calculates the sum of an unsigned integer and a signed integer\\n    * @param  x Unsigned integer\\n    * @param  y Signed integer\\n    * @return z Unsigned sum of `x` and `y`\\n    */\\n    function _add(uint x, int y) internal pure returns (uint z) {\\n        if (y >= 0) {\\n            z = x + uint256(y);\\n        } else {\\n            z = x - uint256(-y);\\n        }\\n        require(y >= 0 || z <= x);\\n        require(y <= 0 || z >= x);\\n    }\\n\\n    /**\\n    * @notice Calculates the substraction of an unsigned integer and a signed integer\\n    * @param  x Unsigned integer\\n    * @param  y Signed integer\\n    * @return z Unsigned substraction of `x` and `y`\\n    */\\n    function _sub(uint x, int y) internal pure returns (uint z) {\\n        if (y >= 0) {\\n            z = x - uint256(y);\\n        } else {\\n            z = x + uint256(-y);\\n        }\\n        require(y <= 0 || z <= x);\\n        require(y >= 0 || z >= x);\\n    }\\n    function _mul(uint x, int y) internal pure returns (int z) {\\n        z = int(x) * y;\\n        require(int(x) >= 0);\\n        require(y == 0 || z / y == int(x));\\n    }\\n\\n    function _add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x);\\n    }\\n    function _sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x);\\n    }\\n    function _mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x);\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x <= y ? x : y;\\n    }\\n\\n    function either(bool x, bool y) internal pure returns (bool z) {\\n        assembly{ z := or(x, y)}\\n    }\\n    function both(bool x, bool y) internal pure returns (bool z) {\\n        assembly{ z := and(x, y)}\\n    }\\n}\\n\",\"keccak256\":\"0xcc88ae73c3c41786ae52f22a516bc57dbd66ffb4de9ea42d2344231b3d82dd3f\",\"license\":\"AGPL-3.0-or-later\"},\"contracts/periphery/contracts/interfaces/oracle/ISuOracle.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\n// solhint-disable compiler-version\\npragma solidity >=0.7.6;\\n\\ninterface ISuOracle {\\n    /**\\n     * @notice WARNING! Read this description very carefully!\\n     *     function getFiatPrice1e18(address asset) returns (uint256) that:\\n     *         basicAmountOfAsset * getFiatPrice1e18(asset) / 1e18 === $$ * 1e18\\n     *     in other words, it doesn't matter what's the erc20.decimals is,\\n     *     you just multiply token balance in basic units on value from oracle and get dollar amount multiplied on 1e18.\\n     *\\n     * different assets have different deviation threshold (errors)\\n     *     for wBTC it's <= 0.5%, read more https://data.chain.link/ethereum/mainnet/crypto-usd/btc-usd\\n     *     for other asset is can be larger based on particular oracle implementation.\\n     *\\n     * examples:\\n     *     market price of btc = $30k,\\n     *     for 0.1 wBTC the unit256 amount is 0.1 * 1e18\\n     *     0.1 * 1e18 * (price1e18 / 1e18) == $3000 == uint256(3000*1e18)\\n     *     => price1e18 = 30000 * 1e18;\\n     *\\n     *     market price of usdt = $0.97,\\n     *     for 1 usdt uint256 = 1 * 1e6\\n     *     so 1*1e6 * price1e18 / 1e18 == $0.97 == uint256(0.97*1e18)\\n     *     => 1*1e6 * (price1e18 / 1e18) / (0.97*1e18)   = 1\\n     *     =>  price1e18 = 0.97 * (1e18/1e6) * 1e18\\n     *\\n     *    assume market price of wBTC = $31,503.77, oracle error = $158\\n     *\\n     *     case #1: small amount of wBTC\\n     *         we have 0.0,000,001 wBTC that is worth v = $0.00315 \\u00b1 $0.00001 = 0.00315*1e18 = 315*1e13 \\u00b1 1*1e13\\n     *         actual balance on the asset b = wBTC.balanceOf() =  0.0000001*1e18 = 1e11\\n     *         oracle should return or = oracle.getFiatPrice1e18(wBTC) <=>\\n     *         <=> b*or = v => v/b = 315*1e13 / 1e11 = 315*1e2 \\u00b1 1e2\\n     *         error = or.error * b = 1e2 * 1e11 = 1e13 => 1e13/1e18 usd = 1e-5 = 0.00001 usd\\n     *\\n     *     case #2: large amount of wBTC\\n     *         v = 2,000,000 wBTC = $31,503.77 * 2m \\u00b1 158*2m = $63,007,540,000 \\u00b1 $316,000,000 = 63,007*1e24 \\u00b1 316*1e24\\n     *         for calc convenience we increase error on 0.05 and have v = 63,000*24 \\u00b1 300*1e24 = (630 \\u00b1 3)*1e26\\n     *         b = 2*1e6 * 1e18 = 2*1e24\\n     *         or = v/b = (630 \\u00b1 3)*1e26 / 2*1e24 = 315*1e2 \\u00b1 1.5*1e2\\n     *         error = or.error * b = 1.5*100 * 2*1e24 = 3*1e26 = 3*1e8*1e18 = $300,000,000 ~ $316,000,000\\n     *\\n     *     assume the market price of USDT = $0.97 \\u00b1 $0.00485,\\n     *\\n     *     case #3: little amount of USDT\\n     *         v = USDT amount 0.005 = 0.005*(0.97 \\u00b1 0.00485) = 0.00485*1e18 \\u00b1 0.00002425*1e18 = 485*1e13 \\u00b1 3*1e13\\n     *         we rounded error up on (3000-2425)/2425 ~= +24% for calculation convenience.\\n     *         b = USDT.balanceOf() = 0.005*1e6 = 5*1e3\\n     *         b*or = v => or = v/b = (485*1e13 \\u00b1 3*1e13) / 5*1e3 = 970*1e9 \\u00b1 6*1e9\\n     *         error = 6*1e9 * 5*1e3 / 1e18 = 30*1e12/1e18 = 3*1e-5 = $0,00005\\n     *\\n     *     case #4: lot of USDT\\n     *         v = we have 100,000,000,000 USDT = $97B = 97*1e9*1e18 \\u00b1 0.5*1e9*1e18\\n     *         b = USDT.balanceOf() = 1e11*1e6 = 1e17\\n     *         or = v/b = (97*1e9*1e18 \\u00b1 0.5*1e9*1e18) / 1e17 = 970*1e9 \\u00b1 5*1e9\\n     *         error = 5*1e9 * 1e17 = 5*1e26 = 0.5 * 1e8*1e18\\n     *\\n     * @param asset - address of erc20 token contract\\n     * @return usdPrice1e18 such that asset.balanceOf() * getFiatPrice1e18(asset) / 1e18 == $$ * 1e18\\n     **/\\n    function getFiatPrice1e18(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xa56b9cc86ef5935efecc276e6a3188d518f1a99cad960083a8de35849c997687\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x6080346100cf57601f610ac238819003918201601f19168301916001600160401b038311848410176100d4578084926080946040528339810103126100cf57610047816100ea565b90610054602082016100ea565b61006c6060610065604085016100ea565b93016100ea565b90336000526000602052600160406000205560018060a01b03928380928160018060a01b0319971687600154161760015516856002541617600255168360035416176003551690600454161760045560016007556040516109c390816100ff8239f35b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b03821682036100cf5756fe6080604081815260048036101561001557600080fd5b600092833560e01c90816324ba5884146107e1575080632d09f11d146107c257806335b281531461076f5780633977a3191461074857806341b3a0d91461072957806344bf3c7214610700578063550a1e00146103f857806367aea313146103cf5780637dc0d1d0146103a657838163894ba833146101eb575080638b24dc3e146101935783816394f3f81d1461014957508063a8b30a9f146100eb5763d46e50d0146100c157600080fd5b346100e757826003193601126100e7575490516001600160a01b03909116815260209150f35b8280fd5b5090346100e75760203660031901126100e7576101439135903384528360205261011a6001828620541461082f565b428452600560205261012f8282862054610963565b904285526005602052842055600654610963565b60065580f35b80843461019057602036600319011261019057610164610814565b3383528260205261017a6001838520541461082f565b6001600160a01b03168252602082905281205580f35b50fd5b509190346101e75760203660031901126101e757823560065481845260056020528284205481039081116101d4578394506006558252600560205281205580f35b634e487b7160e01b845260118552602484fd5b5080fd5b808484346103a257826003193601126103a25733835260208381526102156001848620541461082f565b61022360016007541461087b565b600784905560068490556001548351633eaf7a0360e21b815230848201526001600160a01b03909116918082602481865afa918215610398578692610369575b5084516311005b0760e01b815230858201528181602481875afa91821561035f57879261032d575b50508082116103255750905b803b156103215760248592855196879384926327a0bb3360e01b8452878401525af18015610317576102ec575b837f2d4b4ecff7bd7503135271925520a2f6c0d98c9473ffc1a1e72c92502f51b25e8180a180f35b6001600160401b0383116103045750528180806102c4565b634e487b7160e01b845260419052602483fd5b82513d86823e3d90fd5b8480fd5b905090610297565b90809250813d8311610358575b61034481836108d3565b810103126103545751878061028b565b8580fd5b503d61033a565b86513d89823e3d90fd5b9080925081813d8311610391575b61038181836108d3565b8101031261035457519087610263565b503d610377565b85513d88823e3d90fd5b5050fd5b5050346101e757816003193601126101e75760035490516001600160a01b039091168152602090f35b5050346101e757816003193601126101e75760015490516001600160a01b039091168152602090f35b508290346101e757826003193601126101e757610413610814565b9060249081359160018060a01b039384600254169487519563de51eefd60e01b875286828416918287830152818660209a8b935afa9081156106a25789916106d3575b50156106be57670de0b6b3a7640000918287029287840414871517156106ac5787816003541692868c5180958193631735856760e31b83528b8301525afa9182156106a257899261066f575b50811561065d5785548a516323b872dd60e01b8a8201908152338883015230604483015260648083018b905282526001600160401b0393909216919060a081018481118282101761064b578d52518b9283929083905af1610501610924565b8161061b575b50156105f3578951918883019363a9059cbb60e01b85523387850152046044830152604482526080820190828210908211176105e157895251879283929083905af1610551610924565b816105b1575b501561058a5750507f062234b32cab33fa5bcd957e318141fefab38cc79f25ec5b972be8392e98cb6c929351908152a180f35b855162461bcd60e51b81529182018490526002908201526114d560f21b6044820152606490fd5b805180159250869083156105c9575b50505087610557565b6105d9935082018101910161090c565b8785816105c0565b634e487b7160e01b8952604186528489fd5b895162461bcd60e51b81528087018990526003818701526229aa2360e91b6044820152606490fd5b8051801592508a908315610633575b5050508b610507565b610643935082018101910161090c565b8b898161062a565b634e487b7160e01b8d5260418a52888dfd5b634e487b7160e01b8952601286528489fd5b9091508781813d831161069b575b61068781836108d3565b810103126106975751908a6104a2565b8880fd5b503d61067d565b8a513d8b823e3d90fd5b634e487b7160e01b8952601186528489fd5b8484918a5191633935d9fb60e21b8352820152fd5b6106f39150883d8a116106f9575b6106eb81836108d3565b81019061090c565b8a610456565b503d6106e1565b5050346101e757816003193601126101e75760025490516001600160a01b039091168152602090f35b5050346101e757816003193601126101e7576020906007549051908152f35b50346100e75760203660031901126100e75760209282913581526005845220549051908152f35b5050346101e75760203660031901126101e75760019061078d610814565b338452836020526107a283838620541461082f565b6107af836007541461087b565b828060a01b031683528260205282205580f35b5050346101e757816003193601126101e7576020906006549051908152f35b849084346100e75760203660031901126100e7576020926001600160a01b03610808610814565b16815280845220548152f35b600435906001600160a01b038216820361082a57565b600080fd5b1561083657565b60405162461bcd60e51b815260206004820152601f60248201527f4163636f756e74696e67456e67696e652f6e6f742d617574686f72697a6564006044820152606490fd5b1561088257565b60405162461bcd60e51b8152602060048201526024808201527f4163636f756e74696e67456e67696e652f6e6f742d636f6e7472616374456e61604482015263189b195960e21b6064820152608490fd5b601f909101601f19168101906001600160401b038211908210176108f657604052565b634e487b7160e01b600052604160045260246000fd5b9081602091031261082a5751801515810361082a5790565b3d1561095e573d906001600160401b0382116108f65760405191610952601f8201601f1916602001846108d3565b82523d6000602084013e565b606090565b919082019182811161097757821061082a57565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220278c5ce8ca506106f425971ab87339ff8e4b4d923599a3c9cd833d0730c801ae64736f6c63430008110033",
  "deployedBytecode": "0x6080604081815260048036101561001557600080fd5b600092833560e01c90816324ba5884146107e1575080632d09f11d146107c257806335b281531461076f5780633977a3191461074857806341b3a0d91461072957806344bf3c7214610700578063550a1e00146103f857806367aea313146103cf5780637dc0d1d0146103a657838163894ba833146101eb575080638b24dc3e146101935783816394f3f81d1461014957508063a8b30a9f146100eb5763d46e50d0146100c157600080fd5b346100e757826003193601126100e7575490516001600160a01b03909116815260209150f35b8280fd5b5090346100e75760203660031901126100e7576101439135903384528360205261011a6001828620541461082f565b428452600560205261012f8282862054610963565b904285526005602052842055600654610963565b60065580f35b80843461019057602036600319011261019057610164610814565b3383528260205261017a6001838520541461082f565b6001600160a01b03168252602082905281205580f35b50fd5b509190346101e75760203660031901126101e757823560065481845260056020528284205481039081116101d4578394506006558252600560205281205580f35b634e487b7160e01b845260118552602484fd5b5080fd5b808484346103a257826003193601126103a25733835260208381526102156001848620541461082f565b61022360016007541461087b565b600784905560068490556001548351633eaf7a0360e21b815230848201526001600160a01b03909116918082602481865afa918215610398578692610369575b5084516311005b0760e01b815230858201528181602481875afa91821561035f57879261032d575b50508082116103255750905b803b156103215760248592855196879384926327a0bb3360e01b8452878401525af18015610317576102ec575b837f2d4b4ecff7bd7503135271925520a2f6c0d98c9473ffc1a1e72c92502f51b25e8180a180f35b6001600160401b0383116103045750528180806102c4565b634e487b7160e01b845260419052602483fd5b82513d86823e3d90fd5b8480fd5b905090610297565b90809250813d8311610358575b61034481836108d3565b810103126103545751878061028b565b8580fd5b503d61033a565b86513d89823e3d90fd5b9080925081813d8311610391575b61038181836108d3565b8101031261035457519087610263565b503d610377565b85513d88823e3d90fd5b5050fd5b5050346101e757816003193601126101e75760035490516001600160a01b039091168152602090f35b5050346101e757816003193601126101e75760015490516001600160a01b039091168152602090f35b508290346101e757826003193601126101e757610413610814565b9060249081359160018060a01b039384600254169487519563de51eefd60e01b875286828416918287830152818660209a8b935afa9081156106a25789916106d3575b50156106be57670de0b6b3a7640000918287029287840414871517156106ac5787816003541692868c5180958193631735856760e31b83528b8301525afa9182156106a257899261066f575b50811561065d5785548a516323b872dd60e01b8a8201908152338883015230604483015260648083018b905282526001600160401b0393909216919060a081018481118282101761064b578d52518b9283929083905af1610501610924565b8161061b575b50156105f3578951918883019363a9059cbb60e01b85523387850152046044830152604482526080820190828210908211176105e157895251879283929083905af1610551610924565b816105b1575b501561058a5750507f062234b32cab33fa5bcd957e318141fefab38cc79f25ec5b972be8392e98cb6c929351908152a180f35b855162461bcd60e51b81529182018490526002908201526114d560f21b6044820152606490fd5b805180159250869083156105c9575b50505087610557565b6105d9935082018101910161090c565b8785816105c0565b634e487b7160e01b8952604186528489fd5b895162461bcd60e51b81528087018990526003818701526229aa2360e91b6044820152606490fd5b8051801592508a908315610633575b5050508b610507565b610643935082018101910161090c565b8b898161062a565b634e487b7160e01b8d5260418a52888dfd5b634e487b7160e01b8952601286528489fd5b9091508781813d831161069b575b61068781836108d3565b810103126106975751908a6104a2565b8880fd5b503d61067d565b8a513d8b823e3d90fd5b634e487b7160e01b8952601186528489fd5b8484918a5191633935d9fb60e21b8352820152fd5b6106f39150883d8a116106f9575b6106eb81836108d3565b81019061090c565b8a610456565b503d6106e1565b5050346101e757816003193601126101e75760025490516001600160a01b039091168152602090f35b5050346101e757816003193601126101e7576020906007549051908152f35b50346100e75760203660031901126100e75760209282913581526005845220549051908152f35b5050346101e75760203660031901126101e75760019061078d610814565b338452836020526107a283838620541461082f565b6107af836007541461087b565b828060a01b031683528260205282205580f35b5050346101e757816003193601126101e7576020906006549051908152f35b849084346100e75760203660031901126100e7576020926001600160a01b03610808610814565b16815280845220548152f35b600435906001600160a01b038216820361082a57565b600080fd5b1561083657565b60405162461bcd60e51b815260206004820152601f60248201527f4163636f756e74696e67456e67696e652f6e6f742d617574686f72697a6564006044820152606490fd5b1561088257565b60405162461bcd60e51b8152602060048201526024808201527f4163636f756e74696e67456e67696e652f6e6f742d636f6e7472616374456e61604482015263189b195960e21b6064820152608490fd5b601f909101601f19168101906001600160401b038211908210176108f657604052565b634e487b7160e01b600052604160045260246000fd5b9081602091031261082a5751801515810361082a5790565b3d1561095e573d906001600160401b0382116108f65760405191610952601f8201601f1916602001846108d3565b82523d6000602084013e565b606090565b919082019182811161097757821061082a57565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220278c5ce8ca506106f425971ab87339ff8e4b4d923599a3c9cd833d0730c801ae64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "disableContract()": {
        "details": "When we disable, the contract tries to settle as much debt as possible (if there's any) with any surplus that's left in the system. After erasing debt, the contract will either transfer any remaining surplus right away (if disableCooldown == 0) or will only record the timestamp when it was disabled*"
      },
      "popDebtFromQueue(uint256)": {
        "params": {
          "era": "Timestamp of the block of debt that should be popped out"
        }
      },
      "pushDebtToQueue(uint256)": {
        "details": "Debt is locked in a queue to give the system enough time to auction collateral      and gather surplus",
        "params": {
          "amountToRaise": "Amount of debt to push"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "disableContract()": {
        "notice": "Disable this contract (normally called by Global Settlement)"
      },
      "popDebtFromQueue(uint256)": {
        "notice": "A block of debt can be popped from the queue after popDebtDelay seconds passed since it was         added there"
      },
      "pushDebtToQueue(uint256)": {
        "notice": "Push debt (that the system tries to cover with collateral auctions) to a queue"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 6350,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "authorizedAccounts",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 6402,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "safeEngine",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ISafeEngine)9549"
      },
      {
        "astId": 6405,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "liquidationEngine",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(ILiquidationEngine)9322"
      },
      {
        "astId": 6408,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "oracle",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(ISuOracle)10405"
      },
      {
        "astId": 6410,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "stablePro",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 6414,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "debtQueue",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 6416,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "totalQueuedDebt",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 6418,
        "contract": "contracts/makerdao/externalContracts/AccountingEngine.sol:AccountingEngine",
        "label": "contractEnabled",
        "offset": 0,
        "slot": "7",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(ILiquidationEngine)9322": {
        "encoding": "inplace",
        "label": "contract ILiquidationEngine",
        "numberOfBytes": "20"
      },
      "t_contract(ISafeEngine)9549": {
        "encoding": "inplace",
        "label": "contract ISafeEngine",
        "numberOfBytes": "20"
      },
      "t_contract(ISuOracle)10405": {
        "encoding": "inplace",
        "label": "contract ISuOracle",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}