{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/staking/contracts/Blocklist.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport { IVotingEscrow } from \"../interfaces/IVotingEscrow.sol\";\n\n/// @title A blocklist for contracts\n/// @notice Allows blocking of contracts. Blocking a contract also\n/// forces the undelegation of that lock in the VotingEscrow contract\n/// @dev Blocking can be circumvented by a deterministically created\n/// (create2) contract that selfdestructs after execution of instructions\n/// In such a scenario the Blocklist may have to be replaced with new\n/// one that also supports blocking of addresses in general\ncontract Blocklist {\n    mapping(address => bool) private _blocklist;\n    address public immutable manager;\n    address public immutable ve;\n\n    /// @notice Initializes state\n    /// @param _manager Owner of the blocklist contract\n    /// @param _ve Address of the `VotingEscrow` contract\n    constructor(address _manager, address _ve) {\n        manager = _manager;\n        ve = _ve;\n    }\n\n    /// @notice Add address to blocklist\n    /// @param addr The contract address to blocklist\n    /// @dev Is only callable by the Blocklist owner\n    /// Allows blocklisting only of contracts\n    function blockContract(address addr) external {\n        require(msg.sender == manager, \"Only manager\");\n        require(addr.code.length > 0, \"Only contracts\");\n        _blocklist[addr] = true;\n        IVotingEscrow(ve).forceUndelegate(addr);\n    }\n\n    /// @notice Check an address\n    /// @param addr The contract address to check\n    /// @return Whether `addr` is blocked or not\n    /// @dev This method will be called by the VotingEscrow contract\n    function isBlocked(address addr) external view returns (bool) {\n        return _blocklist[addr];\n    }\n}"
    },
    "contracts/staking/contracts/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.3;\n\nimport {\nReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {\nSafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\nIERC20Metadata\n} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IVotingEscrow } from \"../interfaces/IVotingEscrow.sol\";\nimport { IBlocklist } from \"../interfaces/IBlocklist.sol\";\n\n/// @title  Delegated Voting Escrow\n/// @notice An ERC20 token that allocates users a virtual balance depending\n/// on the amount of tokens locked and their remaining lock duration. The\n/// virtual balance decreases linearly with the remaining lock duration.\n/// This is the locking mechanism known from veCRV with additional features:\n/// - Delegation of lock and voting power\n/// - Quit an existing lock and pay a penalty\n/// - Optimistic approval of SmartWallets through Blocklist\n/// - Reduced pointHistory array size and, as a result, lifetime of the contract\n/// - Removed public deposit_for and Aragon compatibility (no use case)\n/// @dev Builds on Curve Finance's original VotingEscrow implementation\n/// (see https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// and mStable's Solidity translation thereof\n/// (see https://github.com/mstable/mStable-contracts/blob/master/contracts/governance/IncentivisedVotingLockup.sol)\n/// Usage of this contract is not safe with all tokens, specifically:\n/// - Contract does not support tokens with maxSupply>2^128-10^[decimals]\n/// - Contract does not support fee-on-transfer tokens\n/// - Contract may be unsafe for tokens with decimals<6\n\n//// TODO: also we can use implementation from Pendle https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/LiquidityMining/VotingEscrow/VotingEscrowPendleMainchain.sol\n//// or https://github.com/chimera-defi/SharedDeposit/blob/main/contracts/governance/voteEscrow.sol\n//// or from Cream.finance, Fixed Forex, Iron.finance, Firebird.finance, Pickle.finance\ncontract VotingEscrow is IVotingEscrow, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Shared Events\n    event Deposit(\n        address indexed provider,\n        uint256 value,\n        uint256 locktime,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event Withdraw(\n        address indexed provider,\n        uint256 value,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event TransferOwnership(address indexed owner);\n    event UpdateBlocklist(address indexed blocklist);\n    event UpdatePenaltyRecipient(address indexed recipient);\n    event CollectPenalty(uint256 amount, address indexed recipient);\n    event Unlock();\n\n    // Shared global state\n    IERC20 public immutable token;\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MAXTIME = 730 days;\n    uint256 public constant MULTIPLIER = 1e18;\n    address public owner;\n    address public penaltyRecipient; // receives collected penalty payments\n    uint256 public maxPenalty = 1e18; // penalty for quitters with MAXTIME remaining lock\n    uint256 public penaltyAccumulated; // accumulated and unwithdrawn penalty payments\n    address public blocklist;\n    uint256 public supply;\n\n    // Lock state\n    uint256 public globalEpoch;\n    Point[1000000000000000000] public pointHistory; // 1e9 * userPointHistory-length, so sufficient for 1e9 users\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges;\n    mapping(address => LockedBalance) public locked;\n\n    // Voting token\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n\n    // Structs\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n    struct LockedBalance {\n        int128 amount;\n        int128 delegated;\n        uint96 end;\n        address delegatee;\n    }\n\n    // Miscellaneous\n    enum LockAction {\n        CREATE,\n        INCREASE_AMOUNT,\n        INCREASE_AMOUNT_AND_DELEGATION,\n        INCREASE_TIME,\n        WITHDRAW,\n        QUIT,\n        DELEGATE,\n        UNDELEGATE\n    }\n\n    /// @notice Initializes state\n    /// @param _owner Is assumed to be a timelock contract\n    /// @param _penaltyRecipient The recipient of penalty paid by lock quitters\n    /// @param _token The token locked in order to obtain voting power\n    /// @param _name The name of the voting token\n    /// @param _symbol The symbol of the voting token\n    constructor(\n        address _owner,\n        address _penaltyRecipient,\n        address _token,\n        string memory _name,\n        string memory _symbol\n    ) {\n        token = IERC20(_token);\n        pointHistory[0] = Point({\n            bias: int128(0),\n            slope: int128(0),\n            ts: block.timestamp,\n            blk: block.number\n        });\n\n        decimals = IERC20Metadata(_token).decimals();\n        require(decimals <= 18, \"Exceeds max decimals\");\n\n        name = _name;\n        symbol = _symbol;\n        owner = _owner;\n        penaltyRecipient = _penaltyRecipient;\n    }\n\n    modifier checkBlocklist() {\n        require(\n            !IBlocklist(blocklist).isBlocked(msg.sender),\n            \"Blocked contract\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       Owner Functions       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Transfers ownership to a new owner\n    /// @param _addr The new owner\n    /// @dev Owner is assumed to be a timelock contract\n    function transferOwnership(address _addr) external onlyOwner {\n        owner = _addr;\n        emit TransferOwnership(_addr);\n    }\n\n    /// @notice Updates the blocklist contract\n    function updateBlocklist(address _addr) external onlyOwner {\n        blocklist = _addr;\n        emit UpdateBlocklist(_addr);\n    }\n\n    /// @notice Updates the recipient of the accumulated penalty paid by quitters\n    function updatePenaltyRecipient(address _addr) external onlyOwner {\n        penaltyRecipient = _addr;\n        emit UpdatePenaltyRecipient(_addr);\n    }\n\n    /// @notice Removes quitlock penalty by setting it to zero\n    /// @dev This is an irreversible action and is assumed to be used in\n    /// a migration to a new VotingEscrow contract only\n    function unlock() external onlyOwner {\n        maxPenalty = 0;\n        emit Unlock();\n    }\n\n    /// @notice Remove delegation for blocked contract\n    /// @param _addr user to which voting power is delegated\n    /// @dev Only callable by the blocklist contract\n    function forceUndelegate(address _addr) external override {\n        require(msg.sender == blocklist, \"Only Blocklist\");\n        LockedBalance memory locked_ = locked[_addr];\n        address delegatee = locked_.delegatee;\n        int128 value = locked_.amount;\n\n        if (delegatee != _addr && value > 0) {\n            LockedBalance memory fromLocked;\n            locked_.delegatee = _addr;\n            fromLocked = locked[delegatee];\n            locked_.end = fromLocked.end;\n            _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n            _delegate(_addr, locked_, value, LockAction.DELEGATE);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       LOCK MANAGEMENT       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Returns a lock's expiration\n    /// @param _addr The address of the lock owner\n    /// @return Expiration of the lock\n    function lockEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /// @notice Returns a lock's last available user point\n    /// @param _addr The address of the lock owner\n    /// @return bias The last recorded virtual balance\n    /// @return slope The last recorded linear decay\n    /// @return ts The last recorded timestamp\n    function getLastUserPoint(address _addr)\n    external\n    view\n    returns (\n        int128 bias,\n        int128 slope,\n        uint256 ts\n    )\n    {\n        uint256 uepoch = userPointEpoch[_addr];\n        if (uepoch == 0) {\n            return (0, 0, 0);\n        }\n        Point memory point = userPointHistory[_addr][uepoch];\n        return (point.bias, point.slope, point.ts);\n    }\n\n    /// @notice Records a checkpoint of both individual and global slope\n    /// @param _addr The address of the lock owner, or address(0) for only global\n    /// @param _oldLocked Old amount that user had locked, or null for global\n    /// @param _newLocked New amount that user has locked, or null for global\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _oldLocked,\n        LockedBalance memory _newLocked\n    ) internal {\n        Point memory userOldPoint;\n        Point memory userNewPoint;\n        int128 oldSlopeDelta = 0;\n        int128 newSlopeDelta = 0;\n        uint256 epoch = globalEpoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            // Casting in the next blocks is safe given that MAXTIME is a small\n            // positive number and we check for _oldLocked.end>block.timestamp\n            // and _newLocked.end>block.timestamp\n            if (_oldLocked.end > block.timestamp && _oldLocked.delegated > 0) {\n                userOldPoint.slope =\n                    _oldLocked.delegated /\n                    int128(int256(MAXTIME));\n                userOldPoint.bias =\n                    userOldPoint.slope *\n                    int128(int256(_oldLocked.end - block.timestamp));\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.delegated > 0) {\n                userNewPoint.slope =\n                    _newLocked.delegated /\n                    int128(int256(MAXTIME));\n                userNewPoint.bias =\n                    userNewPoint.slope *\n                    int128(int256(_newLocked.end - block.timestamp));\n            }\n\n            // Moved from bottom final if statement to resolve stack too deep err\n            // start {\n            // Now handle user history\n            uint256 uEpoch = userPointEpoch[_addr];\n\n            userPointEpoch[_addr] = uEpoch + 1;\n            userNewPoint.ts = block.timestamp;\n            userNewPoint.blk = block.number;\n            userPointHistory[_addr][uEpoch + 1] = userNewPoint;\n\n            // } end\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldSlopeDelta = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newSlopeDelta = oldSlopeDelta;\n                } else {\n                    newSlopeDelta = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint =\n                        Point({\n                bias: 0,\n                slope: 0,\n                ts: block.timestamp,\n                blk: block.number\n            });\n        if (epoch > 0) {\n            lastPoint = pointHistory[epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint =\n                        Point({ bias: 0, slope: 0, ts: lastPoint.ts, blk: lastPoint.blk });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 iterativeTime = _floorToWeek(lastCheckpoint);\n        for (uint256 i; i < 255; ) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            if (iterativeTime > block.timestamp) {\n                iterativeTime = block.timestamp;\n            } else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n            int128 biasDelta =\n                lastPoint.slope *\n                int128(int256((iterativeTime - lastCheckpoint)));\n            lastPoint.bias = lastPoint.bias - biasDelta;\n            lastPoint.slope = lastPoint.slope + dSlope;\n            // This can happen\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // This cannot happen - just in case\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = iterativeTime;\n            lastPoint.ts = iterativeTime;\n            lastPoint.blk =\n                initialLastPoint.blk +\n                (blockSlope * (iterativeTime - initialLastPoint.ts)) /\n                MULTIPLIER;\n\n            // when epoch is incremented, we either push here or after slopes updated below\n            epoch = epoch + 1;\n            if (iterativeTime == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                pointHistory[epoch] = lastPoint;\n            }\n            unchecked { ++i; }\n        }\n\n        globalEpoch = epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope =\n                lastPoint.slope +\n                userNewPoint.slope -\n                userOldPoint.slope;\n            lastPoint.bias =\n                lastPoint.bias +\n                userNewPoint.bias -\n                userOldPoint.bias;\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        pointHistory[epoch] = lastPoint;\n\n        if (_addr != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldSlopeDelta was <something> - userOldPoint.slope, so we cancel that\n                oldSlopeDelta = oldSlopeDelta + userOldPoint.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldSlopeDelta = oldSlopeDelta - userNewPoint.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = oldSlopeDelta;\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    newSlopeDelta = newSlopeDelta - userNewPoint.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = newSlopeDelta;\n                }\n                // else: we recorded it already in oldSlopeDelta\n            }\n        }\n    }\n\n    /// @notice Records a new global checkpoint\n    function checkpoint() external {\n        LockedBalance memory empty;\n        _checkpoint(address(0), empty, empty);\n    }\n\n    /// @notice Creates a new lock\n    /// @param _value Amount of token to lock\n    /// @param _unlockTime Expiration time of the lock\n    /// @dev `_value` is (unsafely) downcasted from `uint256` to `int128`\n    /// and `_unlockTime` is (unsafely) downcasted from `uint256` to `uint96`\n    /// assuming that the values never reach the respective max values\n    function createLock(uint256 _value, uint256 _unlockTime)\n    external\n    override\n    nonReentrant\n    checkBlocklist\n    {\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value != 0, \"Only non zero amount\");\n        require(locked_.amount == 0, \"Lock exists\");\n        require(unlock_time >= locked_.end, \"Only increase lock end\"); // from using quitLock, user should increaseAmount instead\n        require(unlock_time > block.timestamp, \"Only future lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update total supply of token deposited\n        supply = supply + _value;\n        // Update lock and voting power (checkpoint)\n        // Casting in the next block is safe given that we check for _value>0 and the\n        // totalSupply of tokens is generally significantly lower than the int128.max\n        // value (considering the max precision of 18 decimals enforced in the constructor)\n        locked_.amount = locked_.amount + int128(int256(_value));\n        locked_.end = uint96(unlock_time);\n        locked_.delegated = locked_.delegated + int128(int256(_value));\n        locked_.delegatee = msg.sender;\n        locked[msg.sender] = locked_;\n        _checkpoint(msg.sender, LockedBalance(0, 0, 0, address(0)), locked_);\n        // Deposit locked tokens\n        token.safeTransferFrom(msg.sender, address(this), _value);\n        emit Deposit(\n            msg.sender,\n            _value,\n            unlock_time,\n            LockAction.CREATE,\n            block.timestamp\n        );\n    }\n\n    /// @notice Locks more tokens in an existing lock\n    /// @param _value Amount of tokens to add to the lock\n    /// @dev Does not update the lock's expiration\n    /// Does record a new checkpoint for the lock\n    /// `_value` is (unsafely) downcasted from `uint256` to `int128` assuming\n    /// that the max value is never reached in practice\n    function increaseAmount(uint256 _value)\n    external\n    override\n    nonReentrant\n    checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value != 0, \"Only non zero amount\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        // Update total supply of token deposited\n        supply = supply + _value;\n        // Update lock\n        address delegatee = locked_.delegatee;\n        uint256 unlockTime = locked_.end;\n        LockAction action = LockAction.INCREASE_AMOUNT;\n        LockedBalance memory newLocked;\n        // Casting in the next block is safe given that we check for _value>0 and the\n        // totalSupply of tokens is generally significantly lower than the int128.max\n        // value (considering the max precision of 18 decimals enforced in the constructor)\n        if (delegatee == msg.sender) {\n            // Undelegated lock\n            action = LockAction.INCREASE_AMOUNT_AND_DELEGATION;\n            newLocked = _copyLock(locked_);\n            newLocked.amount = newLocked.amount + int128(int256(_value));\n            newLocked.delegated = newLocked.delegated + int128(int256(_value));\n            locked[msg.sender] = newLocked;\n        } else {\n            // Delegated lock, update sender's lock first\n            locked_.amount = locked_.amount + int128(int256(_value));\n            locked[msg.sender] = locked_;\n            // Then, update delegatee's lock and voting power (checkpoint)\n            locked_ = locked[delegatee];\n            require(locked_.amount > 0, \"Delegatee has no lock\");\n            require(locked_.end > block.timestamp, \"Delegatee lock expired\");\n            newLocked = _copyLock(locked_);\n            newLocked.delegated = newLocked.delegated + int128(int256(_value));\n            locked[delegatee] = newLocked;\n            emit Deposit(\n                delegatee,\n                _value,\n                newLocked.end,\n                LockAction.DELEGATE,\n                block.timestamp\n            );\n        }\n        // Checkpoint only for delegatee\n        _checkpoint(delegatee, locked_, newLocked);\n        // Deposit locked tokens\n        token.safeTransferFrom(msg.sender, address(this), _value);\n        emit Deposit(msg.sender, _value, unlockTime, action, block.timestamp);\n    }\n\n    /// @notice Extends the expiration of an existing lock\n    /// @param _unlockTime New lock expiration time\n    /// @dev Does not update the amount of tokens locked\n    /// Does record a new checkpoint for the lock\n    /// `_unlockTime` is (unsafely) downcasted from `uint256` to `uint96`\n    /// assuming that the max value is never reached in practice\n    function increaseUnlockTime(uint256 _unlockTime)\n    external\n    override\n    nonReentrant\n    checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        require(unlock_time > locked_.end, \"Only increase lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock\n        uint256 oldUnlockTime = locked_.end;\n        locked_.end = uint96(unlock_time);\n        locked[msg.sender] = locked_;\n        if (locked_.delegated > 0) {\n            // Lock with non-zero virtual balance\n            LockedBalance memory oldLocked = _copyLock(locked_);\n            oldLocked.end = uint96(oldUnlockTime);\n            _checkpoint(msg.sender, oldLocked, locked_);\n        }\n        emit Deposit(\n            msg.sender,\n            0,\n            unlock_time,\n            LockAction.INCREASE_TIME,\n            block.timestamp\n        );\n    }\n\n    /// @notice Withdraws the tokens of an expired lock\n    /// Delegated locks need to be undelegated first\n    function withdraw() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end <= block.timestamp, \"Lock not expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update total supply of token deposited\n        uint256 value = uint256(uint128(locked_.amount));\n        supply = supply - value;\n        // Update lock\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.end = 0;\n        newLocked.delegated = newLocked.delegated - locked_.amount;\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // Send back deposited tokens\n        token.safeTransfer(msg.sender, value);\n        emit Withdraw(msg.sender, value, LockAction.WITHDRAW, block.timestamp);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         DELEGATION         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Delegate lock and voting power to another lock\n    /// The receiving lock needs to have a longer lock duration\n    /// The delegated lock will inherit the receiving lock's expiration\n    /// @param _addr The address of the lock owner to which to delegate\n    function delegate(address _addr)\n    external\n    override\n    nonReentrant\n    checkBlocklist\n    {\n        // Different restrictions apply to undelegation\n        if (_addr == msg.sender) {\n            _undelegate();\n            return;\n        }\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(!IBlocklist(blocklist).isBlocked(_addr), \"Blocked contract\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        require(locked_.delegatee != _addr, \"Already delegated\");\n        // Update locks\n        int128 value = locked_.amount;\n        address delegatee = locked_.delegatee;\n        LockedBalance memory toLocked = locked[_addr];\n        locked_.delegatee = _addr;\n        if (delegatee != msg.sender) {\n            locked[msg.sender] = locked_;\n            locked_ = locked[delegatee];\n        }\n        require(toLocked.amount > 0, \"Delegatee has no lock\");\n        require(toLocked.end > block.timestamp, \"Delegatee lock expired\");\n        require(toLocked.end >= locked_.end, \"Only delegate to longer lock\");\n        _delegate(delegatee, locked_, value, LockAction.UNDELEGATE);\n        _delegate(_addr, toLocked, value, LockAction.DELEGATE);\n    }\n\n    // Undelegates sender's lock\n    // Can be executed on expired locks too\n    // Owner inherits delegatee's unlockTime if it exceeds owner's\n    function _undelegate() internal {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.delegatee != msg.sender, \"Already undelegated\");\n        // Update locks\n        int128 value = locked_.amount;\n        address delegatee = locked_.delegatee;\n        LockedBalance memory fromLocked = locked[delegatee];\n        locked_.delegatee = msg.sender;\n        if (locked_.end < fromLocked.end) {\n            locked_.end = fromLocked.end;\n        }\n        _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n        _delegate(msg.sender, locked_, value, LockAction.DELEGATE);\n    }\n\n    // Delegates from/to lock and voting power\n    function _delegate(\n        address addr,\n        LockedBalance memory _locked,\n        int128 value,\n        LockAction action\n    ) internal {\n        LockedBalance memory newLocked = _copyLock(_locked);\n        if (action == LockAction.DELEGATE) {\n            newLocked.delegated = newLocked.delegated + value;\n            emit Deposit(\n                addr,\n                uint256(int256(value)),\n                newLocked.end,\n                action,\n                block.timestamp\n            );\n        } else {\n            newLocked.delegated = newLocked.delegated - value;\n            emit Withdraw(\n                addr,\n                uint256(int256(value)),\n                action,\n                block.timestamp\n            );\n        }\n        locked[addr] = newLocked;\n        if (newLocked.amount > 0) {\n            // Only if lock (from lock) hasn't been withdrawn/quitted\n            _checkpoint(addr, _locked, newLocked);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         QUIT LOCK          ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Quit an existing lock by withdrawing all tokens less a penalty\n    /// Use `withdraw` for expired locks\n    /// @dev Quitters lock expiration remains in place because it might be delegated to\n    function quitLock() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update total supply of token deposited\n        uint256 value = uint256(uint128(locked_.amount));\n        supply = supply - value;\n        // Update lock\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.delegated = newLocked.delegated - locked_.amount;\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.end = 0;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // apply penalty\n        uint256 penaltyRate = _calculatePenaltyRate(locked_.end);\n        uint256 penaltyAmount = (value * penaltyRate) / 1e18; // quitlock_penalty is in 18 decimals precision\n        penaltyAccumulated = penaltyAccumulated + penaltyAmount;\n        uint256 remainingAmount = value - penaltyAmount;\n        // Send back remaining tokens\n        token.safeTransfer(msg.sender, remainingAmount);\n        emit Withdraw(msg.sender, value, LockAction.QUIT, block.timestamp);\n    }\n\n    /// @notice Returns the penalty rate for a given lock expiration\n    /// @param end The lock's expiration\n    /// @return The penalty rate applicable to the lock\n    /// @dev The penalty rate decreases linearly at the same rate as a lock's voting power\n    /// in order to compensate for votes unlocked without committing to the lock expiration\n    function getPenaltyRate(uint256 end) external view returns (uint256) {\n        return _calculatePenaltyRate(end);\n    }\n\n    // Calculate penalty rate\n    // Penalty rate decreases linearly at the same rate as a lock's voting power\n    // in order to compensate for votes used\n    function _calculatePenaltyRate(uint256 end)\n    internal\n    view\n    returns (uint256)\n    {\n        // We know that end > block.timestamp because expired locks cannot be quitted\n        return ((end - block.timestamp) * maxPenalty) / MAXTIME;\n    }\n\n    /// @notice Collect accumulated penalty from lock quitters\n    /// Everyone can collect but penalty is sent to `penaltyRecipient`\n    function collectPenalty() external {\n        uint256 amount = penaltyAccumulated;\n        penaltyAccumulated = 0;\n        address recipient = penaltyRecipient;\n        token.safeTransfer(recipient, amount);\n        emit CollectPenalty(amount, recipient);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///            GETTERS         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // Creates a copy of a lock\n    function _copyLock(LockedBalance memory _locked)\n    internal\n    pure\n    returns (LockedBalance memory)\n    {\n        return\n            LockedBalance({\n            amount: _locked.amount,\n            end: _locked.end,\n            delegatee: _locked.delegatee,\n            delegated: _locked.delegated\n        });\n    }\n\n    // Floors a timestamp to the nearest weekly increment\n    function _floorToWeek(uint256 _t) internal pure returns (uint256) {\n        return (_t / WEEK) * WEEK;\n    }\n\n    // Uses binarysearch to find the most recent point history preceeding block\n    // Find the most recent point history before _block\n    // Do not search pointHistories past _maxEpoch\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch)\n    internal\n    view\n    returns (uint256)\n    {\n        // Binary search\n        uint256 min = 0;\n        uint256 max = _maxEpoch;\n        // Will be always enough for 128-bit numbers\n        for (uint256 i; i < 128; ) {\n            if (min >= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            if (pointHistory[mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n            unchecked { ++i; }\n        }\n        return min;\n    }\n\n    // Uses binarysearch to find the most recent user point history preceeding block\n    // _addr is the lock owner for which to search\n    // Find the most recent point history before _block\n    function _findUserBlockEpoch(address _addr, uint256 _block)\n    internal\n    view\n    returns (uint256)\n    {\n        uint256 min = 0;\n        uint256 max = userPointEpoch[_addr];\n        for (uint256 i; i < 128; ) {\n            if (min >= max) {\n                break;\n            }\n            uint256 mid = (min + max + 1) / 2;\n            if (userPointHistory[_addr][mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n            unchecked { ++i; }\n        }\n        return min;\n    }\n\n    /// @notice Get a lock's current voting power\n    /// @param _owner The address of the lock owner for which to return voting power\n    /// @return Voting power of the lock\n    function balanceOf(address _owner) public view override returns (uint256) {\n        uint256 epoch = userPointEpoch[_owner];\n        if (epoch == 0) {\n            return 0;\n        }\n        // Casting is safe given that checkpoints are recorded in the past\n        // and are more frequent than every int128.max seconds\n        Point memory lastPoint = userPointHistory[_owner][epoch];\n        lastPoint.bias =\n            lastPoint.bias -\n            (lastPoint.slope * int128(int256(block.timestamp - lastPoint.ts)));\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    /// @notice Get a lock's voting power at a given block number\n    /// @param _owner The address of the lock owner for which to return voting power\n    /// @param _blockNumber The block at which to calculate the lock's voting power\n    /// @return uint256 Voting power of the lock\n    function balanceOfAt(address _owner, uint256 _blockNumber)\n    public\n    view\n    override\n    returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        // Get most recent user Point to block\n        uint256 userEpoch = _findUserBlockEpoch(_owner, _blockNumber);\n        if (userEpoch == 0) {\n            return 0;\n        }\n        Point memory upoint = userPointHistory[_owner][userEpoch];\n\n        // Get most recent global Point to block\n        uint256 maxEpoch = globalEpoch;\n        uint256 epoch = _findBlockEpoch(_blockNumber, maxEpoch);\n        Point memory point0 = pointHistory[epoch];\n\n        // Calculate delta (block & time) between user Point and target block\n        // Allowing us to calculate the average seconds per block between\n        // the two points\n        uint256 dBlock = 0;\n        uint256 dTime = 0;\n        if (epoch < maxEpoch) {\n            Point memory point1 = pointHistory[epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dTime = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dTime = block.timestamp - point0.ts;\n        }\n        // (Deterministically) Estimate the time at which block _blockNumber was mined\n        uint256 blockTime = point0.ts;\n        if (dBlock != 0) {\n            blockTime =\n                blockTime +\n                ((dTime * (_blockNumber - point0.blk)) / dBlock);\n        }\n        // Current Bias = most recent bias - (slope * time since update)\n        // Casting is safe given that checkpoints are recorded in the past\n        // and are more frequent than every int128.max seconds\n        upoint.bias =\n            upoint.bias -\n            (upoint.slope * int128(int256(blockTime - upoint.ts)));\n        if (upoint.bias >= 0) {\n            return uint256(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    // Calculate total supply of voting power at a given time _t\n    // _point is the most recent point before time _t\n    // _t is the time at which to calculate supply\n    function _supplyAt(Point memory _point, uint256 _t)\n    internal\n    view\n    returns (uint256)\n    {\n        Point memory lastPoint = _point;\n        // Floor the timestamp to weekly interval\n        uint256 iterativeTime = _floorToWeek(lastPoint.ts);\n        // Iterate through all weeks between _point & _t to account for slope changes\n        for (uint256 i; i < 255; ) {\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            // If week end is after timestamp, then truncate & leave dSlope to 0\n            if (iterativeTime > _t) {\n                iterativeTime = _t;\n            }\n                // else get most recent slope change\n            else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n\n            // Casting is safe given that lastPoint.ts < iterativeTime and\n            // iteration goes over 255 weeks max\n            lastPoint.bias =\n                lastPoint.bias -\n                (lastPoint.slope *\n                    int128(int256(iterativeTime - lastPoint.ts)));\n            if (iterativeTime == _t) {\n                break;\n            }\n            lastPoint.slope = lastPoint.slope + dSlope;\n            lastPoint.ts = iterativeTime;\n\n            unchecked { ++i; }\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    /// @notice Calculate current total supply of voting power\n    /// @return Current totalSupply\n    function totalSupply() public view override returns (uint256) {\n        uint256 epoch_ = globalEpoch;\n        Point memory lastPoint = pointHistory[epoch_];\n        return _supplyAt(lastPoint, block.timestamp);\n    }\n\n    /// @notice Calculate total supply of voting power at a given block number\n    /// @param _blockNumber The block number at which to calculate total supply\n    /// @return totalSupply of voting power at the given block number\n    function totalSupplyAt(uint256 _blockNumber)\n    public\n    view\n    override\n    returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        uint256 epoch = globalEpoch;\n        uint256 targetEpoch = _findBlockEpoch(_blockNumber, epoch);\n\n        Point memory point = pointHistory[targetEpoch];\n\n        // If point.blk > _blockNumber that means we got the initial epoch & contract did not yet exist\n        if (point.blk > _blockNumber) {\n            return 0;\n        }\n\n        uint256 dTime = 0;\n        if (targetEpoch < epoch) {\n            Point memory pointNext = pointHistory[targetEpoch + 1];\n            if (point.blk != pointNext.blk) {\n                dTime =\n                    ((_blockNumber - point.blk) * (pointNext.ts - point.ts)) /\n                    (pointNext.blk - point.blk);\n            }\n        } else if (point.blk != block.number) {\n            dTime =\n                ((_blockNumber - point.blk) * (block.timestamp - point.ts)) /\n                (block.number - point.blk);\n        }\n        // Now dTime contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dTime);\n    }\n}"
    },
    "contracts/staking/interfaces/IBlocklist.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ninterface IBlocklist {\n    function isBlocked(address addr) external view returns (bool);\n}"
    },
    "contracts/staking/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.3;\n\ninterface IVotingEscrow {\n    function createLock(uint256 _value, uint256 _unlockTime) external;\n\n    function increaseAmount(uint256 _value) external;\n\n    function increaseUnlockTime(uint256 _unlockTime) external;\n\n    function withdraw() external;\n\n    function delegate(address _addr) external;\n\n    function quitLock() external;\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function balanceOfAt(address _owner, uint256 _blockNumber)\n    external\n    view\n    returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function totalSupplyAt(uint256 _blockNumber)\n    external\n    view\n    returns (uint256);\n\n    function forceUndelegate(address _addr) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}