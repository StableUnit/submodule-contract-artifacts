{
  "language": "Solidity",
  "sources": {
    "@balancer-labs/v2-interfaces/contracts/pool-stable/StablePoolUserData.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary StablePoolUserData {\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT, ALL_TOKENS_IN_FOR_EXACT_BPT_OUT }\n    enum ExitKind { EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT, EXACT_BPT_IN_FOR_ALL_TOKENS_OUT }\n\n    function joinKind(bytes memory self) internal pure returns (JoinKind) {\n        return abi.decode(self, (JoinKind));\n    }\n\n    function exitKind(bytes memory self) internal pure returns (ExitKind) {\n        return abi.decode(self, (ExitKind));\n    }\n\n    // Joins\n\n    function initialAmountsIn(bytes memory self) internal pure returns (uint256[] memory amountsIn) {\n        (, amountsIn) = abi.decode(self, (JoinKind, uint256[]));\n    }\n\n    function exactTokensInForBptOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsIn, uint256 minBPTAmountOut)\n    {\n        (, amountsIn, minBPTAmountOut) = abi.decode(self, (JoinKind, uint256[], uint256));\n    }\n\n    function tokenInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut, uint256 tokenIndex) {\n        (, bptAmountOut, tokenIndex) = abi.decode(self, (JoinKind, uint256, uint256));\n    }\n\n    function allTokensInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut) {\n        (, bptAmountOut) = abi.decode(self, (JoinKind, uint256));\n    }\n\n    // Exits\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (ExitKind, uint256, uint256));\n    }\n\n    function exactBptInForTokensOut(bytes memory self) internal pure returns (uint256 bptAmountIn) {\n        (, bptAmountIn) = abi.decode(self, (ExitKind, uint256));\n    }\n\n    function bptInForExactTokensOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsOut, uint256 maxBPTAmountIn)\n    {\n        (, amountsOut, maxBPTAmountIn) = abi.decode(self, (ExitKind, uint256[], uint256));\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/core/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nlibrary Errors {\n    // BulkSeller\n    error BulkInsufficientSyForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInsufficientTokenForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInSufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error BulkInSufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error BulkInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error BulkNotMaintainer();\n    error BulkNotAdmin();\n    error BulkSellerAlreadyExisted(address token, address SY, address bulk);\n    error BulkSellerInvalidToken(address token, address SY);\n    error BulkBadRateTokenToSy(uint256 actualRate, uint256 currentRate, uint256 eps);\n    error BulkBadRateSyToToken(uint256 actualRate, uint256 currentRate, uint256 eps);\n\n    // APPROX\n    error ApproxFail();\n    error ApproxParamsInvalid(uint256 guessMin, uint256 guessMax, uint256 eps);\n    error ApproxBinarySearchInputInvalid(\n        uint256 approxGuessMin,\n        uint256 approxGuessMax,\n        uint256 minGuessMin,\n        uint256 maxGuessMax\n    );\n\n    // MARKET + MARKET MATH CORE\n    error MarketExpired();\n    error MarketZeroAmountsInput();\n    error MarketZeroAmountsOutput();\n    error MarketZeroLnImpliedRate();\n    error MarketInsufficientPtForTrade(int256 currentAmount, int256 requiredAmount);\n    error MarketInsufficientPtReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketZeroTotalPtOrTotalAsset(int256 totalPt, int256 totalAsset);\n    error MarketExchangeRateBelowOne(int256 exchangeRate);\n    error MarketProportionMustNotEqualOne();\n    error MarketRateScalarBelowZero(int256 rateScalar);\n    error MarketScalarRootBelowZero(int256 scalarRoot);\n    error MarketProportionTooHigh(int256 proportion, int256 maxProportion);\n\n    error OracleUninitialized();\n    error OracleTargetTooOld(uint32 target, uint32 oldest);\n    error OracleZeroCardinality();\n\n    error MarketFactoryExpiredPt();\n    error MarketFactoryInvalidPt();\n    error MarketFactoryMarketExists();\n\n    error MarketFactoryLnFeeRateRootTooHigh(uint80 lnFeeRateRoot, uint256 maxLnFeeRateRoot);\n    error MarketFactoryReserveFeePercentTooHigh(\n        uint8 reserveFeePercent,\n        uint8 maxReserveFeePercent\n    );\n    error MarketFactoryZeroTreasury();\n    error MarketFactoryInitialAnchorTooLow(int256 initialAnchor, int256 minInitialAnchor);\n\n    // ROUTER\n    error RouterInsufficientLpOut(uint256 actualLpOut, uint256 requiredLpOut);\n    error RouterInsufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error RouterInsufficientPtOut(uint256 actualPtOut, uint256 requiredPtOut);\n    error RouterInsufficientYtOut(uint256 actualYtOut, uint256 requiredYtOut);\n    error RouterInsufficientPYOut(uint256 actualPYOut, uint256 requiredPYOut);\n    error RouterInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error RouterExceededLimitSyIn(uint256 actualSyIn, uint256 limitSyIn);\n    error RouterExceededLimitPtIn(uint256 actualPtIn, uint256 limitPtIn);\n    error RouterExceededLimitYtIn(uint256 actualYtIn, uint256 limitYtIn);\n    error RouterInsufficientSyRepay(uint256 actualSyRepay, uint256 requiredSyRepay);\n    error RouterInsufficientPtRepay(uint256 actualPtRepay, uint256 requiredPtRepay);\n    error RouterNotAllSyUsed(uint256 netSyDesired, uint256 netSyUsed);\n\n    error RouterTimeRangeZero();\n    error RouterCallbackNotPendleMarket(address caller);\n    error RouterInvalidAction(bytes4 selector);\n    error RouterInvalidFacet(address facet);\n\n    error RouterKyberSwapDataZero();\n\n    // YIELD CONTRACT\n    error YCExpired();\n    error YCNotExpired();\n    error YieldContractInsufficientSy(uint256 actualSy, uint256 requiredSy);\n    error YCNothingToRedeem();\n    error YCPostExpiryDataNotSet();\n    error YCNoFloatingSy();\n\n    // YieldFactory\n    error YCFactoryInvalidExpiry();\n    error YCFactoryYieldContractExisted();\n    error YCFactoryZeroExpiryDivisor();\n    error YCFactoryZeroTreasury();\n    error YCFactoryInterestFeeRateTooHigh(uint256 interestFeeRate, uint256 maxInterestFeeRate);\n    error YCFactoryRewardFeeRateTooHigh(uint256 newRewardFeeRate, uint256 maxRewardFeeRate);\n\n    // SY\n    error SYInvalidTokenIn(address token);\n    error SYInvalidTokenOut(address token);\n    error SYZeroDeposit();\n    error SYZeroRedeem();\n    error SYInsufficientSharesOut(uint256 actualSharesOut, uint256 requiredSharesOut);\n    error SYInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n\n    // SY-specific\n    error SYQiTokenMintFailed(uint256 errCode);\n    error SYQiTokenRedeemFailed(uint256 errCode);\n    error SYQiTokenRedeemRewardsFailed(uint256 rewardAccruedType0, uint256 rewardAccruedType1);\n    error SYQiTokenBorrowRateTooHigh(uint256 borrowRate, uint256 borrowRateMax);\n\n    error SYCurveInvalidPid();\n    error SYCurve3crvPoolNotFound();\n\n    error SYApeDepositAmountTooSmall(uint256 amountDeposited);\n    error SYBalancerInvalidPid();\n    error SYInvalidRewardToken(address token);\n\n    error SYStargateRedeemCapExceeded(uint256 amountLpDesired, uint256 amountLpRedeemable);\n\n    error SYBalancerReentrancy();\n\n    error NotFromTrustedRemote(uint16 srcChainId, bytes path);\n\n    // Liquidity Mining\n    error VCInactivePool(address pool);\n    error VCPoolAlreadyActive(address pool);\n    error VCZeroVePendle(address user);\n    error VCExceededMaxWeight(uint256 totalWeight, uint256 maxWeight);\n    error VCEpochNotFinalized(uint256 wTime);\n    error VCPoolAlreadyAddAndRemoved(address pool);\n\n    error VEInvalidNewExpiry(uint256 newExpiry);\n    error VEExceededMaxLockTime();\n    error VEInsufficientLockTime();\n    error VENotAllowedReduceExpiry();\n    error VEZeroAmountLocked();\n    error VEPositionNotExpired();\n    error VEZeroPosition();\n    error VEZeroSlope(uint128 bias, uint128 slope);\n    error VEReceiveOldSupply(uint256 msgTime);\n\n    error GCNotPendleMarket(address caller);\n    error GCNotVotingController(address caller);\n\n    error InvalidWTime(uint256 wTime);\n    error ExpiryInThePast(uint256 expiry);\n    error ChainNotSupported(uint256 chainId);\n\n    error FDTotalAmountFundedNotMatch(uint256 actualTotalAmount, uint256 expectedTotalAmount);\n    error FDEpochLengthMismatch();\n    error FDInvalidPool(address pool);\n    error FDPoolAlreadyExists(address pool);\n    error FDInvalidNewFinishedEpoch(uint256 oldFinishedEpoch, uint256 newFinishedEpoch);\n    error FDInvalidStartEpoch(uint256 startEpoch);\n    error FDInvalidWTimeFund(uint256 lastFunded, uint256 wTime);\n    error FDFutureFunding(uint256 lastFunded, uint256 currentWTime);\n\n    error BDInvalidEpoch(uint256 epoch, uint256 startTime);\n\n    // Cross-Chain\n    error MsgNotFromSendEndpoint(uint16 srcChainId, bytes path);\n    error MsgNotFromReceiveEndpoint(address sender);\n    error InsufficientFeeToSendMsg(uint256 currentFee, uint256 requiredFee);\n    error ApproxDstExecutionGasNotSet();\n    error InvalidRetryData();\n\n    // GENERIC MSG\n    error ArrayLengthMismatch();\n    error ArrayEmpty();\n    error ArrayOutOfBounds();\n    error ZeroAddress();\n    error FailedToSendEther();\n    error InvalidMerkleProof();\n\n    error OnlyLayerZeroEndpoint();\n    error OnlyYT();\n    error OnlyYCFactory();\n    error OnlyWhitelisted();\n\n    // Swap Aggregator\n    error SAInsufficientTokenIn(address tokenIn, uint256 amountExpected, uint256 amountActual);\n    error UnsupportedSelector(uint256 aggregatorType, bytes4 selector);\n}\n"
    },
    "@pendle/core-v2/contracts/core/libraries/math/LogExpMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the Software), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity ^0.8.0;\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 27\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 26\n    int256 constant a1 = 6235149080811616882910000000; // e(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 25\n    int256 constant a2 = 7896296018268069516100000000000000; // e(x2)\n    int256 constant x3 = 1600000000000000000000; // 24\n    int256 constant a3 = 888611052050787263676000000; // e(x3)\n    int256 constant x4 = 800000000000000000000; // 23\n    int256 constant a4 = 298095798704172827474000; // e(x4)\n    int256 constant x5 = 400000000000000000000; // 22\n    int256 constant a5 = 5459815003314423907810; // e(x5)\n    int256 constant x6 = 200000000000000000000; // 21\n    int256 constant a6 = 738905609893065022723; // e(x6)\n    int256 constant x7 = 100000000000000000000; // 20\n    int256 constant a7 = 271828182845904523536; // e(x7)\n    int256 constant x8 = 50000000000000000000; // 2-1\n    int256 constant a8 = 164872127070012814685; // e(x8)\n    int256 constant x9 = 25000000000000000000; // 2-2\n    int256 constant a9 = 128402541668774148407; // e(x9)\n    int256 constant x10 = 12500000000000000000; // 2-3\n    int256 constant a10 = 113314845306682631683; // e(x10)\n    int256 constant x11 = 6250000000000000000; // 2-4\n    int256 constant a11 = 106449445891785942956; // e(x11)\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \"Invalid exponent\");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, \"out of bounds\");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, \"x out of bounds\");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, \"y out of bounds\");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) *\n                    y_int256 +\n                    ((ln_36_x % ONE_18) * y_int256) /\n                    ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                \"product out of bounds\"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/core/libraries/math/PMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/* solhint-disable private-vars-leading-underscore, reason-string */\n\nlibrary PMath {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, \"negative\");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function isAApproxB(\n        uint256 a,\n        uint256 b,\n        uint256 eps\n    ) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(\n        uint256 a,\n        uint256 b,\n        uint256 eps\n    ) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(\n        uint256 a,\n        uint256 b,\n        uint256 eps\n    ) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/core/libraries/MiniHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nlibrary MiniHelpers {\n    function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\n        return (expiry <= block.timestamp);\n    }\n\n    function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\n        return (expiry <= blockTime);\n    }\n\n    function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/core/Market/MarketMathCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../libraries/math/PMath.sol\";\nimport \"../libraries/math/LogExpMath.sol\";\n\nimport \"../StandardizedYield/PYIndex.sol\";\nimport \"../libraries/MiniHelpers.sol\";\nimport \"../libraries/Errors.sol\";\n\nstruct MarketState {\n    int256 totalPt;\n    int256 totalSy;\n    int256 totalLp;\n    address treasury;\n    /// immutable variables ///\n    int256 scalarRoot;\n    uint256 expiry;\n    /// fee data ///\n    uint256 lnFeeRateRoot;\n    uint256 reserveFeePercent; // base 100\n    /// last trade data ///\n    uint256 lastLnImpliedRate;\n}\n\n// params that are expensive to compute, therefore we pre-compute them\nstruct MarketPreCompute {\n    int256 rateScalar;\n    int256 totalAsset;\n    int256 rateAnchor;\n    int256 feeRate;\n}\n\n// solhint-disable ordering\nlibrary MarketMathCore {\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    )\n        internal\n        pure\n        returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed)\n    {\n        (\n            int256 _lpToReserve,\n            int256 _lpToAccount,\n            int256 _syUsed,\n            int256 _ptUsed\n        ) = addLiquidityCore(market, syDesired.Int(), ptDesired.Int(), blockTime);\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    )\n        internal\n        pure\n        returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed)\n    {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(\n            market,\n            comp,\n            index,\n            netPtToAccount\n        );\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(\n            market,\n            comp,\n            index,\n            netPtToAccount,\n            netSyToAccount,\n            netSyToReserve,\n            blockTime\n        );\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE)\n                revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(\n        MarketState memory market,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/core/StandardizedYield/PYIndex.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"../../interfaces/IPYieldToken.sol\";\nimport \"../../interfaces/IPPrincipalToken.sol\";\n\nimport \"./SYUtils.sol\";\nimport \"../libraries/math/PMath.sol\";\n\ntype PYIndex is uint256;\n\nlibrary PYIndexLib {\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/core/StandardizedYield/SYUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nlibrary SYUtils {\n    uint256 internal constant ONE = 1e18;\n\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate) / ONE;\n    }\n\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\n    }\n\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE) / exchangeRate;\n    }\n\n    function assetToSyUp(\n        uint256 exchangeRate,\n        uint256 assetAmount\n    ) internal pure returns (uint256) {\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/interfaces/IPGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface IPGauge {\n    function totalActiveSupply() external view returns (uint256);\n\n    function activeBalance(address user) external view returns (uint256);\n\n    // only available for newer factories. please check the verified contracts\n    event RedeemRewards(address indexed user, uint256[] rewardsOut);\n}\n"
    },
    "@pendle/core-v2/contracts/interfaces/IPInterestManagerYT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface IPInterestManagerYT {\n    function userInterest(\n        address user\n    ) external view returns (uint128 lastPYIndex, uint128 accruedInterest);\n}\n"
    },
    "@pendle/core-v2/contracts/interfaces/IPMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./IPPrincipalToken.sol\";\nimport \"./IPYieldToken.sol\";\nimport \"./IStandardizedYield.sol\";\nimport \"./IPGauge.sol\";\nimport \"../core/Market/MarketMathCore.sol\";\n\ninterface IPMarket is IERC20Metadata, IPGauge {\n    event Mint(\n        address indexed receiver,\n        uint256 netLpMinted,\n        uint256 netSyUsed,\n        uint256 netPtUsed\n    );\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(\n        uint32[] memory secondsAgos\n    ) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens()\n        external\n        view\n        returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    )\n        external\n        view\n        returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}\n"
    },
    "@pendle/core-v2/contracts/interfaces/IPPrincipalToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IPPrincipalToken is IERC20Metadata {\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}\n"
    },
    "@pendle/core-v2/contracts/interfaces/IPYieldToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./IRewardManager.sol\";\nimport \"./IPInterestManagerYT.sol\";\n\ninterface IPYieldToken is IERC20Metadata, IRewardManager, IPInterestManagerYT {\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(\n        address indexed caller,\n        address indexed receiver,\n        uint256 amountPYToRedeem,\n        uint256 amountSyOut\n    );\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event WithdrawFeeToTreasury(uint256[] amountRewardsOut, uint256 syOut);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n\n}\n"
    },
    "@pendle/core-v2/contracts/interfaces/IRewardManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface IRewardManager {\n    function userReward(\n        address token,\n        address user\n    ) external view returns (uint128 index, uint128 accrued);\n}\n"
    },
    "@pendle/core-v2/contracts/interfaces/IStandardizedYield.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IStandardizedYield is IERC20Metadata {\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(address tokenIn, uint256 amountTokenToDeposit)\n        external\n        view\n        returns (uint256 amountSharesOut);\n\n    function previewRedeem(address tokenOut, uint256 amountSharesToRedeem)\n        external\n        view\n        returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo()\n        external\n        view\n        returns (\n            AssetType assetType,\n            address assetAddress,\n            uint8 assetDecimals\n        );\n}\n"
    },
    "@pendle/core-v2/contracts/offchain-helpers/BoringLpSeller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"../interfaces/IPMarket.sol\";\n\nabstract contract BoringLpSeller {\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    constructor() {}\n\n    /// @dev slippage control should be done on a higher level with the returned parameter\n    /// @param market market address\n    /// @param netLpIn amount of Lp to sell\n    /// @param tokenOut should be included in SY.getTokensOut()\n    /// @return netTokenOut amount of token out\n    function _sellLpForToken(\n        address market,\n        uint256 netLpIn,\n        address tokenOut\n    ) internal returns (uint256 netTokenOut) {\n        (IStandardizedYield SY, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market)\n            .readTokens();\n\n        IPMarket(market).transfer(market, netLpIn);\n\n        uint256 netSyToRedeem;\n\n        if (PT.isExpired()) {\n            (uint256 netSyRemoved, ) = IPMarket(market).burn(address(SY), address(YT), netLpIn);\n            uint256 netSyFromPt = YT.redeemPY(address(SY));\n            netSyToRedeem = netSyRemoved + netSyFromPt;\n        } else {\n            (uint256 netSyRemoved, uint256 netPtRemoved) = IPMarket(market).burn(\n                address(SY),\n                market,\n                netLpIn\n            );\n            (uint256 netSySwappedOut, ) = IPMarket(market).swapExactPtForSy(\n                address(SY),\n                netPtRemoved,\n                EMPTY_BYTES\n            );\n            netSyToRedeem = netSyRemoved + netSySwappedOut;\n        }\n\n        netTokenOut = SY.redeem(address(this), netSyToRedeem, tokenOut, 0, true);\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/oracles/PendleLpOracleLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./PendlePtOracleLib.sol\";\n\nlibrary PendleLpOracleLib {\n    using PendlePtOracleLib for IPMarket;\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n\n    /**\n      * This function returns the approximated twap rate LP/asset on market, but take into account the current rate of SY\n     This is to account for special cases where underlying asset becomes insolvent and has decreasing exchangeRate\n     * @param market market to get rate from\n     * @param duration twap duration\n     */\n    function getLpToAssetRate(IPMarket market, uint32 duration) internal view returns (uint256) {\n        (uint256 syIndex, uint256 pyIndex) = PendlePtOracleLib.getSYandPYIndexCurrent(market);\n        uint256 lpToAssetRateRaw = _getLpToAssetRateRaw(market, duration, pyIndex);\n        return (lpToAssetRateRaw * syIndex) / pyIndex;\n    }\n\n    function _getLpToAssetRateRaw(\n        IPMarket market,\n        uint32 duration,\n        uint256 pyIndex\n    ) private view returns (uint256 lpToAssetRateRaw) {\n        MarketState memory state = market.readState(address(0));\n\n        MarketPreCompute memory comp = state.getMarketPreCompute(\n            PYIndex.wrap(pyIndex),\n            block.timestamp\n        );\n\n        int256 totalHypotheticalAsset;\n        if (state.expiry <= block.timestamp) {\n            // 1 PT = 1 Asset post-expiry\n            totalHypotheticalAsset = state.totalPt + comp.totalAsset;\n        } else {\n            (int256 rateOracle, int256 rateHypTrade) = _getPtRatesRaw(market, state, duration);\n            int256 cParam = LogExpMath.exp(\n                comp.rateScalar.mulDown((rateOracle - comp.rateAnchor))\n            );\n\n            int256 tradeSize = (cParam.mulDown(comp.totalAsset) - state.totalPt).divDown(\n                PMath.IONE + cParam.divDown(rateHypTrade)\n            );\n\n            totalHypotheticalAsset =\n                comp.totalAsset -\n                tradeSize.divDown(rateHypTrade) +\n                (state.totalPt + tradeSize).divDown(rateOracle);\n        }\n\n        lpToAssetRateRaw = totalHypotheticalAsset.divDown(state.totalLp).Uint();\n    }\n\n    function _getPtRatesRaw(\n        IPMarket market,\n        MarketState memory state,\n        uint32 duration\n    ) private view returns (int256 rateOracle, int256 rateHypTrade) {\n        rateOracle = PMath.IONE.divDown(market.getPtToAssetRateRaw(duration).Int());\n        int256 rateLastTrade = MarketMathCore._getExchangeRateFromImpliedRate(\n            state.lastLnImpliedRate,\n            state.expiry - block.timestamp\n        );\n        rateHypTrade = (rateLastTrade + rateOracle) / 2;\n    }\n}\n"
    },
    "@pendle/core-v2/contracts/oracles/PendlePtOracleLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IPMarket.sol\";\nimport \"../core/libraries/math/PMath.sol\";\n\nlibrary PendlePtOracleLib {\n    using PMath for uint256;\n    using PMath for int256;\n\n    /**\n     * This function returns the twap rate PT/Asset on market, but take into account the current rate of SY\n     This is to account for special cases where underlying asset becomes insolvent and has decreasing exchangeRate\n     * @param market market to get rate from\n     * @param duration twap duration\n     */\n    function getPtToAssetRate(IPMarket market, uint32 duration) internal view returns (uint256) {\n        (uint256 syIndex, uint256 pyIndex) = getSYandPYIndexCurrent(market);\n        return (getPtToAssetRateRaw(market,duration) * syIndex) / pyIndex;\n    }\n\n    function getPtToAssetRateRaw(IPMarket market, uint32 duration) internal view returns (uint256) {\n        uint256 expiry = market.expiry();\n\n        if (expiry <= block.timestamp) {\n            return PMath.ONE;\n        } else {\n            uint256 lnImpliedRate = _getMarketLnImpliedRate(market, duration);\n            uint256 timeToExpiry = expiry - block.timestamp;\n            uint256 assetToPtRate =\n                MarketMathCore._getExchangeRateFromImpliedRate(lnImpliedRate, timeToExpiry).Uint();\n            return PMath.ONE.divDown(assetToPtRate);\n        }\n    }\n\n    function getSYandPYIndexCurrent(IPMarket market)\n        internal\n        view\n        returns (uint256 syIndex, uint256 pyIndex)\n    {\n        (IStandardizedYield SY, , IPYieldToken YT) = market.readTokens();\n\n        syIndex = SY.exchangeRate();\n        uint256 pyIndexStored = YT.pyIndexStored();\n\n        if (YT.doCacheIndexSameBlock() && YT.pyIndexLastUpdatedBlock() == block.number) {\n            pyIndex = pyIndexStored;\n        } else {\n            pyIndex = PMath.max(syIndex, pyIndexStored);\n        }\n    }\n\n    function _getMarketLnImpliedRate(IPMarket market, uint32 duration)\n        private\n        view\n        returns (uint256)\n    {\n        uint32[] memory durations = new uint32[](2);\n        durations[0] = duration;\n\n        uint216[] memory lnImpliedRateCumulative = market.observe(durations);\n        return (lnImpliedRateCumulative[1] - lnImpliedRateCumulative[0]) / duration;\n    }\n}\n"
    },
    "@prb/math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "@prb/math/contracts/PRBMathSD59x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathSD59x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\nlibrary PRBMathSD59x18 {\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\n    int256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev Half the SCALE number.\n    int256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\n\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_WHOLE_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\n\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\n\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_WHOLE_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    int256 internal constant SCALE = 1e18;\n\n    /// INTERNAL FUNCTIONS ///\n\n    /// @notice Calculate the absolute value of x.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than MIN_SD59x18.\n    ///\n    /// @param x The number to calculate the absolute value for.\n    /// @param result The absolute value of x.\n    function abs(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x == MIN_SD59x18) {\n                revert PRBMathSD59x18__AbsInputTooSmall();\n            }\n            result = x < 0 ? -x : x;\n        }\n    }\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\n        // The operations can never overflow.\n        unchecked {\n            int256 sum = (x >> 1) + (y >> 1);\n            if (sum < 0) {\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\n                // right rounds down to infinity.\n                assembly {\n                    result := add(sum, and(or(x, y), 1))\n                }\n            } else {\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\n                // remainder gets truncated twice.\n                result = sum + (x & y & 1);\n            }\n        }\n    }\n\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function ceil(int256 x) internal pure returns (int256 result) {\n        if (x > MAX_WHOLE_SD59x18) {\n            revert PRBMathSD59x18__CeilOverflow(x);\n        }\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x > 0) {\n                    result += SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDiv\".\n    /// - None of the inputs can be MIN_SD59x18.\n    /// - The denominator cannot be zero.\n    /// - The result must fit within int256.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDiv\".\n    ///\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\n            revert PRBMathSD59x18__DivInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x and y.\n        uint256 ax;\n        uint256 ay;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n        }\n\n        // Compute the absolute value of (x*SCALE)y. The result must fit within int256.\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\n        if (rAbs > uint256(MAX_SD59x18)) {\n            revert PRBMathSD59x18__DivOverflow(rAbs);\n        }\n\n        // Get the signs of x and y.\n        uint256 sx;\n        uint256 sy;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n        }\n\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\n        // should be positive. Otherwise, it should be negative.\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (int256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\".\n    /// - For any x less than -41.446531673892822322, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp(int256 x) internal pure returns (int256 result) {\n        // Without this check, the value passed to \"exp2\" would be less than -59.794705707972522261.\n        if (x < -41_446531673892822322) {\n            return 0;\n        }\n\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathSD59x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            int256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - For any x less than -59.794705707972522261, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp2(int256 x) internal pure returns (int256 result) {\n        // This works because 2^(-x) = 1/2^x.\n        if (x < 0) {\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\n            if (x < -59_794705707972522261) {\n                return 0;\n            }\n\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n            unchecked {\n                result = 1e36 / exp2(-x);\n            }\n        } else {\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n            if (x >= 192e18) {\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\n            }\n\n            unchecked {\n                // Convert x to the 192.64-bit fixed-point format.\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\n\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\n                result = int256(PRBMath.exp2(x192x64));\n            }\n        }\n    }\n\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function floor(int256 x) internal pure returns (int256 result) {\n        if (x < MIN_WHOLE_SD59x18) {\n            revert PRBMathSD59x18__FloorUnderflow(x);\n        }\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x < 0) {\n                    result -= SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\n    /// of the radix point for negative numbers.\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\n    function frac(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x % SCALE;\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\n    function fromInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x < MIN_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__FromIntUnderflow(x);\n            }\n            if (x > MAX_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__FromIntOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\n    /// - x * y cannot be negative.\n    ///\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            int256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathSD59x18__GmOverflow(x, y);\n            }\n\n            // The product cannot be negative.\n            if (xy < 0) {\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = int256(PRBMath.sqrt(uint256(xy)));\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\n    function inv(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\n    function ln(int256 x) internal pure returns (int256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 195205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\n    function log10(int256 x) internal pure returns (int256 result) {\n        if (x <= 0) {\n            revert PRBMathSD59x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly mul operation, not the \"mul\" function defined in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            default {\n                result := MAX_SD59x18\n            }\n        }\n\n        if (result == MAX_SD59x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than zero.\n    ///\n    /// Caveats:\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\n    function log2(int256 x) internal pure returns (int256 result) {\n        if (x <= 0) {\n            revert PRBMathSD59x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n                assembly {\n                    x := div(1000000000000000000000000000000000000, x)\n                }\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\n\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\n            result = int256(n) * SCALE;\n\n            // This is y = x * 2^(-n).\n            int256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result * sign;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n            result *= sign;\n        }\n    }\n\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\n    /// fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is\n    /// always 1e18.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - None of the inputs can be MIN_SD59x18\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    ///\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\n            revert PRBMathSD59x18__MulInputTooSmall();\n        }\n\n        unchecked {\n            uint256 ax;\n            uint256 ay;\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\n            if (rAbs > uint256(MAX_SD59x18)) {\n                revert PRBMathSD59x18__MulOverflow(rAbs);\n            }\n\n            uint256 sx;\n            uint256 sy;\n            assembly {\n                sx := sgt(x, sub(0, 1))\n                sy := sgt(y, sub(0, 1))\n            }\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\n        }\n    }\n\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\n    function pi() internal pure returns (int256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - z cannot be zero.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : int256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - All from \"abs\" and \"PRBMath.mulDivFixedPoint\".\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\n        uint256 xAbs = uint256(abs(x));\n\n        // Calculate the first iteration of the loop in advance.\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        uint256 yAux = y;\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (yAux & 1 > 0) {\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\n            }\n        }\n\n        // The result must fit within the 59.18-decimal fixed-point representation.\n        if (rAbs > uint256(MAX_SD59x18)) {\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\n        }\n\n        // Is the base negative and the exponent an odd number?\n        bool isNegative = x < 0 && y & 1 == 1;\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\n    function scale() internal pure returns (int256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x cannot be negative.\n    /// - x must be less than MAX_SD59x18 / SCALE.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as a signed 59.18-decimal fixed-point .\n    function sqrt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x < 0) {\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\n            }\n            if (x > MAX_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\n        }\n    }\n\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/emergency/CircuitBreakerUnoptimized.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/ICircuitBreaker.sol\";\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\n\n/**\n * @title CircuitBreakerUnoptimized\n * @dev This is gas-unoptimized version for testing.\n * See the associated interface for full details.\n */\ncontract CircuitBreakerUnoptimized is ICircuitBreaker, SuAuthenticated {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant WITHDRAWAL_PERIOD = 24 hours;\n    /**\n     * @dev Here we use sliding window algorithm (https://www.geeksforgeeks.org/window-sliding-technique/)\n     * to count sum of funds passed during 1 day\n     */\n    uint256 public constant SLIDING_WINDOW_PARTS = 4;\n    uint256 public constant SLIDING_WINDOW_SIZE = WITHDRAWAL_PERIOD / SLIDING_WINDOW_PARTS;\n    uint256 public constant TRIGGER_RATE_LIMIT_LENGTH = 356 days;\n\n    uint256 public fundsFlowThreshold;\n    mapping(uint256 => uint256) public liqInPeriod;\n    State public state;\n    uint256 public triggeredRateLimitEndTimestamp;\n\n    /* ==================== MUTABLE METHODS ==================== */\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n    }\n\n    // TODO: add onlyRole for our lending protocol\n    function controlledTransfer(address token, address to, uint256 amount, uint256 value) external {\n        if (state == State.Triggered) {\n            if (block.timestamp < triggeredRateLimitEndTimestamp) {\n                revert Triggered();\n            } else {\n                state = State.Ok;\n                emit TriggeredRateLimitExpired();\n            }\n        }\n        addFundsFlow(value);\n        uint256 totalFundsFlow = totalLiquidityInPeriod();\n        if (totalFundsFlow > fundsFlowThreshold) {\n            revert ThresholdExceeded();\n        } else\n            if (totalFundsFlow > fundsFlowThreshold/2) {\n                if (state != State.Warning) {\n                    state = State.Warning;\n                    emit ThresholdWarning();\n                }\n            }\n        IERC20(token).safeTransferFrom(msg.sender, to, amount);\n    }\n\n    function addFundsFlow(uint256 value) internal {\n        uint256 windowId = getWindowId();\n        liqInPeriod[windowId] += value;\n    }\n\n    function setFundsFlowThreshold(uint256 _fundsFlowThreshold) external onlyDAO {\n        fundsFlowThreshold = _fundsFlowThreshold;\n    }\n\n    function reset() external onlyAdmin {\n        state = State.Ok;\n        // flush funds flow\n        uint256 windowId = getWindowId();\n        for (uint256 i = 0; i < SLIDING_WINDOW_PARTS; i++) {\n            liqInPeriod[windowId-i] = 0;\n        }\n\n        emit ResetByAdmin();\n    }\n\n    function triggerRateLimit() external onlyAlerter {\n        state = State.Triggered;\n        triggeredRateLimitEndTimestamp = block.timestamp + TRIGGER_RATE_LIMIT_LENGTH;\n\n        emit RateLimitTriggered();\n    }\n\n    /* ==================== VIEW METHODS ==================== */\n    function totalLiquidityInPeriod() public view returns (uint256) {\n        uint256 windowId = getWindowId();\n        uint256 totalFlow;\n        for (uint256 i = 0; i < SLIDING_WINDOW_PARTS; i++) {\n            totalFlow += liqInPeriod[windowId-i];\n        }\n        return totalFlow;\n    }\n\n    function getWindowId() public view returns (uint256) {\n        return block.timestamp / SLIDING_WINDOW_SIZE;\n    }\n}\n"
    },
    "contracts/emergency/SuPausable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\nimport \"../interfaces/ISuPausable.sol\";\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\n\n/**\n * @dev Contract module which allows to implement an emergency stop mechanism that can be triggered only by an owner.\n * See the associated interface for full details.\n */\ncontract SuPausable is SuAuthenticated, ContextUpgradeable, ISuPausable {\n    mapping(address => bool) private _isCollateralPaused;\n    mapping(address => bool) private _isContractPaused;\n    bool private _isAllPaused;\n\n    /**\n     * @dev _isCollateralPaused and _isContractPaused are empty that means\n     * that all collaterals and contracts are not paused.\n     */\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n        _isAllPaused = false;\n    }\n\n    function pauseCollateral(address collateral) public onlyAlerter {\n        if (_isCollateralPaused[collateral]) revert AlreadyPaused();\n        _isCollateralPaused[collateral] = true;\n        emit PausedCollateral(_msgSender(), collateral);\n    }\n\n    function batchPauseCollateral(address[] calldata collaterals) public onlyAlerter {\n        for (uint16 i = 0; i < collaterals.length; ++i) {\n            pauseCollateral(collaterals[i]);\n        }\n    }\n\n    function pauseContract(address _contract) public onlyAlerter {\n        if (_isContractPaused[_contract]) revert AlreadyPaused();\n        _isContractPaused[_contract] = true;\n        emit PausedContract(_msgSender(), _contract);\n    }\n\n    function pauseAll() public onlyAlerter {\n        _isAllPaused = true;\n    }\n\n    function unpauseCollateral(address collateral) public onlyAlerter {\n        if (!_isCollateralPaused[collateral]) revert NotPaused();\n        _isCollateralPaused[collateral] = false;\n        emit UnpausedCollateral(_msgSender(), collateral);\n    }\n\n    function batchUnpauseCollateral(address[] calldata collaterals) public onlyAlerter {\n        for (uint16 i = 0; i < collaterals.length; ++i) {\n            unpauseCollateral(collaterals[i]);\n        }\n    }\n\n    function unpauseContract(address _contract) public onlyAlerter {\n        if (!_isContractPaused[_contract]) revert NotPaused();\n        _isContractPaused[_contract] = false;\n        emit UnpausedContract(_msgSender(), _contract);\n    }\n\n    function unpauseAll() public onlyAlerter {\n        _isAllPaused = false;\n    }\n\n    function isPaused(address collateral) public view virtual returns (bool) {\n        return _isCollateralPaused[collateral] || _isContractPaused[msg.sender] || _isAllPaused;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/emergency/SuPausableAbstract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISuPausable.sol\";\n\n/**\n * @dev Abstract contract which allows other contracts to use modifiers\n */\nabstract contract SuPausableAbstract {\n    error AlreadyPaused();\n    error NotPaused();\n\n    ISuPausable internal suPausable;\n\n    function __suPausableAbstractInit(address _suPausable) internal {\n        suPausable = ISuPausable(_suPausable);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused(address collateral) {\n        if (suPausable.isPaused(collateral)) revert AlreadyPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused(address collateral) {\n        if (!suPausable.isPaused(collateral)) revert NotPaused();\n        _;\n    }\n}\n"
    },
    "contracts/exchange/contracts/ArbitrageHelper.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IArbitrageHelper.sol\";\nimport \"../interfaces/IExchange.sol\";\nimport \"./CalldataDecoder.sol\";\nimport \"../../periphery/contracts/access-control/SuAuthenticated.sol\";\nimport \"../../periphery/contracts/interfaces/adapters/ILPAdapter.sol\";\n\n/**\n * @title ArbitrageHelper\n * @notice Helper contract to arbitrage using Exchange module\n * @dev See IArbitrageHelper interface for full details.\n */\ncontract ArbitrageHelper is SuAuthenticated, IArbitrageHelper, CalldataDecoder {\n    IExchange internal EXCHANGE;\n    mapping(address => ILPAdapter) public lpToAdapter;\n\n    function initialize(address _authControl, address _exchange) public initializer {\n        __suAuthenticatedInit(_authControl);\n\n        EXCHANGE = IExchange(_exchange);\n    }\n\n    function registerLP(address _lp, address _lpAdapter) public onlyAdmin {\n        lpToAdapter[_lp] = ILPAdapter(_lpAdapter);\n\n        TransferHelper.safeApprove(_lp, _lpAdapter, 2**256 - 1);\n    }\n\n    /**\n     * @notice Swap using Paraswap. Sell {amount2sell} token2sell to token using route encoded in paraswapData.data\n     * @dev We get that data in bot using ParaSwap API (apiv5.paraswap.io)\n     * Docs: https://developers.paraswap.network/api/build-parameters-for-transaction\n     */\n    function swapByParaswap(address token2sell, uint256 amount2sell, ParaswapData memory paraswapData) internal {\n        // All token transfers are through tokenTransferProxy, so we need to make approve to this contract\n        TransferHelper.safeApprove(token2sell, paraswapData.tokenTransferProxy, amount2sell);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success,) = paraswapData.contractAddress.call(paraswapData.data);\n        if (!success) {\n            revert SwapByParaSwapError();\n        }\n    }\n    /**\n     * @notice as in swapByParaswap, look into utils/1inch.ts\n     * @dev Docs: https://docs.1inch.io/docs/aggregation-protocol/api/swap-params/\n     */\n    function swapBy1Inch(address token2sell, uint256 amount2sell, address contractAddress, bytes memory data) internal {\n        TransferHelper.safeApprove(token2sell, contractAddress, amount2sell);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success,) = contractAddress.call(data);\n        if (!success) {\n            revert SwapBy1InchError();\n        }\n    }\n\n    function swapWithFlashLoan(\n        uint256 orderId,\n        address token2sell,\n        uint256 token2sellAmount,\n        InchData memory inchData\n    ) public {\n        InchData[] memory inchDataArr = new InchData[](1);\n        inchDataArr[0] = inchData;\n        // We do a flash-loan of {token2sell} in amount of {token2sellAmount} to our contract.\n        // {data} will be decoded in stableunitFillOrderCallback() - the callback after we get flash-loan\n        EXCHANGE.fillOrderAsFlashLoan(\n            orderId,\n            token2sellAmount,\n            abi.encode(FlashCallbackData({\n                isLP: false,\n                orderId: orderId,\n                token2sell: token2sell,\n                token2sellAmount: token2sellAmount,\n                recipient: msg.sender,\n                inchData: inchDataArr\n            }))\n        );\n    }\n\n    function swapLPWithFlashLoan(\n        uint256 orderId,\n        address token2sell,\n        uint256 token2sellAmount,\n        InchData[] memory inchData\n    ) public {\n        EXCHANGE.fillOrderAsFlashLoan(\n            orderId,\n            token2sellAmount,\n            abi.encode(FlashCallbackData({\n                isLP: true,\n                orderId: orderId,\n                token2sell: token2sell,\n                token2sellAmount: token2sellAmount,\n                recipient: msg.sender,\n                inchData: inchData\n            }))\n        );\n    }\n\n    /**\n     * @notice This is callback function from Exchange contract.\n     * fillOrderAsFlashLoan call (msg.sender).executeOperation(...) after transferring loan to sender\n     * @dev behaviour like in uniswapV3FlashCallback:\n     * https://docs.uniswap.org/contracts/v3/guides/flash-integrations/flash-callback\n     * and AAVE flash-loan callback:\n     * https://github.com/aave/aave-v3-core/blob/master/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol\n    **/\n    function stableunitFillOrderCallback(\n        address asset,\n        uint256 amount,\n        address sender,\n        bytes calldata data\n    ) external returns (bool) {\n        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));\n\n        if (msg.sender != address(EXCHANGE)) revert NotAPool(msg.sender);\n        if (sender != address(this)) revert BadSender(sender);\n\n        uint256 balanceBefore = IERC20(asset).balanceOf(address(this));\n\n        if (decoded.isLP) {\n            if (address(lpToAdapter[decoded.token2sell]) == address(0)) revert LPTokenNotRegistered(decoded.token2sell);\n            if (\n                !lpToAdapter[decoded.token2sell].isAdapterLP(decoded.token2sell)\n            ) revert LPTokenNotSupported(decoded.token2sell);\n\n            WithdrawResult[] memory unwrapResult = lpToAdapter[decoded.token2sell].withdraw(\n                decoded.token2sell,\n                decoded.token2sellAmount\n            );\n            uint256 inchDataNTokens = decoded.inchData.length;\n            uint256 unwrapNTokens = unwrapResult.length;\n\n            // if withdraw don't unwrap to all underlying tokens, then we need to find 1inch data to use in swap\n            // else we need to use all 1inch data for each unwrapped tokens\n            bool isCorrectUnwrap = inchDataNTokens == unwrapNTokens;\n            for (uint16 i = 0; i < unwrapNTokens; ++i) {\n                address underlineToken = unwrapResult[i].token;\n                uint256 underlineTokenAmount = unwrapResult[i].amount;\n\n                // If token2buy is underline token of LP-token token2sell => this part of order is done\n                if (underlineToken != asset) {\n                    if (isCorrectUnwrap) {\n                        swapBy1Inch(\n                            underlineToken,\n                            underlineTokenAmount,\n                            decoded.inchData[i].contractAddress,\n                            this.changeCalldataAmount(decoded.inchData[i].data, underlineTokenAmount)\n                        );\n                    } else { // we need to find correct 1inch data for that unwrapped token\n                        for (uint16 j = 0; j < inchDataNTokens; ++j) {\n                            if (unwrapResult[i].token == decoded.inchData[j].token) {\n                                swapBy1Inch(\n                                    underlineToken,\n                                    underlineTokenAmount,\n                                    decoded.inchData[j].contractAddress,\n                                    this.changeCalldataAmount(decoded.inchData[j].data, underlineTokenAmount)\n                                );\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            swapBy1Inch(\n                decoded.token2sell,\n                decoded.token2sellAmount,\n                decoded.inchData[0].contractAddress,\n                decoded.inchData[0].data\n            );\n        }\n\n        uint256 balanceAfter = IERC20(asset).balanceOf(address(this));\n        uint256 tokenBReceived = balanceAfter - balanceBefore;\n\n        if (tokenBReceived < amount) revert SwapNotProfitable();\n        uint256 swapProfit = tokenBReceived - amount;\n\n        // Return flash-loan debt to Exchange contract\n        TransferHelper.safeTransfer(asset, address(EXCHANGE), amount);\n\n        // Send swapped {asset} minus debt from flash-loan to liquidator (it's user profit)\n        TransferHelper.safeTransfer(asset, decoded.recipient, swapProfit);\n\n        return true;\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/exchange/contracts/CalldataDecoder.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nstruct SwapDescription {\n    address srcToken;\n    address dstToken;\n    address srcReceiver;\n    address dstReceiver;\n    uint256 amount;\n    uint256 minReturnAmount;\n    uint256 flags;\n}\n\n/**\n * @notice Helper abstract contract to work with calldata\n**/\nabstract contract CalldataDecoder {\n    /**\n     * @notice We need this functions to check their selector and functionSelector in calldata\n     * for changeCalldataAmount() function\n    **/\n    /* solhint-disable no-empty-blocks */\n    function uniswapV3Swap(uint256, uint256, uint256[] calldata) public pure {}\n    function unoswap(address, uint256, uint256, uint256[] calldata) public pure {}\n    function swap(address, SwapDescription calldata, bytes calldata, bytes calldata) public pure {}\n    function clipperSwap(\n        address clipperExchange,\n        address srcToken,\n        address dstToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 goodUntil,\n        bytes32 r,\n        bytes32 vs\n    ) public pure {}\n    /* solhint-enable no-empty-blocks */\n\n    // TODO: add comment about minAmount\n    // TODO: use byteToChange position in TS + check how much gas spent\n    /**\n      * @notice\n      * Helper function to change amount parameter on callback that depends on return by 1inch API calldata for swap\n      * We set minAmount to 1 to be sure, that swap will be created. Route path don't depend on that -\n      * this path was calculated previously in backend part and is stored in {data}.\n      * @param data - calldata to edit\n      * @param newAmount - new amount that should replace amount in {data}\n      * @return edited calldata with new amount inside\n     **/\n    function changeCalldataAmount(bytes calldata data, uint256 newAmount) public pure returns (bytes memory) {\n        bytes4 functionSelector = bytes4(data[:4]);\n        if (functionSelector == this.uniswapV3Swap.selector) {\n            (\n                /*uint256 _amount */, /*uint256 minReturn*/, uint256[] memory pools\n            ) = abi.decode(data[4:], (uint256, uint256, uint256[]));\n            return abi.encodeWithSignature(\"uniswapV3Swap(uint256,uint256,uint256[])\", newAmount, 1, pools);\n        }\n        if (functionSelector == this.unoswap.selector) {\n            (\n                address token, /* uint256 _amount */, /*uint256 minReturn*/, uint256[] memory pools\n            ) = abi.decode(data[4:], (address,uint256,uint256,uint256[]));\n            return abi.encodeWithSignature(\"unoswap(address,uint256,uint256,uint256[])\", token, newAmount, 1, pools);\n        }\n        if (functionSelector == this.swap.selector) {\n            (\n                address caller, SwapDescription memory description, bytes memory permit, bytes memory swapData\n            ) = abi.decode(data[4:], (address, SwapDescription, bytes, bytes));\n            return abi.encodeWithSignature(\n                \"swap(address,(address,address,address,address,uint256,uint256,uint256),bytes,bytes)\",\n                caller,\n                SwapDescription({\n                    srcToken: description.srcToken,\n                    dstToken: description.dstToken,\n                    srcReceiver: description.srcReceiver,\n                    dstReceiver: description.dstReceiver,\n                    amount: newAmount,\n                    minReturnAmount: 1,\n                    flags: description.flags\n                }),\n                permit,\n                swapData\n            );\n        }\n        if (functionSelector == this.clipperSwap.selector) {\n            (\n                address clipperExchange,\n                address srcToken,\n                address dstToken,\n                /*uint256 _inputAmount*/,\n                /*uint256 outputAmount*/,\n                uint256 goodUntil,\n                bytes32 r,\n                bytes32 vs\n            ) = abi.decode(data[4:], (address, address, address, uint256, uint256, uint256, bytes32, bytes32));\n            return abi.encodeWithSignature(\n                \"clipperSwap(address,address,address,uint256,uint256,uint256,bytes32,bytes32)\",\n                clipperExchange,\n                srcToken,\n                dstToken,\n                newAmount,\n                1,\n                goodUntil,\n                r,\n                vs\n            );\n        }\n\n        return data;\n    }\n}\n"
    },
    "contracts/exchange/contracts/Exchange.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IExchange.sol\";\nimport \"../interfaces/ITopStakers.sol\";\nimport \"../interfaces/IExchangeCallback.sol\";\nimport \"../../makerdao/interfaces/v8/ICollateralJoin.sol\";\nimport \"../../periphery/contracts/access-control/SuAuthenticated.sol\";\nimport \"../../periphery/contracts/interfaces/oracle/ISuOracle.sol\";\n\n/**\n * @title Exchange\n * @notice Main contract of Exchange module. Here we can add order or fill it to get profit.\n * @dev See IExchange interface for full details.\n */\ncontract Exchange is SuAuthenticated, IExchange {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    // todo: add enumerableSet of all IDs\n    mapping (uint256 => Order) public orders;\n    EnumerableSetUpgradeable.UintSet private orderIdSet;\n\n    /**\n     * @notice priceCurve is like price_t = price_0 * (1 - t/priceCurve[0]) - priceCurve[1]\n     * from timePassed = 0 to t priceCurve decrease linear, but after t (when discount is 20%), it's constant\n    **/\n    mapping (DiscountType => uint256[2]) public priceCurve;\n\n    /**\n     * @notice Amount of minimum amountLeft in order. It's measured in fiat.\n     * For example DUST_THRESHOLD = 100 * 1e18 => it's 100 USD\n    **/\n    uint256 public DUST_THRESHOLD;\n    ISuOracle public ORACLE;\n    ITopStakers public TOP_STAKERS;\n\n    function initialize(\n        address _authControl,\n        address _oracleAddress,\n        address _topStakersAddress\n    ) public initializer {\n        __suAuthenticatedInit(_authControl);\n\n        // -20% for 3min/10h/24h\n        priceCurve[DiscountType.aggressive] = [180 * 5, 0];\n        priceCurve[DiscountType.middle] = [36_000 * 5, 0];\n        priceCurve[DiscountType.conservative] = [86_400 * 5, 0];\n        DUST_THRESHOLD = 100 * 1e18;\n\n        ORACLE = ISuOracle(_oracleAddress);\n        TOP_STAKERS = ITopStakers(_topStakersAddress);\n    }\n\n    function setPriceCurve(DiscountType discountType, uint256[2] calldata newPriceCurve) public onlyDAO {\n        priceCurve[discountType] = newPriceCurve;\n    }\n\n    function addOrder(\n        address token2sell,\n        uint256 amount2sell,\n        address token2buy,\n        address beneficiary,\n        DiscountType discountType,\n        address collateralJoin // or store this map in exchange module\n    ) external returns (uint256 orderId) {\n        // TransferHelper.safeTransferFrom(token2sell, msg.sender, address(this), amount2sell);\n        ICollateralJoin(collateralJoin).exit(address(this), amount2sell);\n\n        orderId = uint256(\n            keccak256(\n                abi.encodePacked(block.number, msg.sender, token2sell, amount2sell, token2buy)\n            )\n        );\n        if (orders[orderId].creationTimestamp != 0) orderId += 1;\n        if (orders[orderId].creationTimestamp != 0) revert OrderExist(orderId);\n\n        orders[orderId] = Order(\n            token2sell,\n            amount2sell,\n            token2buy,\n            0, // token2buyAmount at start should be 0\n            beneficiary,\n            block.timestamp,\n            discountType,\n            msg.sender\n        );\n        EnumerableSetUpgradeable.add(orderIdSet, orderId);\n        emit OrderAdded(orderId);\n    }\n\n    function cancelOrder(uint256 orderId) public {\n        Order memory order = orders[orderId];\n\n        if (order.creationTimestamp == 0) revert OrderNotExist(orderId);\n        if (msg.sender != order.beneficiary && msg.sender != order.caller) revert UserIsNotBeneficiary();\n\n        TransferHelper.safeTransfer(order.token2sell, msg.sender, order.amountLeft);\n        delete orders[orderId];\n        EnumerableSetUpgradeable.remove(orderIdSet, orderId);\n\n        emit OrderCanceled(orderId);\n    }\n\n    /**\n     * @notice Return discounted price of token depending on passed time and type of discount\n     * @dev orderPrice = x * 10^18 * 10^(18 - decimals) like in Oracle\n    **/\n    function getDiscountedTokenPrice(\n        address token2sell,\n        uint256 timePassed,\n        DiscountType discountType\n    ) internal view returns (uint256) {\n        uint256 curveDiv = priceCurve[discountType][0];\n        uint256 curveSub = priceCurve[discountType][1];\n        uint256 price = ORACLE.getFiatPrice1e18(token2sell);\n\n        if (timePassed > curveDiv) {\n            // minimum is 80%;\n            return price * 8 / 10;\n        }\n\n        return price - price * timePassed / curveDiv - curveSub;\n    }\n\n    function getExpectedOrderOutcome(uint256 orderId, uint256 inAmount) public view returns (uint256 outAmount) {\n        Order memory order = orders[orderId];\n        uint256 timePassed = block.timestamp - order.creationTimestamp;\n\n        // Let's assume that: inAmount = x * 10^d1, discountedTokenPrice = p1 * 10^(36 - d1), priceB = p2 * 10^(36 - d2)\n        // Then outAmount = x * 10^d1 * p1 * 10^(36 - d1) / (p2 * 10^(36 - d2)) = (x * p1 / p2) * 10^(d2)\n        uint256 discountedTokenPrice = getDiscountedTokenPrice(order.token2sell, timePassed, order.discountType);\n        uint256 priceB = ORACLE.getFiatPrice1e18(order.token2buy);\n        outAmount = inAmount * discountedTokenPrice / priceB;\n    }\n\n    // TODO: add reentrancy lock\n    function fillOrderAsFlashLoan(\n        uint256 orderId,\n        uint256 inAmount,\n        bytes memory data\n    ) external returns (uint256 outAmount) {\n        Order storage order = orders[orderId];\n\n        if (order.creationTimestamp == 0) revert OrderNotExist(orderId);\n\n        uint256 timePassed = block.timestamp - order.creationTimestamp;\n\n        // grace period\n        // solhint-disable-next-line no-empty-blocks\n        if (timePassed <= 60) {\n            /**\n                // check that msg.sender is in TopStaker list + it's on position {orderId % x}\n                uint256 numberOfStakers = TOP_STAKERS.getTopStakersLength();\n                // TODO: update top stakers to be able to give \"stake power\" to another address\n                if (!TOP_STAKERS.isTopStaker(tx.origin)) revert IsNotTopStaker(tx.origin);\n                if (\n                    uint160(tx.origin) % numberOfStakers != orderId % numberOfStakers\n                ) revert OrderNotForThisStaker(orderId, tx.origin);\n            */\n            // solhint-disable-next-line no-empty-blocks\n        } else {\n            // check that msg.sender is in TopStaker list\n        }\n\n        if (inAmount > order.amountLeft) {\n            inAmount = order.amountLeft;\n        }\n\n        // the same as in getExpectedOrderOutcome\n        uint256 discountedTokenPrice = getDiscountedTokenPrice(order.token2sell, timePassed, order.discountType);\n        uint256 priceB = ORACLE.getFiatPrice1e18(order.token2buy);\n        outAmount = inAmount * discountedTokenPrice / priceB;\n\n        order.token2buyAmount += outAmount;\n        order.amountLeft -= inAmount;\n\n        // If in order some token amount left after updating it\n        // then it should have value > DUST_THRESHOLD, counted in fiat\n        if (order.amountLeft > 0 && discountedTokenPrice * order.amountLeft / 1e18 <= DUST_THRESHOLD) {\n            revert SmallAmountLeft();\n        }\n\n        TransferHelper.safeTransfer(order.token2sell, msg.sender, inAmount);\n\n        uint256 balanceBefore = IERC20(order.token2buy).balanceOf(address(this));\n        if(!IExchangeCallback(msg.sender).stableunitFillOrderCallback(order.token2buy, outAmount, msg.sender, data)) {\n            revert CallbackError();\n        }\n        uint256 balanceAfter = IERC20(order.token2buy).balanceOf(address(this));\n        if (balanceAfter < balanceBefore + outAmount) revert NotEnoughReturnValue();\n\n        // TODO: check tokenomics with profit to exchange/middleware\n        TransferHelper.safeTransfer(order.token2buy, order.beneficiary, outAmount);\n\n        if (order.amountLeft == 0) {\n            delete orders[orderId];\n            EnumerableSetUpgradeable.remove(orderIdSet, orderId);\n            emit OrderFilled(orderId);\n        } else {\n            emit OrderFilledPartially(orderId);\n        }\n    }\n\n    function getOrder (uint256 orderId) public view returns (Order memory) {\n        return orders[orderId];\n    }\n\n    function getOrdersCount() public view returns (uint256) {\n        return EnumerableSetUpgradeable.length(orderIdSet);\n    }\n\n    // TODO: add pagination\n    /**\n     * @notice This method will be deleted after we'll add GraphQL to watch orders\n    **/\n    function getAllOrders() external view returns (OrderWithId[] memory) {\n        uint256[] memory orderIdValues = EnumerableSetUpgradeable.values(orderIdSet);\n        uint256 len = orderIdValues.length;\n        OrderWithId[] memory result = new OrderWithId[](len);\n        for (uint256 i = 0; i < len; i++) {\n            uint256 orderId = orderIdValues[i];\n            result[i] = OrderWithId({\n                order: orders[orderId],\n                orderId: orderId\n            });\n        }\n        return result;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return interfaceId == type(IExchange).interfaceId;\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/exchange/contracts/TopStakers.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/ITopStakers.sol\";\nimport \"../../periphery/contracts/access-control/SuAuthenticated.sol\";\n\n// TODO: It's Mock, only for test usage\n/**\n * @notice Real TopStaker in polygon/mainnet will be different, but with the same interface\n**/\ncontract TopStakers is SuAuthenticated, ITopStakers {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // move to another contract\n    EnumerableSetUpgradeable.AddressSet private topStakers;\n\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n    }\n\n    function addTopStaker(address staker) public onlyAdmin {\n        if (isTopStaker(staker)) revert StakerExist(staker);\n        EnumerableSetUpgradeable.add(topStakers, staker);\n    }\n\n    function removeTopStaker(address staker) public onlyAdmin {\n        if (!isTopStaker(staker)) revert StakerNotExist(staker);\n        EnumerableSetUpgradeable.remove(topStakers, staker);\n    }\n\n    function isTopStaker(address staker) public view returns(bool) {\n        return EnumerableSetUpgradeable.contains(topStakers, staker);\n    }\n\n    function getTopStakersLength() public view returns(uint256) {\n        return EnumerableSetUpgradeable.length(topStakers);\n    }\n}\n"
    },
    "contracts/exchange/interfaces/IArbitrageHelper.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"./IExchangeCallback.sol\";\n\nstruct FlashCallbackData {\n    bool isLP;\n    uint256 orderId;\n    address token2sell;\n    uint256 token2sellAmount;\n    address recipient;\n    InchData[] inchData;\n}\n\nstruct ParaswapData {\n    address contractAddress;\n    address tokenTransferProxy;\n    bytes data;\n}\n\nstruct InchData {\n    address contractAddress;\n    bytes data;\n    address token; // needed only if adapter unwrap not to all underlying tokens\n}\n\ninterface IArbitrageHelper is IExchangeCallback {\n    /* ===================== ERRORS ===================== */\n    error NotAPool(address sender);\n    error SwapNotProfitable();\n    error SwapByParaSwapError();\n    error SwapBy1InchError();\n    error BadSender(address sender);\n    error LPTokenNotSupported(address lpToken);\n    error LPTokenNotRegistered(address lpToken);\n\n    /* ===================== EVENTS ===================== */\n    // event SwapByUniswap(address tokenA, address tokenB);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n\n    /**\n      * @notice Register LP to use it adapter to withdraw or get price of LP later in swapLPWithFlashLoan();\n      * @param lp - address of LP token\n      * @param lpAdapter - address of LPAdapter for this LP token\n    **/\n    function registerLP(address lp, address lpAdapter) external;\n\n    /**\n      * @notice Reference implementation of Arbitrage bot contract, that use Exchange module to get profit\n      * @dev Contract receive loan from exchange module, sell it on 1inch and get profit = received amount - fee\n      * @param orderId - Id of order in Exchange module to fill\n      * @param token2sell - Token in order to get as flash-loan\n      * @param token2sellAmount - Amount of token in order to get as flash-loan\n      * @param inchData - 1inch callData and contract to swap loan\n     **/\n    function swapWithFlashLoan(\n        uint256 orderId,\n        address token2sell,\n        uint256 token2sellAmount,\n        InchData memory inchData\n    ) external;\n\n    /**\n      * @notice The same as swapWithFlashLoan, but loan is LP-token that we need to unwrap\n      * @dev Contract receive LP-token from exchange module, unwrap it and swap with 1inch all underline tokens\n      * to token that exchange module need.\n      * @param orderId - Id of order in Exchange module to fill\n      * @param token2sell - Token in order to get as flash-loan\n      * @param token2sellAmount - Amount of token in order to get as flash-loan\n      * @param inchData - 1inch callData and contract array to swap every underline token of LP\n     **/\n    function swapLPWithFlashLoan(\n        uint256 orderId,\n        address token2sell,\n        uint256 token2sellAmount,\n        InchData[] memory inchData\n    ) external;\n}"
    },
    "contracts/exchange/interfaces/IArbitrageHelperUniswap.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nstruct FlashCallbackData {\n    uint256 orderId;\n    address tokenA;\n    address tokenB;\n    uint256 tokenBAmount;\n    address recipient;\n    bytes path;\n}\n\ninterface IArbitrageHelperUniswap {\n    /* ===================== ERRORS ===================== */\n    error NotAPool(address sender);\n    error BadSender(address sender);\n    error BadDecodedData();\n    error SwapNotProfitable();\n\n    /* ==================== MUTABLE METHODS ==================== */\n    function swapWithFlashLoan(\n        uint256 orderId,\n        address tokenA,\n        address tokenB,\n        uint256 tokenBAmount,\n        bytes memory path\n    ) external;\n}"
    },
    "contracts/exchange/interfaces/IExchange.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nenum DiscountType {\n    aggressive,\n    middle,\n    conservative\n}\n\nstruct Order {\n    address token2sell;\n    uint256 amountLeft;\n    address token2buy;\n    uint256 token2buyAmount;\n    address beneficiary;\n    uint256 creationTimestamp;\n    DiscountType discountType;\n    address caller;\n}\n\nstruct OrderWithId {\n    Order order;\n    uint256 orderId;\n}\n\ninterface IExchange {\n    /* ===================== ERRORS ===================== */\n    error OrderExist(uint256 orderId);\n    error OrderNotExist(uint256 orderId);\n    error IncorrectToken(address orderToken2buy, address inToken);\n    error SmallAmountLeft();\n    error UserIsNotBeneficiary();\n    error IsNotTopStaker(address staker);\n    error OrderNotForThisStaker(uint256 orderId, address staker);\n    error NotEnoughReturnValue();\n    error CallbackError();\n\n    /* ======================== EVENTS ========================= */\n    event OrderAdded(uint256 orderId);\n    event OrderCanceled(uint256 orderId);\n    event OrderFilled(uint256 orderId);\n    event OrderFilledPartially(uint256 orderId);\n    event LpOrdersAdded(address LPToken, uint256[] orderIds);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    /**\n      * @notice Add order to swap {token2sell} to {token2buy}.\n      * @dev This swap is async, because depends on how arbitrage bots will fill this order. Emits OrderAdded() event.\n      * Before addOrder user needs to approve token2sell for exchange contract\n      * @param token2sell - Address of token to sell\n      * @param amount2sell - Amount of {token2sell} to sell\n      * @param token2buy - Address of token to buy\n      * @param beneficiary - Address that will receive {token2buy} after filling order.\n      * @param discountType - Speed of decreasing swap price. { 0 - aggressive, 1 - middle, 2 - conservative }\n      * @param collateralJoin - address of collateral adapter\n     **/\n    function addOrder (\n        address token2sell,\n        uint256 amount2sell,\n        address token2buy,\n        address beneficiary,\n        DiscountType discountType,\n        address collateralJoin\n    ) external returns (uint256);\n\n    /**\n      * @notice Only user who place order or who is beneficiary can cancelOrder();\n      * @param orderId - Id of order to cancel.\n     **/\n    function cancelOrder (uint256 orderId) external;\n\n    /**\n      * @notice Fill order with flash-loan like logic\n      * @dev Caller contract receive orders {token2sell} and after that his stableunitFillOrderCallback() is called.\n      * At the end of thi callback contract should send some amount of another token back to Exchange contract.\n      * @param orderId - Id of order to fill.\n      * @param inAmount - Amount of {token2sell} to receive\n      * @param data - encoded data to pass to callback function\n     **/\n    function fillOrderAsFlashLoan (\n        uint256 orderId,\n        uint256 inAmount,\n        bytes memory data\n    ) external returns (uint256 outAmount);\n\n    /**\n      * @notice Function to update price curve - how fast {token2sell} price will decrease/increase\n      * @param discountType - discount type to change\n      * @param newPriceCurve - parameters of formula\n     **/\n    function setPriceCurve(DiscountType discountType, uint256[2] calldata newPriceCurve) external;\n\n    /* ==================== VIEW METHODS ==================== */\n    /**\n      * @return The amount of outcome that caller will receive if he will fill {orderId} with {inAmount} of {token2sell}\n     **/\n    function getExpectedOrderOutcome (uint256 orderId, uint256 inAmount) external view returns (uint256);\n\n    /**\n      * @return Order with id = {orderId}\n     **/\n    function getOrder (uint256 orderId) external view returns (Order memory);\n\n    /**\n      * @return The amount of not full-filled orders\n     **/\n    function getOrdersCount () external view returns (uint256);\n\n    /**\n      * @return The array of all not-filled orders. May be deleted after adding GraphQL for orderIds\n     **/\n    function getAllOrders () external view returns (OrderWithId[] memory);\n}\n"
    },
    "contracts/exchange/interfaces/IExchangeCallback.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\ninterface IExchangeCallback {\n    /**\n     * @notice Callback that will be called by Exchange module in fillOrderAsFlashLoan()\n     * after sending collateral to msg.sender.\n     * In the implementation you must pay stablecoin for Exchange contract.\n     * @dev Any contract that calls Exchange#fillOrderAsFlashLoan must implement this interface\n     * @param asset - The address of the token that should be returned\n     * @param amount - The amount of the {token} to return\n     * @param initiator The address of the flashloan initiator\n     * @return True if the execution of the operation succeeds, false otherwise\n     */\n    function stableunitFillOrderCallback (\n        address asset,\n        uint256 amount,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool);\n}\n"
    },
    "contracts/exchange/interfaces/ITopStakers.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\n// WARNING: Implementation is a mock, but the interface will be the same\ninterface ITopStakers {\n    /* ===================== ERRORS ===================== */\n    error StakerExist(address staker);\n    error StakerNotExist(address staker);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    function addTopStaker(address staker) external;\n\n    function removeTopStaker(address staker) external;\n\n    /* ==================== VIEW METHODS ==================== */\n\n    function isTopStaker(address staker) external view returns(bool);\n    function getTopStakersLength() external view returns(uint256);\n}"
    },
    "contracts/gain-erc20/GainErc20v1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * This is fork on openzeppelin_v4 ERC20\n */\ninterface IGainable {\n    /**\n     * @dev Transfers amount of tokens from msg.sender and distributes it to all accounts\n     *      proportional to the account's balances.\n     *      No mints or burns happens, totalSupply remains unchanged.\n     * @param amount of tokens to be distributed\n     */\n    function distribute(uint256 amount) external;\n    event Distributed(uint256 amount, uint256 newMultiplicator1e18);\n}\n\n// TODO: check that changes with _preimageBalances work and don't break erc20 logic. Coverage should be 100%\n// TODO: finish code for distribute function and test against mint, burn, and all erc20 logic\n\ncontract GainErc20v1 is Context, IERC20, IGainable {\n    /**\n     * Instead of _balances mapping we use _preimageBalances and special multiplicator >= 1 that:\n     *      _balances[account] == _preimageBalances[account] * multiplicator\n     *      multiplicator is coded as fraction _multiplicator1e18 / 1e18\n     *  Original code with _balances preserved in // comments for clarity\n     */\n    // mapping (address => uint256) private _balances;\n    mapping (address => uint256) private _preimageBalances;\n    uint256 public _multiplicator1e18;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    function distribute(uint256 amount) external {\n        // TODO: test this implementation\n        /**\n         *  because it's just re-distribution of existing tokens, total supply doesn't change\n         *  total values of recipients = totalSupply - amount\n         *  total values of recipients = sum(_preimageBalances of recipients) * multiplicator\n         *  after distribution, totalSupply = sum(_preimageBalances of recipients) * newMultiplicator\n         *  let s := sum(_preimageBalances of recipients)\n         *  totalSupply - amount = s * multiplicator && totalSupply = s * newMultiplicator\n         *  <=> totalSupply = s * multiplicator + amount = s * newMultiplicator\n         *  <=> s = (totalSupply - amount) / multiplicator && newMultiplicator = totalSupply / s\n         *\n         *  now, if multiplicator increased, totalSupply != sum(_preimageBalances of everyone) * newMultiplicator\n         *  so we have to decrease balanceOf(this) for this amount\n         *  however, this is not burn, since totalSupply shouldn't change\n         *  after that we can increase multiplicator\n         */\n        // @dev  straightforward implementation\n        //\n        //        this.transferFrom(_msgSender(), address(this), amount);\n        //        uint256 s = (_totalSupply - amount) * 1e18 / _multiplicator1e18;\n        //        uint256 newMultiplicator1e18 = _totalSupply * 1e18 / s;\n        //        require(newMultiplicator1e18 > _multiplicator1e18);\n        //        uint256 thisBalance = _preimageBalances[address(this)] * _multiplicator1e18 / 1e18;\n        //        _preimageBalances[address(this)] = (thisBalance - amount) * 1e18 / _multiplicator1e18;\n        //        _multiplicator1e18 = newMultiplicator1e18;\n\n        // @dev simplified implementation\n\n        this.transferFrom(_msgSender(), address(this), amount);\n\n        // same as this.balanceOf(address(this));\n        uint256 thisBalance = _preimageBalances[address(this)] * _multiplicator1e18 / 1e18;\n\n        // @dev for ACTION_CASE[3] with transfer that can lost some tokens:\n        // thisBalance =        19999999999999999999,\n        // amount =             20000000000000000000,\n        // _multiplicator1e18 = 1500000000000000000\n\n        // \"burn\" amount\n        _preimageBalances[address(this)] = (thisBalance - amount) * 1e18 / _multiplicator1e18;\n\n        // allocate the same amount via increasing multiplicator\n        uint256 newMultiplicator1e18 = _multiplicator1e18 * _totalSupply / (_totalSupply - amount);\n        _multiplicator1e18 = newMultiplicator1e18;\n\n        emit Distributed(amount, newMultiplicator1e18);\n    }\n\n    //===================================================================\n    // We need to disable custom-errors rule to behave like standard ERC20 token\n    /* solhint-disable custom-errors */\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _multiplicator1e18 = 1 * 1e18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        // return _balances[account];\n        return _preimageBalances[account] * _multiplicator1e18 / 1e18;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(sender, spender, amount);\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        // uint256 senderBalance = _balances[sender];\n        uint256 senderBalance = _preimageBalances[sender] * _multiplicator1e18 / 1e18;\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        // _balances[sender] = senderBalance - amount;\n        uint256 epsSender = (senderBalance - amount) -\n            ((senderBalance - amount) * 1e18 / _multiplicator1e18) * _multiplicator1e18 / 1e18;\n        _preimageBalances[sender] = (senderBalance - amount) * 1e18 / _multiplicator1e18 + epsSender;\n\n        // _balances[recipient] += amount;\n        uint256 epsRecipient = amount - ((amount) * 1e18 / _multiplicator1e18) * _multiplicator1e18 / 1e18;\n        _preimageBalances[recipient] += (amount) * 1e18 / _multiplicator1e18 + epsRecipient;\n\n\n        emit Transfer(sender, recipient, amount);\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        // _balances[account] += amount;\n        _preimageBalances[account] += amount * 1e18 / _multiplicator1e18;\n\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        // uint256 accountBalance = _balances[account];\n        uint256 accountBalance = _preimageBalances[account] * _multiplicator1e18 / 1e18;\n\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        // _balances[account] = accountBalance - amount;\n        _preimageBalances[account] = (accountBalance - amount) * 1e18 / _multiplicator1e18;\n\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    // solhint-disable-next-line no-empty-blocks\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    // solhint-disable-next-line no-empty-blocks\n    ) internal virtual {}\n    /* solhint-enable custom-errors */\n}\n"
    },
    "contracts/gain-erc20/GainErc20v3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * This is fork on openzeppelin ERC20 v4.5.0\n * @dev Implementation of the {IERC20} interface.\n */\ncontract GainableERC20v3 is Context, IERC20, IERC20Metadata {\n    using SafeCast for uint256;\n    using SafeCast for uint128;\n    using SafeCast for uint64;\n    using SafeCast for int256;\n\n    /**\n     * log2(1e18) = 60 bit\n     *\n     */\n    struct IAccount {\n        uint256 balance;\n        int256 rewardDebt;\n        bool isGainDisabled;\n    }\n\n    struct IRewardPool {\n        uint128 accRewardPerShare;\n        uint64 lastRewardBlock;\n        //        uint256 lpSupply;\n    }\n\n    error BadEndBlock();\n\n    uint256 private constant ACC_REWARD_TOKEN_PRECISION = 1e12;\n    IRewardPool public rewardPool;\n\n    mapping(address => IAccount) public _accounts;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    // ==========================REWARDER================================\n    uint256 public rewardPerBlock;\n    uint256 public rewardEndBlock;\n\n    function refillReward(uint256 amount, uint64 endBlock) public {\n        if (block.number >= endBlock) revert BadEndBlock();\n        updateRewardPool();\n\n        transferFrom(msg.sender, address(this), amount);\n        uint256 rewardLeftAmount;\n        // if there are active rewards leftovers\n        if (rewardEndBlock > 0) {\n            // if we call refillReward before old endBlock ends\n            if (block.number < rewardEndBlock) {\n                rewardLeftAmount = rewardPerBlock * (rewardEndBlock - block.number);\n            } else {\n                // if we start the new reward interval that has nothing in common with the old noe\n                rewardLeftAmount = 0;\n            }\n        }\n        rewardPerBlock = (rewardLeftAmount + amount) / (endBlock - block.number);\n        rewardEndBlock = endBlock;\n    }\n\n    /**\n     *  @dev returns total amount of rewards allocated to the all pools on the rage (startBlock, endBlock]\n     *      i.e. excluding startBlock but including endBlock\n     */\n    function rewardsBetweenBlocks(uint256 startBlock, uint256 endBlock) public view returns (uint256) {\n        // if all rewards were allocation before our rage - then answer is 0\n        if (rewardEndBlock <= startBlock) {\n            return 0;\n        } else {\n            // if rewards allocates on the whole range, than just calc rectangle area\n            if (endBlock < rewardEndBlock) {\n                return (endBlock - startBlock) * rewardPerBlock;\n            } else {\n                // other-vice, rewards end its allocation during our rage, so we have to calc only until rewardEndBlock\n                return (rewardEndBlock - startBlock) * rewardPerBlock;\n            }\n        }\n    }\n\n    function updateRewardPool() public {\n        if (block.number > rewardPool.lastRewardBlock) {\n            uint256 totalRewardsSinceLastUpdate = rewardsBetweenBlocks(rewardPool.lastRewardBlock, block.number);\n            uint256 activeSupply = _totalSupply;\n            // totalSupply - undistributed reward - disabled accounts\n            if (activeSupply > 0) {\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare +\n                (totalRewardsSinceLastUpdate * ACC_REWARD_TOKEN_PRECISION / activeSupply).toUint128();\n            }\n            rewardPool.lastRewardBlock = block.number.toUint64();\n        }\n    }\n\n    function pendingRewards(address account) public view returns (uint256) {\n        // simulate updateRewardPool() in-place\n        uint256 totalRewardsSinceLastUpdate = rewardsBetweenBlocks(rewardPool.lastRewardBlock, block.number);\n        uint256 activeSupply = _totalSupply;\n        // TODO: if we'll have some initial _totalSupply we can remove some conditions\n        if (activeSupply == 0) {\n            return 0;\n        }\n        // totalSupply - undistributed reward - disabled accounts\n        uint256 currentAccRewardPerShare = rewardPool.accRewardPerShare +\n        (totalRewardsSinceLastUpdate * ACC_REWARD_TOKEN_PRECISION / activeSupply).toUint128();\n\n        // simulate harvest()\n        IAccount memory user = _accounts[account];\n        int256 completeAccountReward = (\n            user.balance * currentAccRewardPerShare / ACC_REWARD_TOKEN_PRECISION\n        ).toInt256();\n        uint256 pending = (completeAccountReward - user.rewardDebt).toUint256();\n        return pending;\n    }\n\n    function harvest(address account) internal {\n        IAccount storage user = _accounts[account];\n        updateRewardPool();\n        uint256 _pendingRewards = pendingRewards(account);\n        user.balance = user.balance + _pendingRewards;\n        user.rewardDebt = (user.balance * rewardPool.accRewardPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256();\n    }\n\n    function getYieldAPR() public view returns (uint256) {\n        if (block.number > rewardEndBlock) {\n            return 0;\n        }\n        uint256 rewardsLeftToDistribute = rewardPerBlock * (rewardEndBlock - block.number);\n        uint256 activeSupply = totalSupply() - rewardsLeftToDistribute;\n        uint256 blocksPerYear = 4 * 60 * 24 * 365;\n\n        return rewardPerBlock * blocksPerYear * 1e18 / activeSupply;\n    }\n    //===================================================================\n    // We need to disable custom-errors rule to behave like standard ERC20 token\n    /* solhint-disable custom-errors */\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _accounts[account].balance + pendingRewards(account);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n        _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _accounts[from].balance;\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n        _accounts[from].balance = fromBalance - amount;\n    }\n        _accounts[to].balance += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _accounts[account].balance += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _accounts[account].balance;\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n        _accounts[account].balance = accountBalance - amount;\n    }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - amount);\n        }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal {\n        harvest(from);\n        harvest(to);\n    }\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    // solhint-disable-next-line no-empty-blocks\n    ) internal virtual {}\n    /* solhint-enable custom-errors */\n}\n"
    },
    "contracts/gain-erc20/GainErc20v3Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\n\n/**\n * This is fork on openzeppelin ERC20Upgradeable v4.5.0\n * @dev Implementation of the {IERC20} interface.\n */\ncontract GainableERC20v3Upgradeable is\nInitializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable, SuAuthenticated {\n    using SafeCastUpgradeable for uint256;\n    using SafeCastUpgradeable for uint128;\n    using SafeCastUpgradeable for uint64;\n    using SafeCastUpgradeable for int256;\n\n    /**\n     * log2(1e18) = 60 bit\n     */\n    struct IAccount {\n        uint256 balance;\n        int256 rewardDebt;\n        address redirectYieldTo;\n        // bool isGainDisabled;\n    }\n\n    struct IRewardPool {\n        uint128 accRewardPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    error BadEndBlock();\n\n    uint256 private constant ACC_REWARD_TOKEN_PRECISION = 1e12;\n    uint256 public constant REWARD_PRECISION = 1e14; // so min reward is 1e-4 unit cents\n    IRewardPool public rewardPool;\n\n    mapping(address => IAccount) public _accounts;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    // ==========================REWARDER================================\n    uint256 public rewardPerBlock;\n    uint256 public rewardEndBlock;\n\n    function refillReward(uint256 amount, uint64 endBlock) public {\n        if (block.number >= endBlock) revert BadEndBlock();\n        updateRewardPool();\n\n        transferFrom(msg.sender, address(this), amount);\n        uint256 rewardLeftAmount;\n        // if there are active rewards leftovers\n        if (rewardEndBlock > 0) {\n            // if we call refillReward before old endBlock ends\n            if (block.number < rewardEndBlock) {\n                rewardLeftAmount = rewardPerBlock * (rewardEndBlock - block.number);\n            } else {\n                // if we start the new reward interval that has nothing in common with the old noe\n                rewardLeftAmount = 0;\n            }\n        }\n        rewardPerBlock = (rewardLeftAmount + amount) / (endBlock - block.number);\n        rewardEndBlock = endBlock;\n    }\n\n    /**\n     *  @dev returns total amount of rewards allocated to the all pools on the rage (startBlock, endBlock]\n     *      i.e. excluding startBlock but including endBlock\n     */\n    function rewardsBetweenBlocks(uint256 startBlock, uint256 endBlock) public view returns (uint256) {\n        // if all rewards were allocation before our range - then answer is 0\n        if (rewardEndBlock <= startBlock) {\n            return 0;\n        } else {\n            // if rewards allocates on the whole range, than just calc rectangle area\n            if (endBlock < rewardEndBlock) {\n                return (endBlock - startBlock) * rewardPerBlock;\n            } else {\n                // other-vice, rewards end its allocation during our rage, so we have to calc only until rewardEndBlock\n                return (rewardEndBlock - startBlock) * rewardPerBlock;\n            }\n        }\n    }\n\n    function rewardsLeftToDistribute() internal view returns (uint256) {\n        if (block.number > rewardEndBlock) {\n            return 0;\n        }\n        return rewardPerBlock * (rewardEndBlock - block.number);\n    }\n\n    function updateRewardPool() public {\n        if (block.number > rewardPool.lastRewardBlock) {\n            uint256 activeSupply = _totalSupply - rewardsLeftToDistribute();\n            // totalSupply - undistributed reward - disabled accounts\n            if (activeSupply > 0) {\n                uint256 totalRewardsSinceLastUpdate = rewardsBetweenBlocks(rewardPool.lastRewardBlock, block.number);\n\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare +\n                            (totalRewardsSinceLastUpdate * ACC_REWARD_TOKEN_PRECISION / activeSupply).toUint128();\n            }\n            rewardPool.lastRewardBlock = block.number.toUint64();\n        }\n    }\n\n    function pendingRewards(address account) public view returns (uint256) {\n        // simulate updateRewardPool() in-place\n        uint256 activeSupply = _totalSupply - rewardsLeftToDistribute();\n        // We need to have some initial _totalSupply or we'll have division by zero here.\n        if (activeSupply == 0) {\n            return 0;\n        }\n\n        uint256 currentAccRewardPerShare = rewardPool.accRewardPerShare;\n        if (block.number > rewardPool.lastRewardBlock) {\n            uint256 totalRewardsSinceLastUpdate = rewardsBetweenBlocks(rewardPool.lastRewardBlock, block.number);\n            // totalSupply - undistributed reward - disabled accounts\n            currentAccRewardPerShare = currentAccRewardPerShare +\n                (totalRewardsSinceLastUpdate * ACC_REWARD_TOKEN_PRECISION / activeSupply);\n        }\n\n        // simulate harvest()\n        IAccount memory user = _accounts[account];\n        int256 completeAccountReward = (\n            user.balance * currentAccRewardPerShare / ACC_REWARD_TOKEN_PRECISION\n        ).toInt256();\n        uint256 pending = (completeAccountReward - user.rewardDebt).toUint256();\n\n        // Number prettier\n        // on metamask the balanceOf sometimes gives too many digits after the comma\n        // so balance looks ugly, for example: 12507.259801909711051452 StablePro\n        // Since in any known fiat currency sub-cent values are essentially worthless, let's round them up if original\n        // balance doesn't have many decimals - any number of additions of rounded values doesn't increase it\n        return (pending / REWARD_PRECISION) * REWARD_PRECISION;\n    }\n\n    function harvest(address account) internal {\n        IAccount storage user = _accounts[account];\n        updateRewardPool();\n        int256 accumulatedRewards = (\n            user.balance * rewardPool.accRewardPerShare / ACC_REWARD_TOKEN_PRECISION\n        ).toInt256();\n        uint256 _pendingRewards = (accumulatedRewards - user.rewardDebt).toUint256();\n\n        // Effects\n        user.balance = user.balance + _pendingRewards;\n        // Should use new balance\n        user.rewardDebt = (user.balance * rewardPool.accRewardPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256();\n    }\n\n    function getYieldAPR() public view returns (uint256) {\n        if (block.number > rewardEndBlock) {\n            return 0;\n        }\n        uint256 activeSupply = _totalSupply - rewardsLeftToDistribute();\n        uint256 blocksPerYear = 4 * 60 * 24 * 365;\n\n        return rewardPerBlock * blocksPerYear * 1e18 / activeSupply;\n    }\n    //===================================================================\n    // We need to disable custom-errors rule to behave like standard ERC20 token\n    /* solhint-disable custom-errors */\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC20_init(address authControl_, string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(authControl_, name_, symbol_);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC20_init_unchained(\n        address authControl_,\n        string memory name_,\n        string memory symbol_\n    ) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n        __suAuthenticatedInit(authControl_);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _accounts[account].balance + pendingRewards(account);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _accounts[from].balance;\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _accounts[from].balance = fromBalance - amount;\n            _accounts[from].rewardDebt = (\n                _accounts[from].balance * rewardPool.accRewardPerShare / ACC_REWARD_TOKEN_PRECISION\n            ).toInt256();\n        }\n        _accounts[to].balance += amount;\n        _accounts[to].rewardDebt = (\n            _accounts[to].balance * rewardPool.accRewardPerShare / ACC_REWARD_TOKEN_PRECISION\n        ).toInt256();\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _accounts[account].balance += amount;\n        _accounts[account].rewardDebt = (\n            _accounts[account].balance * rewardPool.accRewardPerShare / ACC_REWARD_TOKEN_PRECISION\n        ).toInt256();\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _accounts[account].balance;\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _accounts[account].balance = accountBalance - amount;\n            _accounts[account].rewardDebt = (\n                _accounts[account].balance * rewardPool.accRewardPerShare / ACC_REWARD_TOKEN_PRECISION\n            ).toInt256();\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256) internal {\n        if (from != address(0)) {\n            harvest(from);\n        }\n        if (to != address(0)) {\n            harvest(to);\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    // solhint-disable-next-line no-empty-blocks\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /* solhint-enable custom-errors */\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/interfaces/ICircuitBreaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../lending/SuVaultParameters.sol\";\nimport \"../interfaces/ISuVaultParameters.sol\";\nimport \"../reward/RewardChefV2.sol\";\n\n/**\n * @dev\n * Ok - protocol is working well, there is no abnormal withdrawals\n * Warning - users withdraws more than half of threshold, dev team should be notified about that\n * Triggered - admin trigger rate limit, so protocol can't withdraw tokens.\n * After some time it could be reset automatically, or manually by admin/DAO\n*/\nenum State { Ok, Warning, Triggered }\n\n/**\n * @title Circuit Breaker\n * @dev This contract is a circuit breaker designed for financial safety in DeFi protocols.\n * It acts as a middleware, monitoring the flow of funds through itself and triggering an interrupt\n * if the flow of funds exceeds a certain threshold within a defined period. The threshold could be set\n * as a percentage of the Total Value Locked (TVL) per day, for example, 15% of TVL. Upon an interrupt,\n * there are three potential outcomes:\n *\n * 1. The admin manually resets the circuit breaker. In this case, all held funds are released immediately.\n *\n * 2. No action is taken by the admin or the DAO within the threshold period. In this case, all held funds\n * are released automatically when the threshold period expires.\n *\n * 3. The admin escalates the alarm. In this case, the DAO must resolve the situation via voting.\n *\n * To prevent sudden halts in fund flow, the contract emits a warning event when it is halfway to\n * reaching the interrupt condition. This warning can be caught by an admin to spot potential interrupt\n * scenarios in advance.\n */\ninterface ICircuitBreaker {\n    /* ====================== VARS ====================== */\n\n    // how much funds passed in selected window\n    function liqInPeriod (uint256 windowId) external view returns ( uint256 );\n\n    /* ===================== EVENTS ===================== */\n    event ThresholdWarning();\n    event TriggeredRateLimitExpired();\n    event ResetByAdmin();\n    event RateLimitTriggered();\n\n    /* ===================== ERRORS ===================== */\n    error Triggered();\n    error ThresholdExceeded();\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    /**\n     * @notice  Transfer funds to a specified address.\n     *          If the threshold is exceeded, the transfer will be interrupted.\n     * @dev This function will revert if the contract state is interrupted.\n     * @param token The address of the erc20 token to transfer\n     * @param to The address to transfer to.\n     * @param amount The amount to be transferred.\n     * @param value The total value of the transfer, in fiat amount, for ex. $100 should be passed as 100, not 100*1e18.\n     *        value is needed to avoid expensive call to the oracle inside of the transfer code.\n     */\n    function controlledTransfer(address token, address to, uint256 amount, uint256 value) external;\n\n    function setFundsFlowThreshold(uint256 _fundsFlowThreshold) external;\n\n    function reset() external;\n\n    function triggerRateLimit() external;\n    /* ==================== VIEW METHODS ==================== */\n\n    function totalLiquidityInPeriod() external view returns (uint256);\n\n    function getWindowId() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRewardChefV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../periphery/contracts/interfaces/oracle/ISuOracle.sol\";\n\n/**\n * @title RewardChefV2\n * @notice fork of MasterChefV2(13/05/2023) https://etherscan.io/address/0xef0881ec094552b2e128cf945ef17a6752b4ec5d#code\n * @dev This contract is based on MVC2, but uses \"virtual\" balances instead of storing real ERC20 tokens\n * and uses address of this assets instead of pid.\n * Rewards that are distributed have to be deposited using refillReward(uint256 amount, uint64 endBlock)\n **/\ninterface IRewardChefV2 {\n    /**\n      * @notice Info of each reward pool.\n      * @param accSushiPerShare -\n      * @param lastRewardBlock -\n      * @param allocPoint - The amount of allocation points assigned to the pool.\n      * Also known as the amount of REWARD_TOKEN to distribute per block.\n      * @param lpSupply -\n     **/\n    struct PoolInfo {\n        uint128 accSushiPerShare;\n        uint64 lastRewardBlock;\n        uint64 allocPoint;\n        uint256 lpSupply;\n    }\n\n    /**\n      * @notice Info of each user.\n      * @param amount - token amount the user has provided.\n      * @param rewardDebt - The amount of rewards entitled to the user.\n      * @param multiplicator1e18 - deposit amount multiplicator for current user, that depends on his lockupPeriod\n      * @param lockupPeriodSeconds - users lockupPeriod in seconds\n      * @param lockupStartTimestamp - timestamp when user start lockup\n     **/\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n\n        uint256 multiplicator1e18;\n        uint256 lockupPeriodSeconds;\n        uint256 lockupStartTimestamp;\n    }\n\n    /**\n      * @notice Lockup info struct for a view method getPossibleLockupPeriodsSeconds()\n      * @param lockupPeriodSeconds - available lockupPeriod in seconds\n      * @param multiplicator1e18 - deposit amount multiplicator for this lockup period\n     **/\n    struct ILockupPeriod {\n        uint256 lockupPeriodSeconds;\n        uint256 multiplicator1e18;\n    }\n\n    // =======================================EVENTS=============================================\n    event VirtualDeposit(address indexed user, address indexed asset, uint256 amount);\n    event VirtualWithdraw(address indexed user, address indexed asset, uint256 amount);\n    event ResetAmount(\n        address indexed user, address indexed asset, address indexed to, uint256 amount, uint256 lockupPeriodSeconds\n    );\n    event Harvest(address indexed user, address indexed asset, uint256 amount);\n    event LogPoolAddition(address indexed asset, uint256 allocPoint);\n    event LogSetPool(address indexed asset, uint256 allocPoint);\n    event LogUpdatePool(address indexed asset, uint64 lastRewardBlock, uint256 lpSupply, uint256 accSushiPerShare);\n\n    // =======================================ERRORS=============================================\n    error BadEndBlockForRefill();\n    error ZeroLockupPeriod();\n    error ZeroMultiplicator();\n    error PoolExist();\n    error PoolNotExist();\n    error DifferentLockup();\n    error HarvestBeforeLockup();\n\n    // =========================================VARS=============================================\n    /**\n     *  @dev Total allocation points. Must be the sum of all allocation points in all pools.\n     * The good practice, to always keep this variable is equal 1000.\n     */\n    function totalAllocPoint() external view returns ( uint256 );\n\n    // =======================================REWARDER=============================================\n    // solhint-disable-next-line func-name-mixedcase\n    function REWARD_TOKEN() external view returns ( IERC20Upgradeable );\n    // solhint-disable-next-line func-name-mixedcase\n    function ORACLE() external view returns ( ISuOracle );\n    function rewardPerBlock() external view returns ( uint256 );\n    function rewardEndBlock() external view returns ( uint256 );\n\n    /**\n     * @dev admin transfer REWARD_TOKEN to contract to increase rewards per block\n     */\n    function refillReward(uint256 amount, uint64 endBlock) external;\n    /**\n     * @dev returns total amount of rewards allocated to the all pools on the rage (startBlock, endBlock]\n     * i.e. excluding startBlock but including endBlock\n     */\n    function rewardsBetweenBlocks(uint256 startBlock, uint256 endBlock) external returns ( uint256 );\n\n    //=======================================LOCKUP LOGIC===========================================\n    /**\n     * @notice view method that return all lockupPeriods in ILockupPeriod struct\n     */\n    function getPossibleLockupPeriodsSeconds() external view returns (ILockupPeriod[] memory);\n\n    /**\n     * @notice method to add new LockupPeriods with it multiplicator\n     * @dev If multiplicator1e18 == 0 => we remove lockupPeriodSeconds else we add it\n     * @param lockupPeriodSeconds Amount of seconds of lockupPeriod we want to add/remove\n     * @param multiplicator1e18 Multiplicator for that lockupPeriod\n     */\n    function setPossibleLockupPeriodsSeconds(uint256 lockupPeriodSeconds, uint256 multiplicator1e18) external;\n\n    //================================CORE REWARD CHEF METHODS======================================\n    /**\n     * @notice Add a new reward pool. Can only be called by the admin. Can't add the same LP token more than once.\n     * @param allocPoint AP of the new pool.\n     * @param _asset Address of the ERC-20 token.\n     */\n    function add(uint256 allocPoint, address _asset) external;\n\n    /**\n     * @notice Update the given pool's REWARD_TOKEN allocation point. Can only be called by the admin.\n     * Can't be called for asset that was not added by add() function.\n     * @param _asset Address of the ERC-20 token.\n     * @param _allocPoint New AP of the pool.\n     */\n    function set(address _asset, uint256 _allocPoint) external;\n\n    /**\n     * @notice View function to see pending REWARD_TOKEN on frontend.\n     * @param _asset Address of the ERC-20 token.\n     * @param _user Address of user.\n     * @return pending REWARD_TOKEN reward for a given user.\n     */\n    function pendingSushi(address _asset, address _user) external view returns ( uint256 );\n\n    /**\n     * @notice Update reward variables of the given pool.\n     * @param asset Asset address\n     * @return updated pool info\n     */\n    function updatePool(address asset) external returns ( PoolInfo memory );\n\n    /**\n     * @notice Update reward variables for all pools. Be careful of gas spending!\n     */\n    function updateAllPools() external;\n\n    /**\n     * @notice analogues to MCV2 Deposit method, but can be called only by trusted address (onlyRewardAccess)\n     * that is trusted to honestly calc how many \"virtual\" tokens have to be allocated for each user.\n     * @param asset Asset address\n     * @param to User for whom we will increase the virtual balance\n     * @param amountEDecimal Quantity without taking into account the multiplier that we will add\n     * @param lockupPeriodSeconds Current deposit lockup period. Can't increase amount with 2 different lockupPeriods\n     */\n    function increaseAmount(address asset, address to, uint256 amountEDecimal, uint256 lockupPeriodSeconds) external;\n\n    /**\n     * @notice Analogues to MVC2 Withdraw method, that can be called only by trusted address (onlyRewardAccess)\n     * that is trusted to honestly calc how many \"virtual\" tokens have to be allocated for each user.\n     * @param asset Asset address\n     * @param to User for whom we will subtract the virtual balance\n     * @param amountEDecimal Quantity without taking into account the multiplier that we will subtract\n     */\n    function decreaseAmount(address asset, address to, uint256 amountEDecimal) external;\n\n    /**\n     * @notice View method that return penalty for user that will decrease amount by {amountEDecimal}\n     * @param asset Asset address\n     * @param to User who will decrease his deposit amount\n     * @param amountEDecimal Quantity without taking into account the multiplier that we will subtract\n     */\n    function getDecreaseAmountRewardPenalty(\n        address asset,\n        address to,\n        uint256 amountEDecimal\n    ) external view returns (uint256);\n\n    /**\n     * @notice Harvest proceeds for transaction sender to {to}.\n     * @dev Here we send msg.sender pendingSushi to {to} and update lockup period.\n     * @param asset Asset address\n     * @param to Receiver of REWARD_TOKEN rewards.\n     */\n    function harvest(address asset, address to, uint256 newLockupPeriodSeconds) external;\n\n    // TODO: check for exploits\n    /**\n     * @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n     * @param asset Asset address\n     * @param to The address of the user whose information will be cleared\n     */\n    function resetAmount(address asset, address to) external;\n\n    //================================VIEW METHODS======================================\n    /**\n     * @notice Method for frontend that return pool APR\n     * @param asset Asset address\n     */\n    function getPoolApr(address asset) external view returns (uint256);\n\n    /**\n     * @notice Reward tokens can be locked for certain period of time.\n     * So user have to wait until at least timestamp to be able to harvest them.\n     * There's no lock or any restriction on withdrawing principle.\n     * This function return end timestamp for that lock.\n     * @param asset Asset address\n     * @param user User address\n     */\n    function getHarvestLockupEndTimestamp(address asset, address user) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISafeEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title SafeEngine\n * @notice The single source of truth for the Maker Protocol. It contains the accounting system of the core Vault,\n * Internal Dai balances, and collateral state. It houses the public interface for Vault management,\n * allowing safe(= CDP or Vault) owners to adjust their Vault state balances. It also contains the public interface\n * for Vault fungibility, allowing safe (Vault) owners to transfer, split, and merge Vaults.\n * Excluding these interfaces, SAFEEngine is accessed through trusted smart contract modules.\n **/\ninterface ISafeEngine {\n    /* ==================== METHODS ==================== */\n\n    // --- Auth ---\n    /**\n     * @notice Allow an address to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function approveSAFEModification(address usr) external;\n\n    /**\n     * @notice Deny an address the rights to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function denySAFEModification(address usr) external;\n\n    // --- Administration ---\n\n    function initializeCollateralType(bytes32 collateralType) external;\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n    function disableContract() external;\n\n    // --- Fungibility ---\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external;\n    function transferInternalCoins(address src, address dst, uint256 rad) external;\n\n    // --- CDP Manipulation ---\n    /**\n     * @notice Add/remove collateral or put back/generate more debt in a CDP\n     * @param collateralType Type of collateral to withdraw/deposit in and from the CDP\n     * @param cdp Target CDP\n     * @param collateralSource Account we take collateral from/put collateral into\n     * @param debtDestination Account from which we credit/debit coins and debt\n     * @param deltaCollateral Amount of collateral added/extract from the CDP\n     * @param deltaDebt Amount of debt to generate/repay\n     */\n    function modifySAFECollateralization(bytes32 collateralType, address cdp, address collateralSource, address debtDestination, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Fungibility ---\n    /**\n     * @notice Transfer collateral and/or debt between CDPs\n     * @param collateralType Collateral type transferred between CDPs\n     * @param src Source CDP\n     * @param dst Destination CDP\n     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst\n     * @param deltaDebt Amount of debt to take/add into src and give/take from dst\n     */\n    function transferSAFECollateralAndDebt(bytes32 collateralType, address src, address dst, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Confiscation ---\n    /**\n     * @notice Normally used by the LiquidationEngine in order to confiscate collateral and\n       debt from a CDP and give them to someone else\n     * @param collateralType Collateral type the CDP has locked inside\n     * @param cdp Target CDP\n     * @param collateralCounterparty Who we take/give collateral to\n     * @param debtCounterparty Who we take/give debt to\n     * @param deltaCollateral Amount of collateral taken/added into the CDP\n     * @param deltaDebt Amount of debt taken/added into the CDP\n     */\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address cdp, address collateralCounterparty, address debtCounterparty, int deltaCollateral, int deltaDebt) external;\n\n    // --- Settlement ---\n    /**\n     * @notice Nullify an amount of coins with an equal amount of debt\n     * @param rad Amount of debt & coins to destroy (expressed as a number with 45 decimals)\n     */\n    function settleDebt(uint rad) external;\n\n    /**\n     * @notice Usually called by CoinSavingsAccount in order to create unbacked debt\n     * @param debtDestination Usually AccountingEngine that can settle decreaseSoldAmount with surplus\n     * @param coinDestination Usually CoinSavingsAccount who passes the new coins to depositors\n     * @param rad Amount of debt to create (expressed as a number with 45 decimals)\n     */\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external;\n\n    // --- Rates ---\n    /**\n     * @notice Usually called by TaxCollector in order to accrue interest on a specific collateral type\n     * @param collateralType Collateral type we accrue interest for\n     * @param surplusDst Destination for amount of surplus created by applying the interest rate\n       to debt created by CDPs with 'collateralType'\n     * @param accumulatedRate Multiplier applied to the debtAmount in order to calculate the surplus\n     */\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external;\n}\n"
    },
    "contracts/interfaces/ISuCdpRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @title SuCdpRegistry\n * @notice This contract is needed to index all opened CDPs.\n * @dev It can be removed if there's more gas-efficient way to do that, such as graphQL, NFT-lps or other methods\n **/\ninterface ISuCdpRegistry {\n    /// @notice Collateral Debt Position\n    struct CDP {\n        address asset; // collateral token\n        address owner; // borrower account\n    }\n\n    /* ===================== EVENTS ===================== */\n\n    /// @notice event emitted when a new CDP is created\n    event Added(address indexed asset, address indexed owner);\n\n    /// @notice event emitted when a CDP is closed\n    event Removed(address indexed asset, address indexed owner);\n\n    /* ===================== ERRORS ===================== */\n\n    error ArgumentsLengthMismatch();\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    /// @notice method to add or remove owner from cdpList[asset]\n    function checkpoint ( address asset, address owner ) external;\n\n    /* ==================== VIEW METHODS ==================== */\n\n    /// @notice read-only function to get the list of all cdps\n    function getAllCdps (  ) external view returns ( CDP[] memory r );\n\n    /// @notice read-only function to get the list of cdps for a given collateral\n    function getCdpsByCollateral ( address asset ) external view returns ( CDP[] memory cdps );\n\n    /// @notice read-only function to get the list of all cdps by borrower\n    function getCdpsByOwner ( address owner ) external view returns ( CDP[] memory r );\n\n    /// @notice total number of cdps\n    function getCdpsCount (  ) external view returns ( uint256 totalCdpCount );\n\n    /// @notice number of cdps for a given collateral\n    function getCdpsCountForCollateral ( address asset ) external view returns ( uint256 );\n\n    /// @notice alive means there are debts in the vault for this collateral of this borrower\n    function isAlive ( address asset, address owner ) external view returns ( bool );\n\n    /// @notice listed means there are created cdps in this contract for this collateral of this borrower\n    function isListed ( address asset, address owner ) external view returns ( bool );\n}\n"
    },
    "contracts/interfaces/ISuCollateralRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nstruct CollateralRegistryInfo {\n    uint256 index;\n    bool isDisabled;\n}\n\n/**\n * @title SuCollateralRegistry\n * @notice Simple collateral container of assets as collaterals for our protocol.\n * @dev It's used only by CdpRegistry.\n **/\ninterface ISuCollateralRegistry {\n    /* ===================== EVENTS ===================== */\n    event CollateralAdded(address indexed asset);\n    event CollateralDisabled(address indexed asset);\n    event CollateralEnabled(address indexed asset);\n\n    /* ===================== ERRORS ===================== */\n\n    error ZeroAddress();\n    error AlreadyExist();\n    error NotExist();\n    error AlreadyDisabled();\n    error AlreadyEnabled();\n\n    /* ==================== METHODS ==================== */\n\n    /**\n     * @notice Add asset as collateral for our protocol\n     * @dev After deployment collaterals should be added in our protocol\n     **/\n    function addCollateral ( address asset ) external;\n\n    /**\n     * @notice Disable collateral in our protocol.\n     * Not removed, because it can add problems with users with removed collateral\n     **/\n    function disableCollateral ( address asset ) external;\n\n    /**\n     * @notice Enable recently added collateral in our protocol.\n     * Not removed, because it can add problems with users with removed collateral\n     **/\n    function enableCollateral ( address asset ) external;\n\n    /**\n     * @notice Check whether asset is collateral\n     **/\n    function isCollateral ( address asset ) external view returns ( bool );\n}\n"
    },
    "contracts/interfaces/ISuLiquidationMiddleware.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\n/* @notice This contract is middleware between our Lending module and Exchange module.\n * This contract is responsible for getting collateral to liquidate from lending module, sell it using exchange module.\n * After sell users with StablePro can swap them to another stablecoin.\n * Also DAO can send profit after profitable liquidations to foundation or get swapped StablePro.\n */\ninterface ISuLiquidationMiddleware {\n    /* ===================== ERRORS ===================== */\n    error BadStablecoin(address badStablecoin);\n    error NoProfit();\n    error NoStablePro();\n\n    /* ===================== EVENTS ===================== */\n    event CollateralBorrowed(uint256 debt);\n    event StableProSwapped(uint256 amount);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    /**\n      * @notice Set order to swap collateral to stablecoin to exchange module and store his debt to the SuManager\n      * @dev TriggerLiquidation in SuManager need to send collateral to this contract and call this function\n      * @param collateral - collateral token address\n      * @param amount - The amount of LP-token to be unwrapped\n      * @param debt - debt to the SuManager - how much StablePro user borrow using this collateral\n     **/\n    function borrowCollateralToSell (\n        address collateral,\n        uint256 amount,\n        uint256 debt\n    ) external;\n\n    /**\n      * @notice Swap users StablePro to Stablecoin that Middleware receive from exchange module after filling order\n      * @dev User need to approve StablePro for Middleware\n      * @param stablecoinToken - what stablecoin user want to receive\n      * @param stablecoinAmountEDecimal - The amount of stablecoinToken to receive\n     **/\n    function swapStableProToStablecoin(\n        address stablecoinToken,\n        uint256 stablecoinAmountEDecimal\n    ) external;\n\n    /**\n      * @notice DAO can send profit after liquidations that accumulates in this contract to foundation\n     **/\n    function sendProfitToFoundation() external;\n\n    /**\n      * @notice After swapping Stablecoin to users StablePro Middleware can send them to DAO,\n      * that can send them to liquidity pool, burn them and etc.\n     **/\n    function sendStableProToDAO() external;\n\n    function addWhitelistStablecoin(address _stablecoin) external;\n\n    function removeWhitelistStablecoin(address _stablecoin) external;\n\n    /* ==================== VIEW METHODS ==================== */\n\n    function hasWhitelistStablecoin(address _stablecoin) external view returns(bool);\n}\n"
    },
    "contracts/interfaces/ISuManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./ISuManagerParameters.sol\";\nimport \"./ISuManagerHelpers.sol\";\nimport \"./ISuManagerLiquidation.sol\";\n\n/**\n * @title SuManager\n * @notice Manager mighty over the vault. Allows users to interact with their CDPs.\n * User does only interact with manager as proxy to the vault.\n **/\ninterface ISuManager is ISuManagerParameters, ISuManagerHelpers, ISuManagerLiquidation {\n    /* ===================== EVENTS ===================== */\n    /**\n     * @notice Even triggered when user deposit collateral\n     **/\n    event Join(address indexed asset, address indexed owner, uint256 main, uint256 stablecoin);\n\n    /**\n     * @notice Event triggered when user withdraws collateral\n     **/\n    event Exit(address indexed asset, address indexed owner, uint256 main, uint256 stablecoin);\n\n    /* ===================== ERRORS ===================== */\n    error Restricted();\n    error UselessTransaction();\n    error UnsupportedDecimals();\n    error UnderCollateralized();\n    error SmallCollateral();\n\n    /* ==================== METHODS ==================== */\n    /**\n     * @notice This function is called by user to deposit collateral and receive stablecoin\n     * @dev Before calling this function user has to approve the Vault to take his collateral\n     **/\n    function join(\n        address asset,\n        uint256 assetAmountEDecimal,\n        uint256 stablecoinAmountE18,\n        uint256 lockupPeriodSeconds\n    ) external;\n\n    /**\n     * @notice User can pay back the stablecoin and take his collateral\n     * instead of passing both assetAmount and stablecoinAmount\n     * better user just to pass one of them\n     * also pass preferred rate and maybe acceptable diff percent\n     * that's the purpose of passing both to protect user from rate fluctuations\n     **/\n    function exit(address asset, uint256 assetAmountEDecimal, uint256 stablecoinAmountE18) external;\n}\n"
    },
    "contracts/interfaces/ISuManagerHelpers.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title ISuManagerHelpers\n * @notice Abstract contract that should be in SuManager. Here we have all view and ui-helpers methods.\n * Here we don't change any values.\n **/\ninterface ISuManagerHelpers {\n    /* ===================== ERRORS ===================== */\n\n    error InvalidArgs();\n\n    /* ==================== VIEW METHODS ==================== */\n\n    /**\n     * @notice View function to check if position is liquidatable\n     **/\n    function isLiquidatablePosition(address asset, address owner) external view returns (bool);\n\n    /**\n     * @notice Returns information about a liquidating position\n     * @param asset The address of the main collateral token of a position\n     * @param owner The owner of the collateral\n     * @return collateralEDecimal The amount of collateral\n     * @return debtWithFeesE18 The amount of borrowed stablecoins with accumulated fee\n     **/\n    function getPositionInfo(\n        address asset,\n        address owner\n    ) external view returns (uint256 collateralEDecimal, uint256 debtWithFeesE18);\n\n    /**\n     * @notice Returns information about a liquidating position\n     * @param asset The address of the main collateral token of a position\n     * @param owner The owner of the collateral\n     * @return liquidationBlock The block number when the liquidation was triggered\n     **/\n    function getLiquidationBlock(address asset, address owner) external view returns (uint256);\n\n    /**\n     * @notice USD value of collateral of owner\n     **/\n    function getCollateralUsdValueE18(address asset, address owner) external view returns (uint256);\n\n    /* ==================== UI HELPERS ==================== */\n\n    /**\n     * @notice Returns Loan-To-Value in e18\n     **/\n    function getLTVE18(address asset, address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns Available to Borrow\n     * we have invariant: (collateralAmountEDecimal * collateralPriceE18 / 1e18) * initialCollateralRatioE18 <= debtE18\n     * Has similar logic like in _ensurePositionCollateralization\n     **/\n    function getAvailableToBorrowE18(address asset, address owner) external view returns (uint256);\n\n    /**\n     * @notice Returns Available to Withdraw\n     * Has similar invariant like in getAvailableToBorrowE18\n     **/\n    function getAvailableToWithdrawE18(address asset, address owner) external view returns (uint256);\n\n    /**\n     * @notice Calculate liquidation price\n     * @dev can be used inside of _isLiquidatablePosition\n     **/\n    function liquidationPriceE18(address asset, address owner) external view returns (uint256);\n\n    function liquidationPriceByAmount(\n        address asset,\n        address owner,\n        uint256 additionalCollateralAmount,\n        uint256 additionalStablecoinAmount\n    ) external view returns (uint256);\n\n    /**\n     * @notice View function to show utilization ratio\n     * the same function can be used inside of _isLiquidatablePosition\n     **/\n    function utilizationRatioE18(address asset, address owner) external view returns (uint256);\n}"
    },
    "contracts/interfaces/ISuManagerLiquidation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title ISuManagerLiquidation\n * @notice Abstract contract that should be in SuManager.\n * Here we have triggerLiquidation, that trigger bot should call after finding liquidatable position\n **/\ninterface ISuManagerLiquidation {\n    /* ===================== ERRORS ===================== */\n\n    error PositionIsSafe();\n    error LiquidationIsTriggered();\n\n    /* ===================== EVENTS ===================== */\n    /**\n     * @notice Event triggered when triggerLiquidation() is called\n     **/\n    event LiquidationTriggered(address asset, uint256 debtAmount);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    /**\n     * @notice Marks a position as to be liquidated\n     * @dev\n     * Emits LiquidationTriggered event.\n     * Sets the current block as liquidationBlock for the position.\n     * Can be triggered only once for the position.\n     * Add order for liquidated collateral to sell it by stablecoin from whitelist\n     * @param asset The address of the main collateral token of a position\n     * @param owner The owner of a position\n     **/\n    function triggerLiquidation(address asset, address owner) external;\n}"
    },
    "contracts/interfaces/ISuManagerParameters.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuManagerParameters {\n    /* ====================== VARS ====================== */\n    /**\n     * @notice When ratio (debt / usdValue) goes below it user can't withdraw or borrow.\n     * Should be >= liquidationRatioE18. 1e18 = 100% ratio. Should be less than 1e18.\n     * Is used to calculate available to withdraw and borrow.\n     * For example, user can borrow <= usdValue * initialCollateralRatio\n     **/\n    function initialCollateralRatioE18 (address asset) external view returns ( uint256 );\n\n    /**\n     * @notice Ratio when cdp can be liquidated.\n     * 1e18 = 100% ratio. Should be less than 1e18.\n     * Is used in isLiquidatablePosition(). It's true when debt / usdValue >= liquidationRatio\n     **/\n    function liquidationRatioE18 (address asset) external view returns ( uint256 );\n\n    /**\n     * @notice The minimum value of collateral in USD which allowed to be left after partial closure\n     **/\n    function minCollateralInUsdE18 ( ) external view returns ( uint256 );\n\n    /* ===================== ERRORS ===================== */\n    error BadLiquidationRatioValue();\n    error BadInitialCollateralRatioValue();\n\n    /* ==================== METHODS ==================== */\n    function setCollateral (\n        address asset,\n        uint256 stabilityFeeValueE18,\n        uint256 initialCollateralRatioValueE18,\n        uint256 liquidationRatioValueE18,\n        uint256 stablecoinLimitE18,\n        uint256 minCollateralInUsdValueE18\n    ) external;\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets the initial collateral ratio\n     * @param asset The address of the main collateral token\n     * @param newValueE18 The collateralization ratio (1e18 = 100%)\n     **/\n    function setInitialCollateralRatioE18 ( address asset, uint256 newValueE18 ) external;\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets the liquidation ratio\n     * @param asset The address of the main collateral token\n     * @param newValueE18 The liquidation ratio (1e18 = 100%).\n     **/\n    function setLiquidationRatioE18 ( address asset, uint256 newValueE18 ) external;\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets a minimum value of collateral in USD which allowed to be left after partial closure\n     * @param newValueE18 The minimum value of collateral in USD\n     */\n    function setMinCollateralInUsdE18 ( uint256 newValueE18 ) external;\n}\n"
    },
    "contracts/interfaces/ISuPausable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuPausable {\n    /* ===================== EVENTS ===================== */\n    /**\n     * @dev Emitted when the pause is triggered by `account` for the \"collateral\".\n     **/\n    event PausedCollateral(address account, address collateral);\n\n    /**\n     * @dev Emitted when the pause is triggered by `account` for the \"_contract\".\n     **/\n    event PausedContract(address account, address _contract);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account` for the \"collateral\".\n     **/\n    event UnpausedCollateral(address account, address collateral);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account` for the \"_contract\".\n     **/\n    event UnpausedContract(address account, address _contract);\n\n    /* ===================== ERRORS ===================== */\n    error AlreadyPaused();\n    error NotPaused();\n\n    /* ==================== MUTABLE METHODS ==================== */\n    /**\n     * @dev Triggers stopped state for the \"collateral\".\n     **/\n    function pauseCollateral(address collateral) external;\n\n    /**\n     * @dev Triggers stopped state for all \"collaterals\".\n     **/\n    function batchPauseCollateral(address[] calldata collaterals) external;\n\n    /**\n     * @dev Triggers stopped state for the \"_contract\".\n     **/\n    function pauseContract(address _contract) external;\n\n    /**\n     * @dev Triggers stopped state for the protocol.\n     **/\n    function pauseAll() external;\n\n    /**\n     * @dev Returns \"collateral\" to normal state.\n     **/\n    function unpauseCollateral(address collateral) external;\n\n    /**\n     * @dev Returns all \"collaterals\" to normal state.\n     **/\n    function batchUnpauseCollateral(address[] calldata collaterals) external;\n\n    /**\n     * @dev Returns \"_contract\" to normal state.\n     **/\n    function unpauseContract(address _contract) external;\n\n    /**\n     * @dev Returns protocol to normal state. All previous stopped collaterals and contracts are in the same state.\n     **/\n    function unpauseAll() external;\n\n    /* ==================== VIEW METHODS ==================== */\n    /**\n     * @dev Returns true if the contract for the \"collateral\" is paused, and false otherwise.\n     **/\n    function isPaused(address collateral) external view returns (bool);\n}"
    },
    "contracts/interfaces/ISuVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../lending/SuVaultParameters.sol\";\nimport \"../interfaces/ISuVaultParameters.sol\";\nimport \"../reward/RewardChefV2.sol\";\n\ninterface ISuVault is ISuVaultParameters {\n    /* ===================== EVENTS ===================== */\n    /**\n     * @notice Event triggered when user destroys cdp\n     **/\n    event PositionLiquidated(\n        address asset, address owner, address repayer, uint256 assetAmountEDecimal, uint256 repaymentE18\n    );\n\n    /**\n     * @notice Event triggered when user liquidate some part of cdp (debt > 0)\n     **/\n    event PositionLiquidatedPartial(\n        address asset, address owner, address repayer, uint256 assetAmountEDecimal, uint256 repaymentE18\n    );\n\n    /**\n     * @notice Event triggered when user call repay() function\n     **/\n    event PositionRepaid(address repayer, uint256 repaymentE18, uint256 excessAndFeeE18);\n\n    /**\n     * @notice Event triggered when user didnt withdraw collateral before price goes down\n     **/\n    event LiquidationTriggered(address indexed asset, address indexed owner);\n\n    /* ===================== ERRORS ===================== */\n    error LiquidationIsTriggered();\n    error Restricted();\n    error WithdrawExceeded();\n    error WrongDebt();\n    error WrongTotalDebt();\n    error UselessTransaction();\n    error AssetDebtLimit();\n\n    /* ====================== VARS ====================== */\n    /**\n     * @notice how much collateral the users staked == collaterals[asset][user], i.e deposits\n     * EDecimal means that this value in asset denomination, i.e. x{human readable value} * 10^{erc20.decimals()}\n     **/\n    function collateralsEDecimal (address asset, address user) external view returns ( uint256 );\n\n    /**\n     * @notice stablecoin amount\n     **/\n    function debtsE18 (address asset, address user) external view returns ( uint256 );\n\n    /**\n     * @notice stablecoin amount + fee accumulated before lastUpdate == debtWithFeesE18[asset][user]\n     **/\n    function debtWithFeesE18 (address asset, address user) external view returns ( uint256 );\n\n    /**\n     * @notice the last time, when every fee before lastUpdates are calculated in the debt.\n     * All data such as fees are from lastUpdate only\n     **/\n    function lastUpdate (address asset, address user) external view returns ( uint256 );\n\n    /**\n     * @notice asset => user => block number\n     **/\n    function liquidationBlock (address asset, address user) external view returns (uint256);\n\n    /**\n     * @notice current interest that user pay for stabilityFee[asset][user]\n     **/\n    function stabilityFeeE18 (address asset, address user) external view returns ( uint256 );\n\n    /**\n     * @notice Stats, how much stablecoins were borrowed against particular asset == tokenDebtsE18[asset]\n     **/\n    function tokenDebtsE18 (address asset) external view returns ( uint256 );\n\n    /**\n     * @notice tokenDebtsE18[asset] + accumulated fee in all CDPs in this asset\n     **/\n    function tokenDebtsWithFeesE18 (address asset) external view returns ( uint256 );\n\n    /* ==================== MUTABLE METHODS ==================== */\n    /**\n     * @notice borrow usdPRO using selected asset.\n     * user expected previously to deposit collateral and then being able to take stablecoin\n     * user can't create single position with multiple collaterals?\n     **/\n    function borrow ( address asset, address user, uint256 amountE18, uint256 lockupPeriodSeconds ) external;\n\n    /**\n     * @notice collateral deposit\n     **/\n    function deposit ( address asset, address user, uint256 amountEDecimal ) external;\n\n    /**\n     * @notice only destroy debt info\n     * @dev onlyVaultAccess, exit -> _repay -> destroy if debt == 0\n     **/\n    function destroy ( address asset, address user ) external;\n\n    /**\n     * @notice withdraw in case of some protocol errors, users can always get back their tokens\n     **/\n    function emergencyWithdraw ( address asset, address user, uint256 amountEDecimal ) external;\n\n    /**\n     * @notice liquidate user position, just cut debt and withdraw user collateral without asking StablePro\n     **/\n    function liquidate(\n        address asset,\n        address owner,\n        address recipient,\n        uint256 assetAmountEDecimal,\n        uint256 stablecoinAmountE18\n    ) external;\n\n    /**\n     * @notice set new RewardChef contract address\n     **/\n    function setRewardChef(address rewardChef) external;\n\n    /**\n     * @notice Marks a position as to be liquidated\n     * @param asset The address of the main collateral token of a position\n     * @param positionOwner The owner of a position\n     * @dev Sets the current block as liquidationBlock for the position. Can be triggered only once for the position.\n     **/\n    function triggerLiquidation(address asset, address positionOwner) external;\n\n    /**\n     * @notice Update all main state vars\n     * position is not allowed to be modified during liquidation, because when it's launched -\n     * liquidators want to be sure they can participate\n     * @dev is called, when user borrows more\n     **/\n    function update ( address asset, address user ) external;\n\n    /**\n     * @notice collateral withdraw\n     **/\n    function withdraw ( address asset, address user, address recipient, uint256 amountEDecimal ) external;\n\n    /**\n     * @notice Burns a debt repayment and transfers fees to the foundation.\n     * @param repayer The person who repaies by debt and transfers stablecoins to the foundation\n     * @param stablecoinsToRepaymentE18 The amount of stablecoins which will be burned as a debt repayment\n     * @param stablecoinsToFoundationE18 The amount of stablecoins which will be transfered to the foundation(e.g fees)\n     **/\n    function payFeeAndBurn(\n        address repayer,\n        uint256 stablecoinsToRepaymentE18,\n        uint256 stablecoinsToFoundationE18\n    ) external;\n\n    /* ==================== VIEW METHODS ==================== */\n\n    /**\n     * @notice fee is increased with time. Any call of vault.update would calc fee in debt and restart fee timer\n     **/\n    function calculateFeeE18 ( address asset, address user, uint256 amountE18 ) external view returns ( uint256 );\n\n    /**\n     * @notice total dept is calculated as current debt with added calculated fee, don't use it in practice\n     **/\n    function getTotalDebtE18 ( address asset, address user ) external view returns ( uint256 );\n}\n"
    },
    "contracts/interfaces/ISuVaultParameters.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title SuVaultParameters\n * @notice SuVaultParameters is Singleton for Access Control, like configuration contract.\n **/\ninterface ISuVaultParameters {\n    /* ====================== VARS ====================== */\n    /**\n     * @notice Stability fee that is used in calculateFeeE18 to see how much user debt increased.\n     * It can be different for each collateral\n     **/\n    function protocolStabilityFeeE18 (address asset) external view returns ( uint256 );\n\n    /**\n     * @notice Limit for each collateral-asset to manage risk profile\n     **/\n    function tokenDebtLimitE18 (address asset) external view returns ( uint256 );\n\n    /* ===================== ERRORS ===================== */\n    error ZeroAddress();\n\n    /* ==================== METHODS ==================== */\n    // TODO: creating new collaterals and modifying existing ones should be separate functions for security reason\n    /**\n     * @notice manager is allowed to add new collaterals and modify existing ones\n     **/\n    function setCollateral (address asset, uint256 stabilityFeeValueE18, uint256 stablecoinLimitE18) external;\n\n    /**\n     * @notice manager is allowed to change foundation that receive fees and etc\n     **/\n    function setFoundation ( address newFoundation ) external;\n\n    /**\n     * @notice set fee percentage (1e18 = 100%)\n     **/\n    function setStabilityFeeE18 ( address asset, uint256 newValue ) external;\n\n    /**\n     * @notice debt limit can be changed for any collateral along with liquidation and stability fees\n     **/\n    function setTokenDebtLimitE18 ( address asset, uint256 limit ) external;\n}\n"
    },
    "contracts/lending/SuCdpRegistry.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\nimport \"../interfaces/ISuVault.sol\";\r\nimport \"../interfaces/ISuCdpRegistry.sol\";\r\nimport \"./SuCollateralRegistry.sol\";\r\n\r\n/**\r\n * @title SuCdpRegistry\r\n * @notice Here we store protocol collaterals and use it in GraphQL\r\n * @dev See ISuCdpRegistry interface for full details.\r\n */\r\ncontract SuCdpRegistry is Initializable, SuCollateralRegistry, ISuCdpRegistry {\r\n    // mapping from collateral token to list of borrowers\r\n    mapping (address => address[]) private cdpList;\r\n\r\n    // mapping from collateral token to borrower to the cdpList index\r\n    mapping (address => mapping (address => uint256)) private cdpIndex;\r\n\r\n    ISuVault public vault;\r\n\r\n    function initialize(address _authControl, address _vault) public initializer {\r\n        if (_vault == address(0)) revert ZeroAddress();\r\n        vault = ISuVault(_vault);\r\n\r\n        __suCollateralRegistryInit(_authControl);\r\n    }\r\n\r\n    // anyone can create checkpoint?\r\n    function checkpoint(address asset, address owner) public {\r\n        if (asset == address(0) || owner == address(0)) revert ZeroAddress();\r\n\r\n        bool listed = isListed(asset, owner);\r\n        bool alive = isAlive(asset, owner);\r\n\r\n        if (alive && !listed) {\r\n            _addCdp(asset, owner);\r\n        } else if (listed && !alive) {\r\n            _removeCdp(asset, owner);\r\n        }\r\n    }\r\n\r\n    function _removeCdp(address asset, address owner) internal {\r\n        // take the index by collateral and borrower\r\n        uint256 id = cdpIndex[asset][owner];\r\n\r\n        // then delete this index\r\n        delete cdpIndex[asset][owner];\r\n\r\n        // if the index is not the last one\r\n        uint256 lastId = cdpList[asset].length - 1;\r\n\r\n        // swap the last element with the element to be deleted\r\n        if (id != lastId) {\r\n            address lastOwner = cdpList[asset][lastId];\r\n            cdpList[asset][id] = lastOwner;\r\n            cdpIndex[asset][lastOwner] = id;\r\n        }\r\n\r\n        // delete the last element\r\n        cdpList[asset].pop();\r\n\r\n        // can we optimize this remove function by changing the structure?\r\n\r\n        emit Removed(asset, owner);\r\n    }\r\n\r\n    function _addCdp(address asset, address owner) internal {\r\n        // remember the index of the new element\r\n        cdpIndex[asset][owner] = cdpList[asset].length;\r\n\r\n        // add the new element to the end of the list\r\n        cdpList[asset].push(owner);\r\n\r\n        emit Added(asset, owner);\r\n    }\r\n\r\n    /* ==================== VIEW METHODS ==================== */\r\n\r\n    function isAlive(address asset, address owner) public view returns (bool) {\r\n        return vault.debtWithFeesE18(asset, owner) != 0;\r\n    }\r\n\r\n    function isListed(address asset, address owner) public view returns (bool) {\r\n        if (cdpList[asset].length == 0) { return false; }\r\n        return cdpIndex[asset][owner] != 0 || cdpList[asset][0] == owner;\r\n    }\r\n\r\n    function getCdpsByCollateral(address asset) external view returns (CDP[] memory cdps) {\r\n        address[] memory owners = cdpList[asset];\r\n        cdps = new CDP[](owners.length);\r\n        for (uint16 i = 0; i < owners.length; ++i) {\r\n            cdps[i] = CDP(asset, owners[i]);\r\n        }\r\n    }\r\n\r\n    function getCdpsByOwner(address owner) external view returns (CDP[] memory r) {\r\n        CDP[] memory cdps = new CDP[](collaterals.length);\r\n        uint16 actualCdpsCount;\r\n\r\n        for (uint16 i = 0; i < collaterals.length; ++i) {\r\n            if (isListed(collaterals[i], owner)) {\r\n                cdps[actualCdpsCount++] = CDP(collaterals[i], owner);\r\n            }\r\n        }\r\n\r\n        r = new CDP[](actualCdpsCount);\r\n\r\n        for (uint16 i = 0; i < actualCdpsCount; ++i) {\r\n            r[i] = cdps[i];\r\n        }\r\n    }\r\n\r\n    function getAllCdps() external view returns (CDP[] memory r) {\r\n        uint256 totalCdpCount = getCdpsCount();\r\n\r\n        uint256 cdpCount;\r\n\r\n        r = new CDP[](totalCdpCount);\r\n\r\n        for (uint16 i = 0; i < collaterals.length; i++) {\r\n            address[] memory owners = cdpList[collaterals[i]];\r\n            for (uint256 j = 0; j < owners.length; j++) {\r\n                r[cdpCount++] = CDP(collaterals[i], owners[j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCdpsCount() public view returns (uint256 totalCdpCount) {\r\n        totalCdpCount = 0;\r\n        for (uint16 i = 0; i < collaterals.length; ++i) {\r\n            totalCdpCount += cdpList[collaterals[i]].length;\r\n        }\r\n    }\r\n\r\n    function getCdpsCountForCollateral(address asset) public view returns (uint256) {\r\n        return cdpList[asset].length;\r\n    }\r\n}\r\n"
    },
    "contracts/lending/SuCollateralRegistry.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./SuVaultParameters.sol\";\r\nimport \"../interfaces/ISuCollateralRegistry.sol\";\r\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\r\n\r\n/**\r\n * @title SuCollateralRegistry\r\n * @dev See ISuCollateralRegistry interface for full details.\r\n */\r\nabstract contract SuCollateralRegistry is SuAuthenticated, ISuCollateralRegistry {\r\n    mapping(address => CollateralRegistryInfo) public collateralInfo;\r\n    address[] public collaterals;\r\n\r\n    function __suCollateralRegistryInit(address _authControl) internal {\r\n        __suAuthenticatedInit(_authControl);\r\n    }\r\n\r\n    function addCollateral(address asset) public onlyDAO {\r\n        if (asset == address(0)) revert ZeroAddress();\r\n\r\n        if (isCollateral(asset) || collateralInfo[asset].isDisabled) revert AlreadyExist();\r\n\r\n        collateralInfo[asset] = CollateralRegistryInfo({ index: collaterals.length, isDisabled: false });\r\n        collaterals.push(asset);\r\n\r\n        emit CollateralAdded(asset);\r\n    }\r\n\r\n    function disableCollateral(address asset) public onlyDAO {\r\n        if (collateralInfo[asset].isDisabled) revert AlreadyDisabled();\r\n        if (!isCollateral(asset)) revert NotExist();\r\n\r\n        collateralInfo[asset].isDisabled = true;\r\n\r\n        emit CollateralDisabled(asset);\r\n    }\r\n\r\n    function enableCollateral(address asset) public onlyDAO {\r\n        if (!collateralInfo[asset].isDisabled) {\r\n            if (isCollateral(asset)) {\r\n                revert AlreadyEnabled();\r\n            } else {\r\n                revert NotExist();\r\n            }\r\n        }\r\n\r\n        collateralInfo[asset].isDisabled = false;\r\n\r\n        emit CollateralEnabled(asset);\r\n    }\r\n\r\n    function isCollateral(address asset) public view returns(bool) {\r\n        if (collaterals.length == 0) { return false; }\r\n\r\n        return !collateralInfo[asset].isDisabled && (collateralInfo[asset].index != 0 || collaterals[0] == asset);\r\n    }\r\n}\r\n"
    },
    "contracts/lending/SuManager.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/ISuVault.sol\";\nimport \"../interfaces/ISuCdpRegistry.sol\";\nimport \"../interfaces/ISuManager.sol\";\nimport \"./SuManagerParameters.sol\";\nimport \"./SuManagerHelpers.sol\";\nimport \"./SuManagerLiquidation.sol\";\nimport \"../emergency/SuPausableAbstract.sol\";\n\n/**\n * @title SuManager\n * @notice Main contract to give ability to user to join position or exit from it.\n * @dev See ISuManager interface and all SuManager** contracts for full details.\n */\ncontract SuManager is\nReentrancyGuardUpgradeable,\nSuManagerParameters,\nSuManagerLiquidation,\nSuManagerHelpers,\nSuPausableAbstract,\nISuManager {\n    ISuVault public vault;\n    ISuCdpRegistry public cdpRegistry;\n\n    modifier checkpoint(address asset, address owner) {\n        _;\n        cdpRegistry.checkpoint(asset, owner);\n    }\n\n    function initialize(\n        address _vault,\n        address _suOracle,\n        address _cdpRegistry,\n        address _suLiquidationMiddleware,\n        address _stablePro,\n        address _foundation,\n        address _suPausable\n    ) public initializer {\n        if (_cdpRegistry == address(0) || _suOracle == address(0)) revert InvalidArgs();\n\n        __ReentrancyGuard_init();\n        __suManagerParametersInit(_vault);\n        __suManagerLiquidationInit(address(this), _vault, _suLiquidationMiddleware, _stablePro, _foundation);\n        __suManagerHelpersInit(address(this), _vault, _suOracle);\n        __suPausableAbstractInit(_suPausable);\n\n        vault = ISuVault(_vault);\n        cdpRegistry = ISuCdpRegistry(_cdpRegistry);\n    }\n\n    // wrapper ether only, no native\n    receive() external payable {\n        revert Restricted();\n    }\n\n    function join(address asset, uint256 assetAmountEDecimal, uint256 stablecoinAmountE18, uint256 lockupPeriodSeconds)\n    public nonReentrant checkpoint(asset, msg.sender) whenNotPaused(asset) {\n        if (stablecoinAmountE18 == 0 && assetAmountEDecimal == 0) revert UselessTransaction();\n        if (IERC20Metadata(asset).decimals() > 18) revert UnsupportedDecimals();\n\n        if (stablecoinAmountE18 == 0) {\n            vault.deposit(asset, msg.sender, assetAmountEDecimal);\n        } else {\n            if (assetAmountEDecimal != 0) {\n                vault.deposit(asset, msg.sender, assetAmountEDecimal);\n            }\n\n            vault.borrow(asset, msg.sender, stablecoinAmountE18, lockupPeriodSeconds);\n\n            _ensurePositionCollateralization(asset, msg.sender);\n        }\n\n        // not allowed to left some dust after partial closure the position\n        _ensureMinCollateralThreshold(asset, msg.sender);\n\n        emit Join(asset, msg.sender, assetAmountEDecimal, stablecoinAmountE18);\n    }\n\n    function exit(address asset, uint256 assetAmountEDecimal, uint256 stablecoinAmountE18)\n    public nonReentrant checkpoint(asset, msg.sender) whenNotPaused(asset) {\n        if (vault.liquidationBlock(asset, msg.sender) > 0) revert LiquidationIsTriggered();\n\n        // not to pay more stablecoin than debt\n        uint256 debtWithFeesE18 = vault.debtWithFeesE18(asset, msg.sender);\n        if (stablecoinAmountE18 > debtWithFeesE18) { stablecoinAmountE18 = debtWithFeesE18; }\n\n        // calculate and charge fee\n        uint256 feeE18 = vault.calculateFeeE18(asset, msg.sender, stablecoinAmountE18);\n\n        vault.liquidate(asset, msg.sender, msg.sender, assetAmountEDecimal, stablecoinAmountE18);\n\n        // not allowed to left some dust after partial closure the position\n        _ensureMinCollateralThreshold(asset, msg.sender);\n\n        vault.payFeeAndBurn(msg.sender, stablecoinAmountE18, feeE18);\n\n        if (vault.debtWithFeesE18(asset, msg.sender) > 0) {\n            // TODO: check that withdrawals lead to update\n            vault.update(asset, msg.sender);\n\n            // dont need to check this after full repayment\n            _ensurePositionCollateralization(asset, msg.sender);\n        }\n\n        emit Exit(asset, msg.sender, assetAmountEDecimal, stablecoinAmountE18);\n    }\n\n    // after partial repayment should be made sure its still collateralized enough\n    function _ensurePositionCollateralization(address asset, address owner) internal view {\n        // calculate value in usd from collateral position\n        uint256 usdValueE18 = getCollateralUsdValueE18(asset, owner);\n\n        // multiply value in usd to the collateral ratio, then divide by 1e18\n        uint256 usdLimitE18 = usdValueE18 * initialCollateralRatioE18[asset] / 1e18;\n\n        // make sure calculated allowed limit is higher than the actual debt\n        if (vault.getTotalDebtE18(asset, owner) > usdLimitE18) revert UnderCollateralized();\n    }\n\n    // after partial closure should be made sure it is not left too little amount of collateral\n    function _ensureMinCollateralThreshold(address asset, address owner) internal view {\n        uint256 usdValueE18 = getCollateralUsdValueE18(asset, owner)    ;\n\n        if (usdValueE18 > 0 && usdValueE18 <= minCollateralInUsdE18) revert SmallCollateral();\n    }\n}\n"
    },
    "contracts/lending/SuManagerHelpers.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/ISuManagerHelpers.sol\";\nimport \"../interfaces/ISuVault.sol\";\nimport \"../interfaces/ISuManager.sol\";\nimport \"../periphery/contracts/interfaces/oracle/ISuOracle.sol\";\n\n/**\n * @title SuManagerHelpers\n * @dev See ISuManagerHelpers interface for full details.\n */\nabstract contract SuManagerHelpers is ISuManagerHelpers {\n    ISuVault private _VAULT;\n    ISuManager private _MANAGER;\n    ISuOracle private _ORACLE;\n\n    function __suManagerHelpersInit(address _suManager, address _suVault, address _suOracle) internal {\n        if (_suOracle == address(0)) revert InvalidArgs();\n\n        _MANAGER = ISuManager(_suManager);\n        _VAULT = ISuVault(_suVault);\n        _ORACLE = ISuOracle(_suOracle);\n    }\n\n    /* ==================== VIEW METHODS ==================== */\n\n    function isLiquidatablePosition(address asset, address owner) public view returns (bool) {\n        uint256 usdValueE18 = getCollateralUsdValueE18(asset, owner);\n        if (usdValueE18 == 0) return false;\n\n        // calculate current debt to be returned\n        uint256 debtE18 = _VAULT.getTotalDebtE18(asset, owner);\n\n        if (debtE18 == 0) return false;\n        // make sure its not under collaterazied\n        return debtE18 * 1e18 / usdValueE18 >= _MANAGER.liquidationRatioE18(asset);\n    }\n\n    function getPositionInfo(address asset, address owner) external view returns (\n        uint256 collateralEDecimal,\n        uint256 debtWithFeesE18\n    ) {\n        collateralEDecimal = _VAULT.collateralsEDecimal(asset, owner);\n        debtWithFeesE18 = _VAULT.debtWithFeesE18(asset, owner);\n    }\n\n    function getLiquidationBlock(address asset, address owner) external view returns (uint256) {\n        return _VAULT.liquidationBlock(asset, owner);\n    }\n\n    function getCollateralUsdValueE18(address asset, address owner) public view returns (uint256) {\n        uint256 assetAmountEDecimal = _VAULT.collateralsEDecimal(asset, owner);\n\n        return _ORACLE.getFiatPrice1e18(asset) * assetAmountEDecimal / 1e18;\n    }\n\n    /* ====================== UI HELPERS ====================== */\n\n    function getLTVE18(address asset, address owner) external view returns (uint256) {\n        uint256 usdValueE18 = getCollateralUsdValueE18(asset, owner);\n        if (usdValueE18 == 0) return 0;\n\n        uint256 debtWithFeesE18 = _VAULT.debtWithFeesE18(asset, owner);\n\n        return debtWithFeesE18 * 1e18 / usdValueE18;\n    }\n\n    function getAvailableToBorrowE18(address asset, address owner) external view returns (uint256) {\n        uint256 usdValueE18 = getCollateralUsdValueE18(asset, owner);\n        uint256 usdLimitE18 = usdValueE18 * _MANAGER.initialCollateralRatioE18(asset) / 1e18;\n\n        uint256 totalDebtWithFeeE18 = _VAULT.getTotalDebtE18(asset, owner);\n\n        if (usdLimitE18 <= totalDebtWithFeeE18) return 0;\n\n        return usdLimitE18 - totalDebtWithFeeE18;\n    }\n\n    function getAvailableToWithdrawE18(address asset, address owner) external view returns (uint256) {\n        uint256 collateralAmountEDecimal = _VAULT.collateralsEDecimal(asset, owner);\n        uint256 collateralPriceE18 = _ORACLE.getFiatPrice1e18(asset);\n        if (collateralPriceE18 == 0) return 0;\n        uint256 debtWithFeesE18 = _VAULT.debtWithFeesE18(asset, owner);\n\n        uint256 minCollateralAmountEDecimal = debtWithFeesE18 * (10 ** IERC20Metadata(asset).decimals()) * 1e18 /\n            (collateralPriceE18 * _MANAGER.initialCollateralRatioE18(asset));\n\n        return collateralAmountEDecimal - minCollateralAmountEDecimal;\n    }\n\n    function liquidationPriceE18(address asset, address owner) external view returns (uint256) {\n        uint256 debtE18 = _VAULT.getTotalDebtE18(asset, owner);\n        if (debtE18 == 0) return type(uint256).max;\n\n        uint256 collateralLiqPriceE18 = debtE18 * 1e18 / _MANAGER.liquidationRatioE18(asset);\n\n        return collateralLiqPriceE18 * 1e18 / _VAULT.collateralsEDecimal(asset, owner) /\n            10 ** (18 - IERC20Metadata(asset).decimals());\n    }\n\n    function liquidationPriceByAmount(\n        address asset,\n        address owner,\n        uint256 additionalCollateralAmount,\n        uint256 additionalStablecoinAmount\n    ) external view returns (uint256) {\n        uint256 debtE18 = _VAULT.getTotalDebtE18(asset, owner) + additionalStablecoinAmount;\n        if (debtE18 == 0) return type(uint256).max;\n\n        uint256 collateralLiqPriceE18 = debtE18 * 1e18 / _MANAGER.liquidationRatioE18(asset);\n        uint256 collaterals = _VAULT.collateralsEDecimal(asset, owner) + additionalCollateralAmount;\n\n        return collateralLiqPriceE18 * 1e18 / collaterals / 10 ** (18 - IERC20Metadata(asset).decimals());\n    }\n\n    function utilizationRatioE18(address asset, address owner) public view returns (uint256) {\n        uint256 debtE18 = _VAULT.getTotalDebtE18(asset, owner);\n        if (debtE18 == 0) return 0;\n\n        uint256 usdValueE18 = getCollateralUsdValueE18(asset, owner);\n\n        return debtE18 * 1e18 / usdValueE18;\n    }\n}"
    },
    "contracts/lending/SuManagerLiquidation.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport \"../interfaces/ISuManagerLiquidation.sol\";\nimport \"../interfaces/ISuVault.sol\";\nimport \"../interfaces/ISuManager.sol\";\nimport \"../interfaces/ISuLiquidationMiddleware.sol\";\n\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\n\n/**\n * @title SuManagerLiquidation\n * @dev See ISuManagerLiquidation interface for full details.\n */\nabstract contract SuManagerLiquidation is Initializable, SuAuthenticated, ISuManagerLiquidation {\n    ISuVault private _vault;\n    ISuManager private _manager;\n    ISuLiquidationMiddleware private _liquidationMiddleware;\n    address private _stablePro;\n    address public foundation;\n\n    function __suManagerLiquidationInit(\n        address _suManager,\n        address _suVault,\n        address _suLiquidationMiddleware,\n        address _suStablePro,\n        address _foundation\n    ) internal onlyInitializing {\n        _manager = ISuManager(_suManager);\n        _vault = ISuVault(_suVault);\n        _liquidationMiddleware = ISuLiquidationMiddleware(_suLiquidationMiddleware);\n        _stablePro = _suStablePro;\n        foundation = _foundation;\n    }\n\n    function triggerLiquidation(address asset, address owner) external {\n        if (_vault.liquidationBlock(asset, owner) > 0) revert LiquidationIsTriggered();\n        if (!_manager.isLiquidatablePosition(asset, owner)) revert PositionIsSafe();\n\n        // summarize debt with accumulated fees\n        _vault.update(asset, owner);\n\n        _vault.triggerLiquidation(asset, owner);\n\n        uint256 collateralsEDecimal = _vault.collateralsEDecimal(asset, owner);\n        uint256 debtsE18 = _vault.debtsE18(asset, owner);\n        uint256 debtWithFeesE18 = _vault.debtWithFeesE18(asset, owner);\n\n        // we need to cut all debt (with fees) of owner and send collateral to _liquidationMiddleware\n        _vault.liquidate(\n            asset,\n            owner,\n            address(this),\n            collateralsEDecimal,\n            debtWithFeesE18\n        );\n\n        // TODO: make percent depending on collateralsEDecimal\n        uint256 liquidationReward = collateralsEDecimal * 5 / 1000; // 0.5%\n        uint256 sellAmount = collateralsEDecimal - liquidationReward;\n\n        TransferHelper.safeTransfer(asset, msg.sender, liquidationReward);\n        TransferHelper.safeTransfer(asset, address(_liquidationMiddleware), sellAmount);\n\n        _liquidationMiddleware.borrowCollateralToSell(asset, sellAmount, debtsE18);\n\n        emit LiquidationTriggered(asset, debtsE18);\n    }\n}"
    },
    "contracts/lending/SuManagerParameters.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"./SuVaultParameters.sol\";\nimport \"../interfaces/ISuManagerParameters.sol\";\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\n\n/**\n * @title SuManagerParameters\n * @dev See ISuManagerParameters interface for full details.\n */\nabstract contract SuManagerParameters is SuAuthenticated, ISuManagerParameters {\n    mapping(address => uint256) public initialCollateralRatioE18;\n    mapping(address => uint256) public liquidationRatioE18;\n    uint256 public minCollateralInUsdE18;\n\n    SuVaultParameters public vaultParameters;\n\n    function __suManagerParametersInit(address _vaultParameters) internal onlyInitializing {\n        __suAuthenticatedInit(address(SuAuthenticated(_vaultParameters).ACCESS_CONTROL_SINGLETON()));\n\n        vaultParameters = SuVaultParameters(_vaultParameters);\n        minCollateralInUsdE18 = 5 * 1e18;\n    }\n\n    // TODO: add two types of functions:\n    //  - fundamental for DAO that set collateral and limits for parameters\n    //  - fine tuning for admin that is able to change some parameters within limits\n    function setCollateral(\n        address asset,\n        uint256 stabilityFeeValueE18,\n        uint256 initialCollateralRatioValueE18,\n        uint256 liquidationRatioValueE18,\n        uint256 stablecoinLimitE18,\n        uint256 minCollateralInUsdValueE18\n    ) external onlyDAO {\n        vaultParameters.setCollateral(asset, stabilityFeeValueE18, stablecoinLimitE18);\n        setInitialCollateralRatioE18(asset, initialCollateralRatioValueE18);\n        setLiquidationRatioE18(asset, liquidationRatioValueE18);\n        setMinCollateralInUsdE18(minCollateralInUsdValueE18);\n    }\n\n    function setInitialCollateralRatioE18(address asset, uint256 newValueE18) public onlyDAO {\n        if (newValueE18 == 0 || newValueE18 > 1e18) revert BadInitialCollateralRatioValue();\n        initialCollateralRatioE18[asset] = newValueE18;\n    }\n\n    function setLiquidationRatioE18(address asset, uint256 newValueE18) public onlyDAO {\n        if (newValueE18 == 0 || newValueE18 < initialCollateralRatioE18[asset]) revert BadLiquidationRatioValue();\n        liquidationRatioE18[asset] = newValueE18;\n    }\n\n    function setMinCollateralInUsdE18(uint256 newValueE18) public onlyDAO {\n        minCollateralInUsdE18 = newValueE18;\n    }\n}\n"
    },
    "contracts/lending/SuVault.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./SuVaultParameters.sol\";\nimport \"../StablePro.sol\";\nimport \"../reward/RewardChefV2.sol\";\nimport \"../interfaces/ISuVault.sol\";\nimport \"../emergency/SuPausableAbstract.sol\";\n\n/**\n * @title SuVault\n * @notice Users don't have direct access to it, only through SuManager\n * @dev See ISuVault interface and SuVaultParameters contract for full details.\n */\ncontract SuVault is SuVaultParameters, SuPausableAbstract, ISuVault  {\n    StablePro public STABLE_PRO;\n\n    mapping(address => mapping(address => uint256)) public collateralsEDecimal;\n    mapping(address => mapping(address => uint256)) public debtWithFeesE18;\n    mapping(address => mapping(address => uint256)) public debtsE18;\n    mapping(address => uint256) public tokenDebtsWithFeesE18;\n    mapping(address => uint256) public tokenDebtsE18;\n    mapping(address => mapping(address => uint256)) public stabilityFeeE18;\n    mapping(address => mapping(address => uint256)) public lastUpdate;\n    mapping(address => mapping(address => uint256)) public liquidationBlock;\n\n    /**\n     * @notice check if liquidation process not started for asset of user\n     **/\n    modifier notLiquidating(address asset, address user) {\n        if (liquidationBlock[asset][user] > 0) revert LiquidationIsTriggered();\n        _;\n    }\n\n    RewardChefV2 public rewardChef;\n\n    /**\n     * @notice vault is initialize with parameters for auth (we are using OZ instead)\n     * and it accept address for wrapped eth, main stable coin, and probably governance token\n     **/\n    function initialize(\n        address _authControl,\n        address _stablePro,\n        address _foundation,\n        address _rewardChef,\n        address _suPausable\n    ) public initializer {\n        __suVaultParametersInit(_authControl, payable(this), _foundation);\n        __suPausableAbstractInit(_suPausable);\n\n        STABLE_PRO = StablePro(_stablePro);\n        rewardChef = RewardChefV2(_rewardChef);\n    }\n\n    /**\n     * @notice do not accept direct payments from users because they will be stuck on contract address\n     **/\n    receive() external payable {\n        revert Restricted();\n    }\n\n    function update(\n        address asset,\n        address user\n    ) public onlyVaultAccess notLiquidating(asset, user) whenNotPaused(asset) {\n        // probably should be checked if zero then skip\n        uint256 newDebtWithFeesE18 = getTotalDebtE18(asset, user);\n\n        tokenDebtsWithFeesE18[asset] = tokenDebtsWithFeesE18[asset] - debtWithFeesE18[asset][user] + newDebtWithFeesE18;\n        debtWithFeesE18[asset][user] = newDebtWithFeesE18;\n        stabilityFeeE18[asset][user] = protocolStabilityFeeE18[asset];\n        lastUpdate[asset][user] = block.timestamp;\n    }\n\n    // public?\n    function destroy(address asset, address user) public onlyVaultAccess whenNotPaused(asset) {\n        delete stabilityFeeE18[asset][user];\n        delete lastUpdate[asset][user];\n        delete liquidationBlock[asset][user];\n    }\n\n    function deposit(\n        address asset,\n        address user,\n        uint256 amountEDecimal\n    ) external onlyVaultAccess notLiquidating(asset, user) whenNotPaused(asset) {\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(asset), user, address(this), amountEDecimal);\n        collateralsEDecimal[asset][user] = collateralsEDecimal[asset][user] + amountEDecimal;\n    }\n\n    function withdraw(\n        address asset,\n        address user,\n        address recipient,\n        uint256 amountEDecimal\n    ) public onlyVaultAccess whenNotPaused(asset) {\n        if (amountEDecimal > collateralsEDecimal[asset][user]) revert WithdrawExceeded();\n        collateralsEDecimal[asset][user] = collateralsEDecimal[asset][user] - amountEDecimal;\n        if (recipient != address(0)) {\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(asset), recipient, amountEDecimal);\n        }\n    }\n\n    // TODO: what role should we have? Need whenNotPaused(asset)?\n    function emergencyWithdraw(\n        address asset,\n        address user,\n        uint256 amountEDecimal\n    ) external onlyVaultAccess whenNotPaused(asset) {\n        if (amountEDecimal > collateralsEDecimal[asset][user]) revert WithdrawExceeded();\n        collateralsEDecimal[asset][user] = collateralsEDecimal[asset][user] - amountEDecimal;\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(asset), user, amountEDecimal);\n\n        // solhint-disable-next-line no-empty-blocks\n        try rewardChef.resetAmount(asset, user) {} catch {}\n    }\n\n    function borrow(\n        address asset,\n        address user,\n        uint256 amountE18,\n        uint256 lockupPeriodSeconds\n    ) external onlyVaultAccess notLiquidating(asset, user) whenNotPaused(asset) {\n        update(asset, user);\n\n        debtsE18[asset][user] = debtsE18[asset][user] + amountE18;\n        debtWithFeesE18[asset][user] = debtWithFeesE18[asset][user] + amountE18;\n        tokenDebtsE18[asset] = tokenDebtsE18[asset] + amountE18;\n        tokenDebtsWithFeesE18[asset] = tokenDebtsWithFeesE18[asset] + amountE18;\n\n        if (tokenDebtsWithFeesE18[asset] > tokenDebtLimitE18[asset]) revert AssetDebtLimit();\n\n        STABLE_PRO.mint(user, amountE18);\n        rewardChef.increaseAmount(asset, user, amountE18, lockupPeriodSeconds);\n    }\n\n    function _cutDebt(address asset, address user, uint256 stablecoinAmountE18) internal onlyVaultAccess {\n        if (stablecoinAmountE18 > debtWithFeesE18[asset][user]) revert WrongDebt();\n        if (stablecoinAmountE18 > tokenDebtsWithFeesE18[asset]) revert WrongTotalDebt();\n\n        uint256 fee = stablecoinAmountE18 > debtsE18[asset][user] ? stablecoinAmountE18 - debtsE18[asset][user] : 0;\n\n        // current debt of user by given collateral\n        // is being decreased by chosen amount\n        debtWithFeesE18[asset][user] = debtWithFeesE18[asset][user] - stablecoinAmountE18;\n        // we don't need to count fee here\n        debtsE18[asset][user] = debtsE18[asset][user] + fee - stablecoinAmountE18;\n\n        // total debt by asset is being decreased too\n        // this value is used to limit total collateral allowed debt\n        tokenDebtsWithFeesE18[asset] = tokenDebtsWithFeesE18[asset] - stablecoinAmountE18;\n        tokenDebtsE18[asset] = tokenDebtsE18[asset] + fee - stablecoinAmountE18;\n        rewardChef.decreaseAmount(asset, user, stablecoinAmountE18 - fee);\n    }\n\n    function liquidate(\n        address asset,\n        address user,\n        address recipient,\n        uint256 assetAmountEDecimal,\n        uint256 stablecoinAmountE18\n    ) external onlyVaultAccess whenNotPaused(asset) {\n        if (assetAmountEDecimal == 0 && stablecoinAmountE18 == 0) revert UselessTransaction();\n\n        // reduce debt and don't repay, stablecoinAmount == 0 in case of withdraw\n        if (stablecoinAmountE18 != 0) {\n            _cutDebt(asset, user, stablecoinAmountE18);\n        }\n\n        // vault will transfer collateral to the user\n        if (assetAmountEDecimal != 0) {\n            withdraw(asset, user, recipient, assetAmountEDecimal);\n        }\n\n        // clean state\n        if (debtWithFeesE18[asset][user] == 0) {\n            destroy(asset, user);\n            emit PositionLiquidated(asset, user, recipient, assetAmountEDecimal, stablecoinAmountE18);\n        } else {\n            emit PositionLiquidatedPartial(asset, user, recipient, assetAmountEDecimal, stablecoinAmountE18);\n        }\n    }\n\n    function triggerLiquidation(\n        address asset,\n        address positionOwner\n    ) external onlyVaultAccess notLiquidating(asset, positionOwner) whenNotPaused(asset) {\n        emit LiquidationTriggered(asset, positionOwner);\n\n        liquidationBlock[asset][positionOwner] = block.number;\n    }\n\n    function getTotalDebtE18(address asset, address user) public view returns (uint256) {\n        uint256 debtWithFeeE18 = debtWithFeesE18[asset][user];\n        uint256 feeE18 = calculateFeeE18(asset, user, debtWithFeeE18);\n        // debtWithFee before lastUpdate + fee after lastUpdate\n        return debtWithFeeE18 + feeE18;\n    }\n\n    function calculateFeeE18(address asset, address user, uint256 amountE18) public view returns (uint256) {\n        uint256 sFeePercentE18 = stabilityFeeE18[asset][user];\n        uint256 timePast = block.timestamp - lastUpdate[asset][user];\n\n        return amountE18 * sFeePercentE18 * timePast / (365 days) / 1e18;\n    }\n\n    function payFeeAndBurn(\n        address repayer,\n        uint256 stablecoinsToRepaymentE18,\n        uint256 stablecoinsToFoundationE18\n    ) external onlyVaultAccess {\n        emit PositionRepaid(repayer, stablecoinsToRepaymentE18, stablecoinsToFoundationE18);\n\n        // the repayer transfers fees and excesses over the repayment\n        if (stablecoinsToFoundationE18 != 0) {\n            SafeERC20Upgradeable.safeTransferFrom(STABLE_PRO, repayer, foundation, stablecoinsToFoundationE18);\n        }\n\n        // we burn stablecoin from user\n        STABLE_PRO.burn(repayer, stablecoinsToRepaymentE18);\n    }\n\n    function setRewardChef(address _rewardChef) public onlyVaultAccess {\n        rewardChef = RewardChefV2(_rewardChef);\n    }\n}\n"
    },
    "contracts/lending/SuVaultParameters.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\nimport \"../interfaces/ISuVaultParameters.sol\";\r\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// TODO: merge with ManagerParameters\r\n/**\r\n * @title SuVaultParameters\r\n * @dev See ISuVaultParameters interface for full details.\r\n */\r\nabstract contract SuVaultParameters is SuAuthenticated, ISuVaultParameters {\r\n    mapping(address => uint256) public protocolStabilityFeeE18;\r\n    mapping(address => uint256) public tokenDebtLimitE18;\r\n    address public foundation;\r\n    address public vault;\r\n\r\n    // how can vault address be known at this moment?\r\n    // Precult based on CREATE spec\r\n    // can be created another function to set vault address once deployed?\r\n    // Yes, possibly with some logic change\r\n    function __suVaultParametersInit(\r\n        address _authControl,\r\n        address payable _vault,\r\n        address _foundation\r\n    )  internal onlyInitializing {\r\n        if (_vault == address(0) || _foundation == address(0)) revert ZeroAddress();\r\n\r\n        __suAuthenticatedInit(_authControl);\r\n        vault = _vault;\r\n        foundation = _foundation;\r\n    }\r\n\r\n    function setFoundation(address newFoundation) external onlyDAO {\r\n        if (newFoundation == address(0)) revert ZeroAddress();\r\n        foundation = newFoundation;\r\n    }\r\n\r\n    // is called by Manager\r\n    function setCollateral(\r\n        address asset,\r\n        uint256 stabilityFeeValueE18,\r\n        uint256 stablecoinLimitE18\r\n    ) external onlyVaultAccess {\r\n        // stability fee should be validated in range, what is stability fee should be described here?\r\n        setStabilityFeeE18(asset, stabilityFeeValueE18);\r\n        // why debt limit for collateral is necessary? to manage risks in case of collateral failure?\r\n        setTokenDebtLimitE18(asset, stablecoinLimitE18);\r\n    }\r\n\r\n    function setStabilityFeeE18(address asset, uint256 newValue) public onlyVaultAccess {\r\n        protocolStabilityFeeE18[asset] = newValue;\r\n    }\r\n\r\n    function setTokenDebtLimitE18(address asset, uint256 limit) public onlyVaultAccess {\r\n        tokenDebtLimitE18[asset] = limit;\r\n    }\r\n}\r\n"
    },
    "contracts/lib/ds-auth/lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "contracts/lib/ds-auth/src/auth.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(address(0))) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"
    },
    "contracts/lib/ds-note/lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "contracts/lib/ds-note/src/note.sol": {
      "content": "/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        _;\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n    }\n}\n"
    },
    "contracts/makerdao/core/BasicTokenAdapters.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// BasicTokenAdapters.sol -- Basic token adapters\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/v8/ICollateralJoin.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\ninterface DSTokenLike {\n    function mint(address,uint) external;\n    function burn(address,uint) external;\n}\n\ninterface SafeEngineLike {\n    function modifyCollateralBalance(bytes32,address,int) external;\n    function transferInternalCoins(address,address,uint) external;\n}\n\n/*\n    Here we provide *adapters* to connect the SafeEngine to arbitrary external\n    token implementations, creating a bounded context for the SafeEngine. The\n    adapters here are provided as working examples:\n\n      - `CollateralJoin`: For well behaved ERC20 tokens, with simple transfer\n                   semantics.\n\n      - `ETHJoin`: For native Ether.\n\n      - `CoinJoin`: For connecting internal Dai balances to an external\n                   `DSToken` implementation.\n\n      - `CollateralJoin3`: For a token that has a lower precision than 18 and\n                     doesn't have decimals field in place (like DGD)\n\n\n    In practice, adapter implementations will be varied and specific to\n    individual collateral types, accounting for different transfer\n    semantics and token standards.\n\n    Adapters need to implement two basic methods:\n\n      - `join`: enter collateral into the system\n      - `exit`: remove collateral from the system\n\n*/\n\ncontract CollateralJoin is ICollateralJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 1;\n        emit AddAuthorization(usr);\n    }\n    function removeAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 0;\n        emit RemoveAuthorization(usr);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin/not-authorized\");\n        _;\n    }\n\n    SafeEngineLike public safeEngine;\n    bytes32 public collateralType;\n    IERC20Metadata public collateral;      // Actual collateral token contract\n    uint    public decimals;        // How many decimals the collateral token has\n    uint    public contractEnabled; // Whether this adapter contract is enabled or not\n\n    // Events\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        safeEngine = SafeEngineLike(safeEngine_);\n        collateralType = collateralType_;\n        collateral = IERC20Metadata(collateral_);\n        decimals = collateral.decimals();\n        emit AddAuthorization(msg.sender);\n    }\n    function disableContract() external override isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    /**\n    * @notice Join collateral in the system\n    * @dev This function locks collateral in the adapter and creates a 'representation' of\n    *      the locked collateral inside the system. This adapter assumes that the collateral\n    *      has 18 decimals\n    * @param usr Account from which we transferFrom collateral and add it in the system\n    * @param wad Amount of collateral to transfer in the system (represented as a number with 18 decimals)\n    **/\n    function join(address usr, uint wad) external override {\n        require(contractEnabled == 1, \"CollateralJoin/not-contractEnabled\");\n        require(int(wad) >= 0, \"CollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"CollateralJoin/failed-transfer\");\n        emit Join(usr, wad);\n    }\n    /**\n    * @notice Exit collateral from the system\n    * @dev This function destroys the collateral representation from inside the system\n    *      and exits the collateral from this adapte. The adapter assumes that the collateral\n    *      has 18 decimals\n    * @param usr Account to which we transfer the collateral\n    * @param wad Amount of collateral to transfer to 'account' (represented as a number with 18 decimals)\n    **/\n    function exit(address usr, uint wad) external override {\n        require(wad <= 2 ** 255, \"CollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        require(collateral.transfer(usr, wad), \"CollateralJoin/failed-transfer\");\n        emit Exit(usr, wad);\n    }\n}\n\ncontract CoinJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 1;\n        emit AddAuthorization(usr);\n    }\n    function removeAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 0;\n        emit RemoveAuthorization(usr);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CoinJoin/not-authorized\");\n        _;\n    }\n\n    SafeEngineLike public safeEngine;\n    // Coin created by the system; this is the external, ERC-20 representation, not the internal 'coinBalance'\n    DSTokenLike public systemCoin;\n    // Whether this contract is enabled or not\n    uint public contractEnabled;\n\n    // Events\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n    event DisableContract();\n\n    constructor(address safeEngine_, address systemCoin_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        safeEngine = SafeEngineLike(safeEngine_);\n        systemCoin = DSTokenLike(systemCoin_);\n    }\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n    uint constant ONE = 10 ** 27;\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    /**\n    * @notice Join pegged-coins in the system\n    * @dev Exited coins have 18 decimals but inside the system they have 45 (rad) decimals.\n           When we join, the amount (wad) is multiplied by 10**27 (ray)\n    * @param usr Account that will receive the joined coins\n    * @param wad Amount of external coins to join (18 decimal number)\n    **/\n    function join(address usr, uint wad) external {\n        safeEngine.transferInternalCoins(address(this), usr, mul(ONE, wad));\n        systemCoin.burn(msg.sender, wad);\n        emit Join(usr, wad);\n    }\n    /**\n    * @notice Exit pegged-coins from the system and inside 'Coin.sol'\n    * @dev Inside the system, coins have 45 (rad) decimals but outside they have 18 decimals (wad).\n           When we exit, we specify a wad amount of coins and then the contract automatically multiplies\n           wad by 10**27 to move the correct 45 decimal coin amount to this adapter\n    * @param usr Account that will receive the exited coins\n    * @param wad Amount of internal coins to join (18 decimal number that will be multiplied by ray)\n    **/\n    function exit(address usr, uint wad) external {\n        require(contractEnabled == 1, \"CoinJoin/not-contractEnabled\");\n        safeEngine.transferInternalCoins(msg.sender, address(this), mul(ONE, wad));\n        systemCoin.mint(usr, wad);\n        emit Exit(usr, wad);\n    }\n}\n\ncontract CollateralJoin3 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 1;\n        emit AddAuthorization(usr);\n    }\n    function removeAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 0;\n        emit RemoveAuthorization(usr);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin3/not-authorized\");\n        _;\n    }\n\n    SafeEngineLike public safeEngine;\n    bytes32 public collateralType;\n    IERC20 public collateral;      // Actual collateral token contract\n    uint256 public decimals;\n    uint256 public contractEnabled;  // Access Flag\n\n    // Events\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n    event DisableContract();\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_, uint256 decimals_) public {\n        require(decimals_ < 18, \"CollateralJoin3/decimals-18-or-higher\");\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        safeEngine = SafeEngineLike(safeEngine_);\n        collateralType = collateralType_;\n        collateral = IERC20Metadata(collateral_);\n        decimals = decimals_;\n        emit AddAuthorization(msg.sender);\n    }\n\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"CollateralJoin3/overflow\");\n    }\n\n    function join(address usr, uint256 amt) external {\n        require(contractEnabled == 1, \"CollateralJoin3/not-contractEnabled\");\n        uint256 wad = mul(amt, 10 ** (18 - decimals));\n        require(wad <= 2 ** 255, \"CollateralJoin3/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int256(wad));\n        require(collateral.transferFrom(msg.sender, address(this), amt), \"CollateralJoin3/failed-transfer\");\n        emit Join(usr, amt);\n    }\n\n    function exit(address usr, uint256 amt) external {\n        uint256 wad = mul(amt, 10 ** (18 - decimals));\n        require(wad <= 2 ** 255, \"CollateralJoin3/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int256(wad));\n        require(collateral.transfer(usr, amt), \"CollateralJoin3/failed-transfer\");\n        emit Exit(usr, amt);\n    }\n}\n\n// For tokens that do not implement transferFrom (like GNT), meaning the usual adapter\n// approach won't work: the adapter cannot call transferFrom and therefore\n// has no way of knowing when users deposit gems into it.\n\n// To work around this, we introduce the concept of a bag, which is a trusted\n// (it's created by the adapter), personalized component (one for each user).\n\n// Users first have to create their bag with `GemJoin4.make`, then transfer\n// gem to it, and then call `GemJoin4.join`, which transfer the gems from the\n// bag to the adapter.\nabstract contract CollateralLike4 {\n    function decimals() virtual public view returns (uint);\n    function balanceOf(address) virtual public returns (uint256);\n    function transfer(address, uint256) virtual public returns (bool);\n}\n\ncontract CollateralBag {\n    address         public ada;\n    address         public lad;\n    CollateralLike4 public collateral;\n\n    constructor(address lad_, address collateral_) public {\n        ada = msg.sender;\n        lad = lad_;\n        collateral = CollateralLike4(collateral_);\n    }\n\n    /*\n    * @notify Transfer tokens out of this bag\n    * @param usr The address that will receive tokens\n    * @param wad The amount of tokens to transfer out of the bag\n    */\n    function exit(address usr, uint256 wad) external {\n        require(msg.sender == ada || msg.sender == lad, \"CollateralBag/invalid-caller\");\n        require(collateral.transfer(usr, wad), \"CollateralBag/failed-transfer\");\n    }\n}\n\ncontract CollateralJoin4 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 1;\n        emit AddAuthorization(usr);\n    }\n    function removeAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 0;\n        emit RemoveAuthorization(usr);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin4/not-authorized\");\n        _;\n    }\n\n    SafeEngineLike public safeEngine;\n    bytes32 public collateralType;\n    CollateralLike4 public collateral;      // Actual collateral token contract\n    uint256 public decimals;\n    uint256 public contractEnabled;  // Access Flag\n\n    // Events\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n    event Join(address sender, address bag, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n    event DisableContract();\n\n    mapping(address => address) public bags;\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SafeEngineLike(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike4(collateral_);\n        decimals = collateral.decimals();\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    function make() external returns (address bag) {\n        bag = make(msg.sender);\n    }\n\n    function make(address usr) public returns (address bag) {\n        require(bags[usr] == address(0), \"CollateralJoin4/bag-already-exists\");\n\n        bag = address(new CollateralBag(address(usr), address(collateral)));\n        bags[usr] = bag;\n    }\n\n    function join(address usr, uint256 amt) external {\n        require(contractEnabled == 1, \"CollateralJoin4/not-contractEnabled\");\n        require(int256(amt) >= 0, \"CollateralJoin4/negative-amount\");\n\n        CollateralBag(bags[msg.sender]).exit(address(this), amt);\n        safeEngine.modifyCollateralBalance(collateralType, usr, int256(amt));\n        emit Join(msg.sender, bags[msg.sender], usr, amt);\n    }\n\n    function exit(address usr, uint256 wad) external {\n        require(int256(wad) >= 0, \"CollateralJoin4/negative-amount\");\n\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int256(wad));\n        require(collateral.transfer(usr, wad), \"CollateralJoin4/failed-transfer\");\n\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\n/// TODO: use dss-gem-joins or add more gems for other collaterals\n"
    },
    "contracts/makerdao/externalContracts/LiquidationEngine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// dog.sol -- Dai liquidation module 2.0\n\n// Copyright (C) 2020-2022 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport {AuthWithoutContractEnabled} from \"../utils/v8/AuthWithoutContractEnabled.sol\";\nimport \"../interfaces/v8/ILiquidationEngine.sol\";\nimport \"../interfaces/v8/ISafeEngine.sol\";\nimport \"../../exchange/interfaces/IExchange.sol\";\nimport {CollateralJoin} from \"../core/BasicTokenAdapters.sol\";\n\nimport {Math} from \"../utils/v8/Math.sol\";\n\ninterface AccountingEngineLike {\n    function pushDebtToQueue(uint256) external;\n}\n\ncontract LiquidationEngine is AuthWithoutContractEnabled, ILiquidationEngine, Math {\n    ISafeEngine immutable public safeEngine;  // CDP Engine\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    AccountingEngineLike public accountingEngine;   // Debt Engine\n    uint256 public GlobalLiquidationLimit;  // Max DAI needed to cover debt+fees of active auctions [rad]\n    uint256 public ActiveLiquidationAmount;  // Amt DAI needed to cover debt+fees of active auctions [rad]\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        safeEngine = ISafeEngine(safeEngine_);\n        contractEnabled = 1;\n        authorizedAccounts[msg.sender] = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 what, address data) external override isAuthorized {\n        if (what == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else revert(\"LiquidationEngine/file-unrecognized-param\");\n        emit ModifyParameters(what, data);\n    }\n    function modifyParameters(bytes32 what, uint256 data) external override isAuthorized {\n        if (what == \"GlobalLiquidationLimit\") GlobalLiquidationLimit = data;\n        else revert(\"LiquidationEngine/file-unrecognized-param\");\n        emit ModifyParameters(what, data);\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint256 data) external override isAuthorized {\n        if (what == \"liquidationPenalty\") {\n            require(data >= WAD, \"LiquidationEngine/file-liquidationPenalty-lt-WAD\");\n            collateralTypes[collateralType].liquidationPenalty = data;\n        } else if (what == \"liquidationLimit\") collateralTypes[collateralType].liquidationLimit = data;\n        else revert(\"LiquidationEngine/file-unrecognized-param\");\n        emit ModifyParameters(collateralType, what, data);\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, address liquidator) external override isAuthorized {\n        if (what == \"liquidator\") {\n            // require(collateralType == AuctionLike(liquidator).collateralType(), \"LiquidationEngine/file-collateralType-neq-liquidator.collateralType\");\n            collateralTypes[collateralType].liquidator = liquidator;\n        } else revert(\"LiquidationEngine/file-unrecognized-param\");\n        emit ModifyParameters(collateralType, what, liquidator);\n    }\n\n    function liquidationPenalty(bytes32 collateralType) external override view returns (uint256) {\n        return collateralTypes[collateralType].liquidationPenalty;\n    }\n\n    // --- CDP Liquidation: all bark and no bite ---\n    function liquidateCDP(bytes32 collateralType, address cdp, address incentivesReceiver, address collateralJoin) external override returns (uint256 id) {\n        require(contractEnabled == 1, \"LiquidationEngine/not-contractEnabled\");\n\n        (uint256 collateralAmount, uint256 generatedDebt) = safeEngine.safes(collateralType, cdp);\n        CollateralType memory _cType = collateralTypes[collateralType];\n        uint256 deltaGeneratedDebt;\n        uint256 accumulatedRate;\n        uint256 debtFloor;\n        {\n            uint256 safetyPrice;\n            (, accumulatedRate, safetyPrice,, debtFloor) = safeEngine.collateralTypes(collateralType);\n            require(safetyPrice > 0 && _mul(collateralAmount, safetyPrice) < _mul(generatedDebt, accumulatedRate), \"LiquidationEngine/not-unsafe\");\n\n            // Get the minimum value between:\n            // 1) Remaining space in the general GlobalLiquidationLimit\n            // 2) Remaining space in the collateral liquidationLimit\n            require(GlobalLiquidationLimit > ActiveLiquidationAmount && _cType.liquidationLimit > _cType.activeLiquidationAmount, \"LiquidationEngine/liquidation-limit-hit\");\n            uint256 room = min(GlobalLiquidationLimit - ActiveLiquidationAmount, _cType.liquidationLimit - _cType.activeLiquidationAmount);\n\n            // uint256.max()/(RAD*WAD) = 115,792,089,237,316\n            deltaGeneratedDebt = min(generatedDebt, _mul(room, WAD) / accumulatedRate / _cType.liquidationPenalty);\n\n            // Partial liquidation edge case logic\n            if (generatedDebt > deltaGeneratedDebt) {\n                if (_mul(generatedDebt - deltaGeneratedDebt, accumulatedRate) < debtFloor) {\n\n                    // If the leftover Vault would be dusty, just liquidate it entirely.\n                    // This will result in at least one of activeLiquidationAmount_i > liquidationLimit_i or ActiveLiquidationAmount > GlobalLiquidationLimit becoming true.\n                    // The amount of excess will be bounded above by ceiling(debtFloor_i * liquidationPenalty_i / WAD).\n                    // This deviation is assumed to be small compared to both liquidationLimit_i and GlobalLiquidationLimit, so that\n                    // the extra amount of target DAI over the limits intended is not of economic concern.\n                    deltaGeneratedDebt = generatedDebt;\n                } else {\n\n                    // In a partial liquidation, the resulting auction should also be non-dusty.\n                    require(_mul(deltaGeneratedDebt, accumulatedRate) >= debtFloor, \"LiquidationEngine/dusty-auction-from-partial-liquidation\");\n                }\n            }\n        }\n\n        uint256 deltaCollateral = _mul(collateralAmount, deltaGeneratedDebt) / generatedDebt;\n\n        require(deltaCollateral > 0, \"LiquidationEngine/null-auction\");\n        require(deltaGeneratedDebt <= 2**255 && deltaCollateral <= 2**255, \"LiquidationEngine/overflow\");\n\n        safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType, cdp, _cType.liquidator, address(accountingEngine), -int256(deltaCollateral), -int256(deltaGeneratedDebt)\n        );\n\n        uint256 due = _mul(deltaGeneratedDebt, accumulatedRate);\n        accountingEngine.pushDebtToQueue(due);\n\n        {   // Avoid stack too deep\n            // This calcuation will overflow if deltaGeneratedDebt*rate exceeds ~10^14\n            uint256 amountToRaise = _mul(due, _cType.liquidationPenalty) / WAD;\n            ActiveLiquidationAmount = _add(ActiveLiquidationAmount, amountToRaise);\n            collateralTypes[collateralType].activeLiquidationAmount = _add(_cType.activeLiquidationAmount, amountToRaise);\n\n//            id = AuctionLike(_cType.liquidator).startAuction({\n//                debt: amountToRaise,\n//                collateralToSell: deltaCollateral,\n//                colReceiver: cdp,\n//                incentivesReceiver: incentivesReceiver\n//            });\n\n            // TODO: create algorithm, how to choose stablecoin\n            address stablecoin = EnumerableSetUpgradeable.at(_stablecoinWhitelist, 0);\n            id = IExchange(_cType.liquidator).addOrder(\n                address(CollateralJoin(collateralJoin).collateral()),\n                deltaCollateral,\n                // amountToRaise, TODO: add minAmount?\n                stablecoin,\n                incentivesReceiver,\n                DiscountType.middle, // TODO: should depend on HF\n                collateralJoin\n            );\n        }\n\n        emit LiquidateCDP(collateralType, cdp, deltaCollateral, deltaGeneratedDebt, due, _cType.liquidator, id);\n    }\n\n    function reduceActiveLiquidationAmount(bytes32 collateralType, uint256 rad) external override isAuthorized {\n        ActiveLiquidationAmount = _sub(ActiveLiquidationAmount, rad);\n        collateralTypes[collateralType].activeLiquidationAmount = _sub(collateralTypes[collateralType].activeLiquidationAmount, rad);\n        emit ReduceActiveLiquidationAmount(collateralType, rad);\n    }\n\n    // --- Stablecoin Whitelist ---\n    EnumerableSetUpgradeable.AddressSet internal _stablecoinWhitelist;\n\n    function addWhitelistStablecoin(address _stablecoin) public isAuthorized {\n        EnumerableSetUpgradeable.add(_stablecoinWhitelist, _stablecoin);\n    }\n\n    function removeWhitelistStablecoin(address _stablecoin) public isAuthorized {\n        EnumerableSetUpgradeable.remove(_stablecoinWhitelist, _stablecoin);\n    }\n\n    function hasWhitelistStablecoin(address _stablecoin) public view returns(bool) {\n        return EnumerableSetUpgradeable.contains(_stablecoinWhitelist, _stablecoin);\n    }\n}\n"
    },
    "contracts/makerdao/interfaces/v8/IAuth.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface IAuth {\n    function addAuthorization(address usr) external;\n    function removeAuthorization(address usr) external;\n}\n"
    },
    "contracts/makerdao/interfaces/v8/IAuthWithContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport {IAuth} from \"./IAuth.sol\";\n\ninterface IAuthWithContractEnabled is IAuth {\n    event DisableContract();\n\n    function disableContract() external;\n}\n"
    },
    "contracts/makerdao/interfaces/v8/ICollateralJoin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport {IAuthWithContractEnabled} from \"./IAuthWithContractEnabled.sol\";\n\n/**\n * @title ITaxCollector\n **/\ninterface ICollateralJoin is IAuthWithContractEnabled {\n    /* ==================== METHODS ==================== */\n\n    /**\n    * @notice Join collateral in the system\n    * @param usr Account from which we transferFrom collateral and add it in the system\n    * @param wad Amount of collateral to transfer in the system (represented as a number with 18 decimals)\n    **/\n    function join(address usr, uint wad) external;\n\n    /**\n    * @notice Exit collateral from the system\n    * @param usr Account to which we transfer the collateral\n    * @param wad Amount of collateral to transfer to 'account' (represented as a number with 18 decimals)\n    **/\n    function exit(address usr, uint wad) external;\n}\n"
    },
    "contracts/makerdao/interfaces/v8/ILiquidationEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title ITaxCollector\n **/\ninterface ILiquidationEngine {\n    /* ==================== STRUCTS ==================== */\n\n    struct CollateralType {\n        address liquidator;  // Liquidator, Exchange module\n        uint256 liquidationPenalty;  // Liquidation Penalty                                          [wad]\n        uint256 liquidationLimit;  // Max DAI needed to cover debt+fees of active auctions per collateralType [rad]\n        uint256 activeLiquidationAmount;  // Amt DAI needed to cover debt+fees of active auctions per collateralType [rad]\n    }\n\n    /* ==================== EVENTS ===============-===== */\n\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n\n    event ModifyParameters(bytes32 indexed what, uint256 data);\n    event ModifyParameters(bytes32 indexed what, address data);\n    event ModifyParameters(bytes32 indexed collateralType, bytes32 indexed what, uint256 data);\n    event ModifyParameters(bytes32 indexed collateralType, bytes32 indexed what, address liquidator);\n\n    event LiquidateCDP(\n        bytes32 indexed collateralType,\n        address indexed cdp,\n        uint256 lockedCollateral,\n        uint256 generatedDebt,\n        uint256 due,\n        address liquidator,\n        uint256 indexed id\n    );\n    event ReduceActiveLiquidationAmount(bytes32 indexed collateralType, uint256 rad);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    // --- Administration ---\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, address data) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, address data) external;\n\n    /**\n      * @notice Liquidate a Vault and start a Dutch auction to sell its collateral for DAI.\n      * @dev The entire Vault will be liquidated except when the target amount of DAI to be raised in\n      * the resulting auction (debt of Vault + liquidation penalty) causes either ActiveLiquidationAmount to exceed\n      * GlobalLiquidationLimit or collateralType.activeLiquidationAmount to exceed collateralType.liquidationLimit by an economically significant amount. In that\n      * case, a partial liquidation is performed to respect the global and per-collateralType limits on\n      * outstanding DAI target. The one exception is if the resulting auction would likely\n      * have too little collateral to be interesting to Keepers (debt taken from Vault < collateralType.debtFloor),\n      * in which case the function reverts. Please refer to the code and comments within if\n      * more detail is desired.\n      * @param collateralType - collateral type\n      * @param cdp - address of cdp position\n      * @param incentivesReceiver - address that will receive the liquidation reward, if any.\n      * @param collateralJoin - address of collateral adapter\n    **/\n    function liquidateCDP(bytes32 collateralType, address cdp, address incentivesReceiver, address collateralJoin) external returns (uint256 id);\n\n    function reduceActiveLiquidationAmount(bytes32 collateralType, uint256 rad) external;\n\n    /* ==================== VIEW METHODS ==================== */\n\n    function liquidationPenalty(bytes32 collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/makerdao/interfaces/v8/ISafeEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title SafeEngine\n * @notice The single source of truth for the Maker Protocol. It contains the accounting system of the core Vault,\n * Internal Dai balances, and collateral state. It houses the public interface for Vault management,\n * allowing safe(= CDP or Vault) owners to adjust their Vault state balances. It also contains the public interface\n * for Vault fungibility, allowing safe (Vault) owners to transfer, split, and merge Vaults.\n * Excluding these interfaces, SAFEEngine is accessed through trusted smart contract modules.\n **/\ninterface ISafeEngine {\n    /* ==================== METHODS ==================== */\n\n    // --- Data ---\n    struct CollateralType {\n        uint256 debtAmount;       // Total debt issued for this specific collateral type                          [wad]\n        uint256 accumulatedRate;  // Accumulator for interest accrued on this collateral type                     [ray]\n        uint256 safetyPrice;      // Floor price at which a CDP is allowed to generate debt                       [ray]\n        uint256 debtCeiling;      // Maximum amount of debt that can be generated with this collateral type       [rad]\n        uint256 debtFloor;        // Minimum amount of debt that must be generated by a CDP using this collateral [rad]\n    }\n    struct SAFE {\n        uint256 lockedCollateral; // Total amount of collateral locked in a SAFE/CDP  [wad]\n        uint256 generatedDebt;    // Total amount of debt generated by a SAFE/CDP     [wad]\n    }\n\n    // --- VARS ---\n\n    function safes(bytes32, address) external view returns (uint, uint);\n\n    function collateralTypes(bytes32) external view returns (\n        uint256 debtAmount,   // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,\n        uint256 debtCeiling,\n        uint256 debtFloor\n    );\n\n    // --- Auth ---\n    /**\n     * @notice Allow an address to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function approveSAFEModification(address usr) external;\n\n    /**\n     * @notice Deny an address the rights to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function denySAFEModification(address usr) external;\n\n    // --- Administration ---\n\n    function initializeCollateralType(bytes32 collateralType) external;\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n\n    // --- Fungibility ---\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external;\n    function transferInternalCoins(address src, address dst, uint256 rad) external;\n\n    // --- CDP Manipulation ---\n    /**\n     * @notice Add/remove collateral or put back/generate more debt in a CDP\n     * @param collateralType Type of collateral to withdraw/deposit in and from the CDP\n     * @param cdp Target CDP\n     * @param collateralSource Account we take collateral from/put collateral into\n     * @param debtDestination Account from which we credit/debit coins and debt\n     * @param deltaCollateral Amount of collateral added/extract from the CDP\n     * @param deltaDebt Amount of debt to generate/repay\n     */\n    function modifySAFECollateralization(bytes32 collateralType, address cdp, address collateralSource, address debtDestination, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Fungibility ---\n    /**\n     * @notice Transfer collateral and/or debt between CDPs\n     * @param collateralType Collateral type transferred between CDPs\n     * @param src Source CDP\n     * @param dst Destination CDP\n     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst\n     * @param deltaDebt Amount of debt to take/add into src and give/take from dst\n     */\n    function transferSAFECollateralAndDebt(bytes32 collateralType, address src, address dst, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Confiscation ---\n    /**\n     * @notice Normally used by the LiquidationEngine in order to confiscate collateral and\n       debt from a CDP and give them to someone else\n     * @param collateralType Collateral type the CDP has locked inside\n     * @param cdp Target CDP\n     * @param collateralCounterparty Who we take/give collateral to\n     * @param debtCounterparty Who we take/give debt to\n     * @param deltaCollateral Amount of collateral taken/added into the CDP\n     * @param deltaDebt Amount of debt taken/added into the CDP\n     */\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address cdp, address collateralCounterparty, address debtCounterparty, int deltaCollateral, int deltaDebt) external;\n\n    // --- Settlement ---\n    /**\n     * @notice Nullify an amount of coins with an equal amount of debt\n     * @param rad Amount of debt & coins to destroy (expressed as a number with 45 decimals)\n     */\n    function settleDebt(uint rad) external;\n\n    /**\n     * @notice Usually called by CoinSavingsAccount in order to create unbacked debt\n     * @param debtDestination Usually AccountingEngine that can settle decreaseSoldAmount with surplus\n     * @param coinDestination Usually CoinSavingsAccount who passes the new coins to depositors\n     * @param rad Amount of debt to create (expressed as a number with 45 decimals)\n     */\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external;\n\n    // --- Rates ---\n    /**\n     * @notice Usually called by TaxCollector in order to accrue interest on a specific collateral type\n     * @param collateralType Collateral type we accrue interest for\n     * @param surplusDst Destination for amount of surplus created by applying the interest rate\n       to debt created by CDPs with 'collateralType'\n     * @param accumulatedRate Multiplier applied to the debtAmount in order to calculate the surplus\n     */\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external;\n}\n"
    },
    "contracts/makerdao/utils/v8/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IAuth} from \"../../interfaces/v8/IAuth.sol\";\n\nabstract contract Auth is IAuth {\n    error NotAuthorized();\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 1;  }\n    function removeAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 0; }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert NotAuthorized();\n        _;\n    }\n}\n"
    },
    "contracts/makerdao/utils/v8/AuthWithContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IAuthWithContractEnabled} from \"../../interfaces/v8/IAuthWithContractEnabled.sol\";\n\nabstract contract AuthWithContractEnabled is IAuthWithContractEnabled {\n    error NotAuthorized();\n    error NotContractEnabled();\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external override isAuthorized {\n        if (contractEnabled != 1) revert NotContractEnabled();\n        authorizedAccounts[usr] = 1;\n    }\n    function removeAuthorization(address usr) external override isAuthorized {\n        if (contractEnabled != 1) revert NotContractEnabled();\n        authorizedAccounts[usr] = 0;\n    }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert NotAuthorized();\n        _;\n    }\n\n    uint256 public contractEnabled; // Access flag, indicates whether this contract is still active\n    function disableContract() external override isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n}\n"
    },
    "contracts/makerdao/utils/v8/AuthWithoutContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IAuthWithContractEnabled} from \"../../interfaces/v8/IAuthWithContractEnabled.sol\";\n\nabstract contract AuthWithoutContractEnabled is IAuthWithContractEnabled {\n    error NotAuthorized();\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 1; }\n    function removeAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 0; }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert NotAuthorized();\n        _;\n    }\n\n    uint256 public contractEnabled; // Access flag, indicates whether this contract is still active\n    function disableContract() external override isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n}\n"
    },
    "contracts/makerdao/utils/v8/Math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nabstract contract Math {\n    uint256 constant WAD = 10 ** 18;\n\n    function _add(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function _sub(uint x, int y) internal pure returns (uint z) {\n        z = x - uint(y);\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function _mul(uint x, int y) internal pure returns (int z) {\n        z = int(x) * y;\n        require(int(x) >= 0);\n        require(y == 0 || z / y == int(x));\n    }\n\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function _sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function _mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x <= y ? x : y;\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n}\n"
    },
    "contracts/mocks/Mock1INCH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Mock1INCH is ERC20 {\n    constructor() ERC20(\"test 1INCH\", \"1INCH\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mocks/MockDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockDAI is ERC20 {\n    constructor() ERC20(\"test DAI\", \"DAI\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mocks/MockGainErc20v1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"../gain-erc20/GainErc20v1.sol\";\n\ncontract MockGainErc20v1 is GainErc20v1 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) payable GainErc20v1(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function transferInternal(\n        address from,\n        address to,\n        uint256 value\n    ) public {\n        _transfer(from, to, value);\n    }\n\n    function approveInternal(\n        address owner,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/mocks/MockSHIB.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockSHIB is ERC20 {\n    constructor() ERC20(\"test SHIBA INU\", \"SHIB\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mocks/MockSuDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract MockSuDAO is ERC20 {\n    constructor() ERC20(\"test SuDAO\", \"tSuDAO\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mocks/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * USDT (Tether) implementation doesn't follow ERC standard and can be found here\n * https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code\n * This is mock implementation for testing that resembles Tether interface\n * and helps to avoid situation where openzeppelin erc20 works on testnet but real USDT fails on mainnet\n */\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface TetherERC20Basic {\n    function totalSupply() external returns  (uint);\n    function balanceOf(address who) external returns (uint);\n    function transfer(address to, uint value) external;\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function allowance(address owner, address spender) external returns (uint);\n    function transferFrom(address from, address to, uint value) external;\n    function approve(address spender, uint value) external;\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n/**\n     fork of openzeppelin v4 ERC20 with custom decimals\n**/\ncontract TetherERC20 is Context, TetherERC20Basic {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 immutable private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override {\n        _transfer(_msgSender(), recipient, amount);\n//        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override {\n        _approve(_msgSender(), spender, amount);\n//        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override  {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n//        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n\n\n\ncontract MockUSDT is TetherERC20 {\n    constructor() TetherERC20(\"tTether\", \"tUSDT\", 6) {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mocks/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockWETH is ERC20 {\n    constructor() ERC20(\"test Wrapped ETH\", \"ETH\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mocks/SimpleFillOrder.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';\nimport \"../exchange/interfaces/IExchange.sol\";\nimport \"../exchange/interfaces/IExchangeCallback.sol\";\n\nstruct FlashCallbackData {\n    address recipient;\n}\n\ncontract SimpleFillOrder is IExchangeCallback {\n    IExchange internal EXCHANGE;\n\n    constructor(address _exchange) {\n        EXCHANGE = IExchange(_exchange);\n    }\n\n    function fillOrderSimple(uint256 orderId, address token2sell, uint256 token2sellAmount) public {\n        bytes memory data = abi.encode(FlashCallbackData({ recipient: msg.sender }));\n\n        EXCHANGE.fillOrderAsFlashLoan(orderId, token2sellAmount, data);\n\n        TransferHelper.safeTransfer(token2sell, msg.sender, token2sellAmount);\n    }\n\n    function stableunitFillOrderCallback(address asset, uint256 amount, address, bytes calldata data) external returns (bool) {\n        FlashCallbackData memory decoded = abi.decode(data, (FlashCallbackData));\n\n        TransferHelper.safeTransferFrom(asset, decoded.recipient, address(EXCHANGE), amount);\n        return true;\n    }\n}"
    },
    "contracts/mocks/SimpleSwap.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';\n\ncontract SimpleSwap {\n    ISwapRouter public immutable swapRouter;\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    uint24 public constant feeTier = 3000;\n\n    constructor(ISwapRouter _swapRouter) {\n        swapRouter = _swapRouter;\n    }\n\n    // Docs: https://docs.uniswap.org/contracts/v3/guides/swaps/single-swaps\n    function swapWETHForDAI(uint amountIn) external returns (uint256 amountOut) {\n        // Transfer the specified amount of WETH9 to this contract.\n        TransferHelper.safeTransferFrom(WETH9, msg.sender, address(this), amountIn);\n        // Approve the router to spend WETH9.\n        TransferHelper.safeApprove(WETH9, address(swapRouter), amountIn);\n        // Create the params that will be used to execute the swap\n        ISwapRouter.ExactInputSingleParams memory params =\n        ISwapRouter.ExactInputSingleParams({\n            tokenIn: WETH9,\n            tokenOut: DAI,\n            fee: feeTier,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        // The call to `exactInputSingle` executes the swap.\n        amountOut = swapRouter.exactInputSingle(params);\n        return amountOut;\n    }\n\n    function swapWETHForWBTC(uint amountIn) external returns (uint256 amountOut) {\n        // Transfer the specified amount of WETH9 to this contract.\n        TransferHelper.safeTransferFrom(WETH9, msg.sender, address(this), amountIn);\n        // Approve the router to spend WETH9.\n        TransferHelper.safeApprove(WETH9, address(swapRouter), amountIn);\n        // Create the params that will be used to execute the swap\n        ISwapRouter.ExactInputSingleParams memory params =\n        ISwapRouter.ExactInputSingleParams({\n            tokenIn: WETH9,\n            tokenOut: WBTC,\n            fee: feeTier,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        // The call to `exactInputSingle` executes the swap.\n        amountOut = swapRouter.exactInputSingle(params);\n        return amountOut;\n    }\n\n    function swapWETHForToken(address tokenOut, uint amountIn) external returns (uint256 amountOut) {\n        // Transfer the specified amount of WETH9 to this contract.\n        TransferHelper.safeTransferFrom(WETH9, msg.sender, address(this), amountIn);\n        // Approve the router to spend WETH9.\n        TransferHelper.safeApprove(WETH9, address(swapRouter), amountIn);\n        // Create the params that will be used to execute the swap\n        ISwapRouter.ExactInputSingleParams memory params =\n        ISwapRouter.ExactInputSingleParams({\n            tokenIn: WETH9,\n            tokenOut: tokenOut,\n            fee: feeTier,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        // The call to `exactInputSingle` executes the swap.\n        amountOut = swapRouter.exactInputSingle(params);\n        return amountOut;\n    }\n}"
    },
    "contracts/periphery/contracts/access-control/SuAccessControlSingleton.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/access-control/ISuAccessControl.sol\";\nimport \"./SuAccessRoles.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title SuAccessControl\n * @dev Access control for contracts. SuVaultParameters can be inherited from it.\n * see hierarchy in SuAccessRoles.sol\n */\ncontract SuAccessControlSingleton is AccessControlUpgradeable, SuAccessRoles, ISuAccessControl {\n    /**\n     * @dev Initialize the contract with initial owner to be deployer\n     */\n    function initialize(address dao) public initializer {\n        __AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(DAO_ROLE, dao);\n\n        // Now we set hierarchy - what roles can give/revoke other roles\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        // Only DAO role can set Admin and System roles\n        _setRoleAdmin(ADMIN_ROLE, DAO_ROLE);\n\n        // Only DAO role can set System roles\n        _setRoleAdmin(MINT_ACCESS_ROLE, DAO_ROLE);\n        _setRoleAdmin(VAULT_ACCESS_ROLE, DAO_ROLE);\n        _setRoleAdmin(LIQUIDATION_ACCESS_ROLE, DAO_ROLE);\n        _setRoleAdmin(REWARD_ACCESS_ROLE, DAO_ROLE);\n\n        // Only Admin role can set Alerter role\n        _setRoleAdmin(ALERTER_ROLE, ADMIN_ROLE);\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) public onlyRole(DAO_ROLE) {\n        _setRoleAdmin(role, adminRole);\n    }\n}\n"
    },
    "contracts/periphery/contracts/access-control/SuAccessRoles.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title SuAccessRoles Library\n * @dev SuAuthenticated and SuAccessControlSingleton need to have this constants\n * Hierarchy:\n *      1. DAO - can give admins and system roles\n *      2.1. Admin - can set Alerters\n *      2.2. System - includes Minter, Vault, Liquidation and Reward roles, don't have access to give some roles.\n *      3. Alerter - can send alerts and trigger rate limits, don't have access to give some roles.\n */\nabstract contract SuAccessRoles {\n    bytes32 public constant ADMIN_ROLE = 0x00;\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n\n    bytes32 public constant ALERTER_ROLE = keccak256(\"ALERTER_ROLE\");\n\n    // system roles\n    bytes32 public constant MINT_ACCESS_ROLE = keccak256(\"MINT_ACCESS_ROLE\");\n    bytes32 public constant VAULT_ACCESS_ROLE = keccak256(\"VAULT_ACCESS_ROLE\");\n    bytes32 public constant LIQUIDATION_ACCESS_ROLE = keccak256(\"LIQUIDATION_ACCESS_ROLE\");\n    bytes32 public constant REWARD_ACCESS_ROLE = keccak256(\"REWARD_ACCESS_ROLE\");\n    bytes32 public constant SYSTEM_ROLE = keccak256(\"SYSTEM_ROLE\");\n}\n"
    },
    "contracts/periphery/contracts/access-control/SuAuthenticated.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/access-control/ISuAccessControl.sol\";\nimport \"./SuAccessRoles.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @title SuAuthenticated\n * @dev other contracts should inherit to be authenticated.\n * The address of SuAccessControlSingleton should be one for all contract that inherits SuAuthenticated\n */\nabstract contract SuAuthenticated is Initializable, SuAccessRoles, IERC165Upgradeable {\n    ISuAccessControl public ACCESS_CONTROL_SINGLETON;\n\n    error OnlyDAOError();\n    error OnlyAdminError();\n    error OnlyAlerterError();\n    error OnlyVaultAccessError();\n    error OnlyLiquidationAccessError();\n    error OnlyMintAccessError();\n    error OnlyRewardAccessError();\n    error OnlyRoleError();\n    error BadAccessControlSingleton();\n\n    /**\n     * @dev should be passed in constructor\n     */\n    function __suAuthenticatedInit(address _accessControlSingleton) internal onlyInitializing {\n        ACCESS_CONTROL_SINGLETON = ISuAccessControl(_accessControlSingleton);\n        if (\n            _accessControlSingleton != address(0) &&\n            !ISuAccessControl(_accessControlSingleton).supportsInterface(type(IAccessControlUpgradeable).interfaceId)\n        ) revert BadAccessControlSingleton();\n    }\n\n    /** CORE ROLES */\n\n    modifier onlyDAO() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(DAO_ROLE, msg.sender)) revert OnlyDAOError();\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ADMIN_ROLE, msg.sender)) revert OnlyAdminError();\n        _;\n    }\n\n    modifier onlyAlerter() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ALERTER_ROLE, msg.sender)) revert OnlyAlerterError();\n        _;\n    }\n\n    /** SYSTEM ROLES */\n\n    modifier onlyVaultAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(VAULT_ACCESS_ROLE, msg.sender)) revert OnlyVaultAccessError();\n        _;\n    }\n\n    modifier onlyLiquidationAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(LIQUIDATION_ACCESS_ROLE, msg.sender)) revert OnlyLiquidationAccessError();\n        _;\n    }\n\n    modifier onlyMintAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(MINT_ACCESS_ROLE, msg.sender)) revert OnlyMintAccessError();\n        _;\n    }\n\n    modifier onlyRewardAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(REWARD_ACCESS_ROLE, msg.sender)) revert OnlyRewardAccessError();\n        _;\n    }\n\n    // syntax sugar under ACCESS_CONTROL_SINGLETON\n    modifier onlyRole(bytes32 role) {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(role, msg.sender)) revert OnlyRoleError();\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return ACCESS_CONTROL_SINGLETON.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/periphery/contracts/access-control/SuAuthenticatedNonUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/access-control/ISuAccessControl.sol\";\nimport \"./SuAccessRoles.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title SuAuthenticated\n * @dev other contracts should inherit to be authenticated.\n * The address of SuAccessControlSingleton should be one for all contract that inherits SuAuthenticated\n */\nabstract contract SuAuthenticatedNonUpgradeable is SuAccessRoles, IERC165 {\n    ISuAccessControl public ACCESS_CONTROL_SINGLETON;\n\n    error OnlyDAOError();\n    error OnlyAdminError();\n    error OnlyAlerterError();\n    error OnlyVaultAccessError();\n    error OnlyLiquidationAccessError();\n    error OnlyMintAccessError();\n    error OnlyRewardAccessError();\n    error OnlyRoleError();\n    error BadAccessControlSingleton();\n\n    /**\n     * @dev should be passed in constructor\n     */\n    constructor (address _accessControlSingleton) internal {\n        ACCESS_CONTROL_SINGLETON = ISuAccessControl(_accessControlSingleton);\n        if (\n            !ISuAccessControl(_accessControlSingleton).supportsInterface(type(IAccessControlUpgradeable).interfaceId)\n        ) revert BadAccessControlSingleton();\n    }\n\n    /** CORE ROLES */\n\n    modifier onlyDAO() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(DAO_ROLE, msg.sender)) revert OnlyDAOError();\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ADMIN_ROLE, msg.sender)) revert OnlyAdminError();\n        _;\n    }\n\n    modifier onlyAlerter() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ALERTER_ROLE, msg.sender)) revert OnlyAlerterError();\n        _;\n    }\n\n    /** SYSTEM ROLES */\n\n    modifier onlyVaultAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(VAULT_ACCESS_ROLE, msg.sender)) revert OnlyVaultAccessError();\n        _;\n    }\n\n    modifier onlyLiquidationAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(LIQUIDATION_ACCESS_ROLE, msg.sender)) revert OnlyLiquidationAccessError();\n        _;\n    }\n\n    modifier onlyMintAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(MINT_ACCESS_ROLE, msg.sender)) revert OnlyMintAccessError();\n        _;\n    }\n\n    modifier onlyRewardAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(REWARD_ACCESS_ROLE, msg.sender)) revert OnlyRewardAccessError();\n        _;\n    }\n\n    // syntax sugar under ACCESS_CONTROL_SINGLETON\n    modifier onlyRole(bytes32 role) {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(role, msg.sender)) revert OnlyRoleError();\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return ACCESS_CONTROL_SINGLETON.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/periphery/contracts/adapters/BalancerAdapterWeighted.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"@prb/math/contracts/PRBMathSD59x18.sol\";\n\n// if import \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\" then we have a problem of\n// re-declaration of IERC20, because balancer implement their own IERC20 (don't know why)\nimport \"../vendor/balancer/IVault.sol\";\nimport \"../vendor/balancer/WeightedPoolUserData.sol\";\nimport \"../access-control/SuAuthenticated.sol\";\nimport \"../interfaces/adapters/ILPAdapter.sol\";\nimport \"../interfaces/adapters/IWeightedPool.sol\";\nimport \"./deprecated/BalancerAdapterWeightedUnsafe.sol\";\n\n/**\n * @dev\n * Default - It's pool that is not Composable, just StablePool, like AURA_LP\n * WeightedPool2Tokens - It's Balancer WeightedPool2Tokens LP token, like B_80BAL_20WETH_LP\n*/\nenum WeightedPoolType { Default, WeightedPool2Tokens }\n\nstruct LPInfoAdapter {\n    WeightedPoolType poolType;\n    bytes32 poolId;\n    IVault vault;\n    IERC20[] underlyingTokens;\n    IERC20[] underlyingTokensExpanded;\n}\n\n/**\n * @title BalancerAdapterWeighted\n * @notice Adapter for Balancer Weighted LP token.\n * @dev See ILPAdapter interface for full details. Before mainnet deploy need to remove BalancerAdapterWeightedUnsafe\n */\ncontract BalancerAdapterWeighted is SuAuthenticated, ILPAdapter, BalancerAdapterWeightedUnsafe {\n    using PRBMathSD59x18 for *;\n\n    mapping(address => LPInfoAdapter) public lps; // Mapping from LP token to pool\n    ISuOracle public ORACLE;\n    using WeightedPoolUserData for bytes;\n\n    function initialize(address _authControl, address _oracle) public initializer {\n        __suAuthenticatedInit(_authControl);\n        __BalancerAdapterWeightedUnsafe__init(_oracle);\n        ORACLE = ISuOracle(_oracle);\n    }\n\n    /**\n      * @notice Register the given LP token address and set the LP info. We go to the depth = 2, that means, that if\n      * LP token {lp} contains {lp1} and {erc20Token1} as underlying tokens,\n      * where lp1 contains {erc20Token0} and {erc20Token2},\n      * then we will register that {lp} has {erc20Token0}, {erc20Token2} and {erc20Token1} as underlying tokens.\n      * @param lp LP token to find and set the corresponding info.\n     **/\n    function registerLP(address lp, WeightedPoolType poolType) external onlyAdmin {\n        IVault vault = IWeightedPool(lp).getVault();\n        if (address(vault) == address(0)) revert IsNotLP(lp);\n        if (address(lps[lp].vault) != address(0)) revert AlreadyRegistered(lp);\n\n        bytes32 poolId = IWeightedPool(lp).getPoolId();\n\n        lps[lp].poolId = poolId;\n        lps[lp].vault = vault;\n        lps[lp].poolType = poolType;\n\n        (lps[lp].underlyingTokens,,) = vault.getPoolTokens(poolId);\n\n        uint256 nTokens = lps[lp].underlyingTokens.length;\n        for (uint16 i = 0; i < nTokens; ++i) {\n            IERC20 currentToken = lps[lp].underlyingTokens[i];\n            if (isAdapterLP(address(currentToken))) {\n                IERC20[] memory newUnderlyingTokens;\n                LPInfoAdapter memory underlyingLPTokenInfo = lps[address(currentToken)];\n                (newUnderlyingTokens,,) = underlyingLPTokenInfo.vault.getPoolTokens(\n                    underlyingLPTokenInfo.poolId\n                );\n                for (uint16 j = 0; j < newUnderlyingTokens.length; ++j) {\n                    lps[lp].underlyingTokensExpanded.push(newUnderlyingTokens[j]);\n                }\n            } else {\n                lps[lp].underlyingTokensExpanded.push(currentToken);\n            }\n        }\n    }\n\n    function isAdapterLP(address asset) public view returns (bool) {\n        return address(lps[asset].vault) != address(0);\n    }\n\n    // solhint-disable-next-line max-line-length\n    // Description - https://revestfinance.medium.com/dev-blog-on-the-derivation-of-a-safe-price-formula-for-balancer-pool-tokens-33e8993455d0\n    function _getFiatPriceWeightedComplex(address asset) internal view returns (uint256) {\n        LPInfoAdapter memory lpInfo = lps[asset];\n\n        (IERC20[] memory tokens, uint256[] memory balances, ) = lpInfo.vault.getPoolTokens(lpInfo.poolId);\n        uint256[] memory weights = IWeightedPool(asset).getNormalizedWeights();\n\n        int256 totalPi = PRBMathSD59x18.fromInt(1e18);\n        uint256[] memory prices = new uint256[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address underlyingTokenAddress = address(lpInfo.underlyingTokens[i]);\n            uint256 decimals = IERC20Metadata(underlyingTokenAddress).decimals();\n            balances[i] = (balances[i] * 1e18) / (10**decimals);\n            prices[i] = ORACLE.getFiatPrice1e18(underlyingTokenAddress) / (10**(18 - decimals));\n\n            int256 val = int256(prices[i]).div(int256(weights[i]));\n            int256 indivPi = val.pow(int256(weights[i]));\n\n            totalPi = totalPi.mul(indivPi);\n        }\n\n        int256 invariant = int256(IWeightedPool(asset).getLastInvariant());\n        int256 numerator = totalPi.mul(invariant);\n        int256 totalSupply = int256(IWeightedPool(asset).totalSupply());\n\n        return uint256(numerator.toInt().div(totalSupply));\n    }\n\n    function getFiatPrice1e18(address asset) external view returns (uint256) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n\n        // getTimeWeightedAverage is deprecated, so for any weighted LP token we should use this approximation\n        return _getFiatPriceWeightedComplex(asset);\n    }\n    /// @notice Deprecated - Simple version of oracle that can be attacked with flash-loan, only for tests\n    function getFiatPrice1e18Unsafe(address asset) external view returns (uint256) {\n        return _getFiatPrice1e18Unsafe(asset, lps[asset]);\n    }\n\n    function _withdrawInternal(address asset, uint256 amount) internal returns (WithdrawResult[] memory results) {\n        LPInfoAdapter memory lpInfo = lps[asset];\n        uint256 nTokens = lpInfo.underlyingTokens.length;\n        address vaultAddress = address(lpInfo.vault);\n        if (asset != vaultAddress && IERC20(asset).allowance(address(this), vaultAddress) < amount) {\n            IERC20(asset).approve(vaultAddress, amount);\n        }\n\n        uint256[] memory balancesBefore = new uint256[](nTokens);\n        for (uint16 i = 0; i < nTokens; ++i) {\n            balancesBefore[i] = lpInfo.underlyingTokens[i].balanceOf(address(this));\n        }\n\n        IAsset[] memory assets = new IAsset[](nTokens);\n        uint256[] memory minAmountsOut = new uint[](nTokens);\n        for (uint16 i = 0; i < nTokens; ++i) {\n            assets[i] = IAsset(address(lpInfo.underlyingTokens[i]));\n            minAmountsOut[i] = 0;\n        }\n        lpInfo.vault.exitPool(\n            lpInfo.poolId,\n            payable(address(this)),\n            payable(address(this)),\n            IVault.ExitPoolRequest({\n                assets: assets,\n                minAmountsOut: minAmountsOut,\n                userData: abi.encode(WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT, amount),\n                toInternalBalance: false\n            })\n        );\n\n        // For some LPs vault returns the first address in underlyingTokens as the LP token address\n        if (address(lpInfo.underlyingTokens[0]) == asset) {\n            results = new WithdrawResult[](nTokens - 1);\n            for (uint16 i = 1; i < nTokens; ++i) {\n                uint256 underlineTokenAmount = lpInfo.underlyingTokens[i].balanceOf(address(this)) - balancesBefore[i];\n                results[i - 1] = WithdrawResult({\n                    token: address(lpInfo.underlyingTokens[i]),\n                    amount: underlineTokenAmount\n                });\n            }\n        } else {\n            results = new WithdrawResult[](nTokens);\n            for (uint16 i = 0; i < nTokens; ++i) {\n                uint256 underlineTokenAmount = lpInfo.underlyingTokens[i].balanceOf(address(this)) - balancesBefore[i];\n                results[i] = WithdrawResult({\n                    token: address(lpInfo.underlyingTokens[i]),\n                    amount: underlineTokenAmount\n                });\n            }\n        }\n    }\n\n    function withdraw(address asset, uint256 amount) external returns (WithdrawResult[] memory results) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount);\n\n        uint256 nTokensExpanded = lps[asset].underlyingTokensExpanded.length;\n        WithdrawResult[] memory resultsExt = new WithdrawResult[](nTokensExpanded);\n        uint256 resultsIndex = 0;\n        WithdrawResult[] memory firstWithdrawResult = _withdrawInternal(asset, amount);\n        uint256 nTokens = firstWithdrawResult.length;\n        for (uint16 i = 0; i < nTokens; ++i) {\n            if (isAdapterLP(firstWithdrawResult[i].token)) {\n                WithdrawResult[] memory secondWithdrawResult = _withdrawInternal(\n                    firstWithdrawResult[i].token,\n                    firstWithdrawResult[i].amount\n                );\n                for (uint16 j = 0; j < nTokens; ++j) {\n                    resultsExt[resultsIndex] = secondWithdrawResult[j];\n                    ++resultsIndex;\n                }\n            } else {\n                resultsExt[resultsIndex] = firstWithdrawResult[i];\n                ++resultsIndex;\n            }\n        }\n\n        results = new WithdrawResult[](resultsIndex);\n        resultsIndex = 0;\n        for (uint16 i = 0; i < nTokensExpanded; ++i) {\n            address underlyingToken = resultsExt[i].token;\n            if (underlyingToken != address(0)) {\n                TransferHelper.safeTransfer(underlyingToken, msg.sender, resultsExt[i].amount);\n                results[resultsIndex] = resultsExt[i];\n                ++resultsIndex;\n            }\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/periphery/contracts/adapters/CurveAdapter.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport \"../access-control/SuAuthenticated.sol\";\nimport \"../interfaces/adapters/ILPAdapter.sol\";\nimport \"../vendor/curve/ICurveLP.sol\";\n\n/**\n * @dev\n * Default - It's pool that is not from stablecoins and is not V2 Factory.\n Oracle for this pool isn't secured from pool manipulations, so we can't create secure getPrice function.\n the example of such pool is tricrypto2 (USDT/WBTC/ETH).\n * STABLE - It's pool based on stablecoins ot eth, like 3pool, crvUSD/USDT ot steth\n * V2 - It's V2 Factory pool that have LP-oracle inside, like TriCRV, TricryptoUSDC\n*/\nenum CurvePoolType { Default, Stable, V2 }\n\nstruct CurveLPInfo {\n    address pool;\n    CurvePoolType poolType;\n    address[] underlyingTokens;\n}\n\n/**\n * @title CurveAdapter\n * @notice Adapter for Curve LP token.\n * @dev See ILPAdapter interface for full details.\n */\ncontract CurveAdapter is SuAuthenticated, ILPAdapter {\n    mapping(address => CurveLPInfo) public lps; // Mapping from LP token to pool\n    ISuOracle public ORACLE;\n\n    function initialize(address _authControl, address _oracle) public initializer {\n        __suAuthenticatedInit(_authControl);\n        ORACLE = ISuOracle(_oracle);\n    }\n\n    /**\n      * @notice Register the given LP token address and set the LP pool\n      * @param lp address of LP token\n      * @param lpPool address of pool of {lp} LP-token\n      * @param nTokens amount of underlyingTokens\n     **/\n    function registerLP(address lp, address lpPool, uint256 nTokens, CurvePoolType poolType) external onlyAdmin {\n        lps[lp].pool = lpPool;\n        lps[lp].poolType = poolType;\n        lps[lp].underlyingTokens = new address[](nTokens);\n        for (uint16 i = 0; i < nTokens; ++i) {\n            lps[lp].underlyingTokens[i] = ICurveLP(lpPool).coins(i);\n        }\n    }\n\n    function isAdapterLP(address asset) public view returns (bool) {\n        return lps[asset].pool != address(0);\n    }\n\n    /// @notice Is depreceted, only for tests usage\n    function getFiatPrice1e18Unsafe(address asset) public view returns (uint256) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        CurveLPInfo memory lpInfo = lps[asset];\n\n        uint256 sumBalances = 0;\n        uint256 nTokens = lpInfo.underlyingTokens.length;\n        for (uint256 i = 0; i < nTokens; ++i) {\n            uint256 newTokenBalance = ICurveLP(lpInfo.pool).balances(i);\n            sumBalances += newTokenBalance * ORACLE.getFiatPrice1e18(address(lpInfo.underlyingTokens[i]));\n        }\n\n        return sumBalances / IERC20(asset).totalSupply();\n    }\n\n    function _getFiatPriceStablePool(address asset) internal view returns (uint256) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        CurveLPInfo memory lpInfo = lps[asset];\n\n        return ICurveLP(lpInfo.pool).get_virtual_price();\n    }\n\n    function _getFiatPricePoolV2(address asset) internal view returns (uint256) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        CurveLPInfo memory lpInfo = lps[asset];\n\n        return ICurveLP(lpInfo.pool).lp_price();\n    }\n\n    function getFiatPrice1e18(address asset) external view returns (uint256) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        CurveLPInfo memory lpInfo = lps[asset];\n\n        if (lpInfo.poolType == CurvePoolType.Stable) {\n            return _getFiatPriceStablePool(asset);\n        }\n        if (lpInfo.poolType == CurvePoolType.V2) {\n            return _getFiatPricePoolV2(asset);\n        }\n\n        // If lpInfo.poolType == CurvePoolType.Default or not set:\n        revert LPOracleNotReady();\n    }\n\n    function withdraw(address asset, uint256 amount) external returns (WithdrawResult[] memory results) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount);\n        CurveLPInfo memory lpInfo = lps[asset];\n\n        uint256 nTokens = lpInfo.underlyingTokens.length;\n        results = new WithdrawResult[](nTokens);\n\n        if (asset != lpInfo.pool && IERC20(asset).allowance(address(this), lpInfo.pool) < amount) {\n            IERC20(asset).approve(lpInfo.pool, amount);\n        }\n\n        uint256[] memory balancesBefore = new uint256[](nTokens);\n        for (uint16 i = 0; i < nTokens; ++i) {\n            balancesBefore[i] = IERC20(lpInfo.underlyingTokens[i]).balanceOf(address(this));\n        }\n\n        if (nTokens == 2) {\n            uint256[2] memory minAmounts;\n            minAmounts[0] = 0;\n            minAmounts[1] = 0;\n            ICurveLP(lpInfo.pool).remove_liquidity(amount, minAmounts);\n        }\n        if (nTokens == 3) {\n            uint256[3] memory minAmounts;\n            minAmounts[0] = 0;\n            minAmounts[1] = 0;\n            minAmounts[2] = 0;\n            ICurveLP(lpInfo.pool).remove_liquidity(amount, minAmounts);\n        }\n\n        for (uint16 i = 0; i < nTokens; ++i) {\n            address underlyingToken = lpInfo.underlyingTokens[i];\n            uint256 underlineTokenAmount = IERC20(underlyingToken).balanceOf(address(this)) - balancesBefore[i];\n            results[i] = WithdrawResult({ token: underlyingToken, amount: underlineTokenAmount });\n            TransferHelper.safeTransfer(underlyingToken, msg.sender, underlineTokenAmount);\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/periphery/contracts/adapters/deprecated/BalancerAdapterStable.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/pool-stable/StablePoolUserData.sol\";\n\n// if import \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\" then we have a problem of\n// re-declaration of IERC20, because balancer implement their own IERC20 (don't know why)\nimport \"../../vendor/balancer/IVault.sol\";\nimport \"../../access-control/SuAuthenticated.sol\";\nimport \"../../interfaces/adapters/ILPAdapter.sol\";\nimport \"../../interfaces/adapters/IBasePoolExtended.sol\";\nimport \"../../interfaces/adapters/deprecated/IBalancerPriceOracle.sol\";\n\n/**\n * @dev\n * Default - It's pool that is not Composable, just StablePool, like AURA_BAL_LP\n * Composable - It's Balancer Composable Stable LP token, like WST_R_SFRX_LP\n * MetaStable - It's MetaStable LP token, like B-rETH-STABLE\n*/\nenum StablePoolType { Default, Composable, MetaStable }\n\nstruct LPInfoAdapter {\n    StablePoolType poolType;\n    bytes32 poolId;\n    IVault vault;\n    IERC20[] underlyingTokens;\n    IERC20[] underlyingTokensExpanded;\n}\n\ninterface IPoolWithActualSupply {\n    function getActualSupply() external view returns (uint256);\n}\n\n/**\n * @title BalancerAdapterStable\n * @notice Adapter for Balancer Stable LP token.\n * @dev See ILPAdapter interface for full details.\n */\ncontract BalancerAdapterStable is SuAuthenticated, ILPAdapter {\n    mapping(address => LPInfoAdapter) public lps; // Mapping from LP token to pool\n    ISuOracle public ORACLE;\n    using StablePoolUserData for bytes;\n\n    function initialize(address _authControl, address _oracle) public initializer {\n        __suAuthenticatedInit(_authControl);\n        ORACLE = ISuOracle(_oracle);\n    }\n\n    /**\n      * @notice Register the given LP token address and set the LP info. We go to the depth = 2, that means, that if\n      * LP token {lp} contains {lp1} and {erc20Token1} as underlying tokens,\n      * where lp1 contains {erc20Token0} and {erc20Token2},\n      * then we will register that {lp} has {erc20Token0}, {erc20Token2} and {erc20Token1} as underlying tokens.\n      * @param lp LP token to find and set the corresponding info.\n     **/\n    function registerLP(address lp, StablePoolType poolType) external onlyAdmin {\n        IVault vault = IBasePoolExtended(lp).getVault();\n        if (address(vault) == address(0)) revert IsNotLP(lp);\n        if (address(lps[lp].vault) != address(0)) revert AlreadyRegistered(lp);\n\n        bytes32 poolId = IBasePoolExtended(lp).getPoolId();\n\n        lps[lp].poolId = poolId;\n        lps[lp].vault = vault;\n        lps[lp].poolType = poolType;\n\n        (lps[lp].underlyingTokens,,) = vault.getPoolTokens(poolId);\n\n        uint256 nTokens = lps[lp].underlyingTokens.length;\n        for (uint16 i = 0; i < nTokens; ++i) {\n            IERC20 currentToken = lps[lp].underlyingTokens[i];\n            if (isAdapterLP(address(currentToken))) {\n                IERC20[] memory newUnderlyingTokens;\n                LPInfoAdapter memory underlyingLPTokenInfo = lps[address(currentToken)];\n                (newUnderlyingTokens,,) = underlyingLPTokenInfo.vault.getPoolTokens(\n                    underlyingLPTokenInfo.poolId\n                );\n                for (uint16 j = 0; j < newUnderlyingTokens.length; ++j) {\n                    lps[lp].underlyingTokensExpanded.push(newUnderlyingTokens[j]);\n                }\n            } else {\n                lps[lp].underlyingTokensExpanded.push(currentToken);\n            }\n        }\n    }\n\n    function isAdapterLP(address asset) public view returns (bool) {\n        return address(lps[asset].vault) != address(0);\n    }\n\n    function _getFiatPriceTimeWeightedAverage(address asset) internal view returns (uint256) {\n        LPInfoAdapter memory lpInfo = lps[asset];\n        IBalancerPriceOracle.OracleAverageQuery[] memory query = new IBalancerPriceOracle.OracleAverageQuery[](1);\n        query[0] = IBalancerPriceOracle.OracleAverageQuery(\n            IBalancerPriceOracle.Variable.BPT_PRICE,\n            120, // the average over the past 2 minutes (and 10 seconds because of `ago` argument)\n            10 // last price that included in this average was 10 seconds ago\n        );\n\n        // TODO: why price for RETH_METASTABLE_LP is not correct?\n        // Why we should multiply getTimeWeightedAverage not to firstTokenPrice, but on second?\n        uint256 firstTokenPrice = ORACLE.getFiatPrice1e18(address(lpInfo.underlyingTokens[0]));\n        uint256 price = IBalancerPriceOracle(asset).getTimeWeightedAverage(query)[0];\n        return firstTokenPrice * price / 1e18;\n    }\n\n    function getFiatPrice1e18(address asset) external view returns (uint256) {\n        revert LPOracleNotReady();\n//        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n//        LPInfoAdapter memory lpInfo = lps[asset];\n//\n//        if (lpInfo.poolType == StablePoolType.MetaStable) {\n//            return _getFiatPriceTimeWeightedAverage(asset);\n//        }\n//\n//        // TODO: check - getRate is more gas-efficient, but it isn't secure + we need to store base underline token\n//        // can be manipulated: https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345\n//        return getFiatPrice1e18Unsafe(asset);\n    }\n\n    function getFiatPrice1e18Unsafe(address asset) public view returns (uint256) {\n        LPInfoAdapter memory lpInfo = lps[asset];\n\n        uint256 sumBalances = 0;\n        uint256 nTokens = lpInfo.underlyingTokens.length;\n        (,uint256[] memory newUnderlyingTokenBalances,) = lpInfo.vault.getPoolTokens(lpInfo.poolId);\n        for (uint256 i = 0; i < nTokens; ++i) {\n            address underlyingTokenAddress = address(lpInfo.underlyingTokens[i]);\n            if (underlyingTokenAddress != asset) {\n                sumBalances += newUnderlyingTokenBalances[i] * ORACLE.getFiatPrice1e18(underlyingTokenAddress);\n            }\n        }\n\n        uint256 totalSupply = lpInfo.poolType == StablePoolType.Composable\n            ? IPoolWithActualSupply(asset).getActualSupply()\n            : IERC20(asset).totalSupply();\n\n        return sumBalances / totalSupply;\n    }\n\n    // For some LPs vault returns the first address in underlyingTokens as the LP token address =>\n    // after all _withdrawInternal calls we can receive array with length < underlyingTokensExpanded.length\n    function _withdrawInternal(address asset, uint256 amount) internal returns (WithdrawResult[] memory results) {\n        LPInfoAdapter memory lpInfo = lps[asset];\n        uint256 nTokens = lpInfo.underlyingTokens.length;\n        address vaultAddress = address(lpInfo.vault);\n        if (asset != vaultAddress && IERC20(asset).allowance(address(this), vaultAddress) < amount) {\n            IERC20(asset).approve(vaultAddress, amount);\n        }\n\n        uint256[] memory balancesBefore = new uint256[](nTokens);\n        for (uint16 i = 0; i < nTokens; ++i) {\n            balancesBefore[i] = lpInfo.underlyingTokens[i].balanceOf(address(this));\n        }\n\n        IAsset[] memory assets = new IAsset[](nTokens);\n        uint256[] memory minAmountsOut = new uint[](nTokens);\n        for (uint16 i = 0; i < nTokens; ++i) {\n            assets[i] = IAsset(address(lpInfo.underlyingTokens[i]));\n            minAmountsOut[i] = 0;\n        }\n        lpInfo.vault.exitPool(\n            lpInfo.poolId,\n            payable(address(this)),\n            payable(address(this)),\n            IVault.ExitPoolRequest({\n                assets: assets,\n                minAmountsOut: minAmountsOut,\n                userData: abi.encode(StablePoolUserData.ExitKind.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT, amount),\n                toInternalBalance: false\n            })\n        );\n\n        // For some LPs vault returns the first address in underlyingTokens as the LP token address\n        if (address(lpInfo.underlyingTokens[0]) == asset) {\n            results = new WithdrawResult[](nTokens - 1);\n            for (uint16 i = 1; i < nTokens; ++i) {\n                uint256 underlineTokenAmount = lpInfo.underlyingTokens[i].balanceOf(address(this)) - balancesBefore[i];\n                results[i - 1] = WithdrawResult({\n                    token: address(lpInfo.underlyingTokens[i]),\n                    amount: underlineTokenAmount\n                });\n            }\n        } else {\n            results = new WithdrawResult[](nTokens);\n            for (uint16 i = 0; i < nTokens; ++i) {\n                uint256 underlineTokenAmount = lpInfo.underlyingTokens[i].balanceOf(address(this)) - balancesBefore[i];\n                results[i] = WithdrawResult({\n                    token: address(lpInfo.underlyingTokens[i]),\n                    amount: underlineTokenAmount\n                });\n            }\n        }\n    }\n\n    function withdraw(address asset, uint256 amount) external returns (WithdrawResult[] memory results) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount);\n\n        uint256 nTokensExpanded = lps[asset].underlyingTokensExpanded.length;\n        WithdrawResult[] memory resultsExt = new WithdrawResult[](nTokensExpanded);\n        uint256 resultsIndex = 0;\n        WithdrawResult[] memory firstWithdrawResult = _withdrawInternal(asset, amount);\n        uint256 nTokens = firstWithdrawResult.length;\n        for (uint16 i = 0; i < nTokens; ++i) {\n            if (isAdapterLP(firstWithdrawResult[i].token)) {\n                WithdrawResult[] memory secondWithdrawResult = _withdrawInternal(\n                    firstWithdrawResult[i].token,\n                    firstWithdrawResult[i].amount\n                );\n                for (uint16 j = 0; j < nTokens; ++j) {\n                    resultsExt[resultsIndex] = secondWithdrawResult[j];\n                    ++resultsIndex;\n                }\n            } else {\n                resultsExt[resultsIndex] = firstWithdrawResult[i];\n                ++resultsIndex;\n            }\n        }\n\n        results = new WithdrawResult[](resultsIndex);\n        resultsIndex = 0;\n        for (uint16 i = 0; i < nTokensExpanded; ++i) {\n            address underlyingToken = resultsExt[i].token;\n            if (underlyingToken != address(0)) {\n                TransferHelper.safeTransfer(underlyingToken, msg.sender, resultsExt[i].amount);\n                results[resultsIndex] = resultsExt[i];\n                ++resultsIndex;\n            }\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/periphery/contracts/adapters/deprecated/BalancerAdapterWeightedUnsafe.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../BalancerAdapterWeighted.sol\";\nimport \"../../interfaces/oracle/ISuOracle.sol\";\n\n/**\n * @title BalancerAdapterWeightedUnsafe\n * @notice Needed to store getFiatPrice1e18Unsafe for tests\n */\nabstract contract BalancerAdapterWeightedUnsafe {\n    ISuOracle public _ORACLE;\n\n    function __BalancerAdapterWeightedUnsafe__init(address _oracle) public {\n        _ORACLE = ISuOracle(_oracle);\n    }\n\n    /// @notice Deprecated - Simple version of oracle that can be attacked with flash-loan, only for tests\n    function _getFiatPrice1e18Unsafe(address asset, LPInfoAdapter memory lpInfo) internal view returns (uint256) {\n        uint256 sumBalances = 0;\n        uint256 nTokens = lpInfo.underlyingTokens.length;\n        (,uint256[] memory newUnderlyingTokenBalances,) = lpInfo.vault.getPoolTokens(lpInfo.poolId);\n        for (uint256 i = 0; i < nTokens; ++i) {\n            address underlyingTokenAddress = address(lpInfo.underlyingTokens[i]);\n            if (underlyingTokenAddress != asset) {\n                sumBalances += newUnderlyingTokenBalances[i] * _ORACLE.getFiatPrice1e18(underlyingTokenAddress);\n            }\n        }\n\n        return sumBalances / IERC20(asset).totalSupply();\n    }\n}\n"
    },
    "contracts/periphery/contracts/adapters/deprecated/QuickSwapPolygonAdapter.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport \"../../access-control/SuAuthenticated.sol\";\nimport \"../../interfaces/adapters/ILPAdapter.sol\";\nimport \"../../vendor/quickswap/IUniswapV2Pair.sol\";\nimport \"../../vendor/quickswap/IUniswapV2Router01.sol\";\n\nstruct QuickSwapLPInfo {\n    address[2] underlyingTokens;\n}\n\n/**\n * @title QuickSwapPolygonAdapter\n * @notice Adapter for QuickSwap LP token in Polygon.\n * @dev See ILPAdapter interface for full details.\n */\ncontract QuickSwapPolygonAdapter is SuAuthenticated, ILPAdapter {\n    mapping(address => QuickSwapLPInfo) private lps; // Mapping from LP token to pool\n    ISuOracle public ORACLE;\n    address public ROUTER;\n\n    function initialize(address _authControl, address _oracle) public initializer {\n        __suAuthenticatedInit(_authControl);\n        ORACLE = ISuOracle(_oracle);\n        ROUTER = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;\n    }\n\n    /**\n      * @notice Register the given LP token address and set the LP underlyingTokens\n      * @param lp address of LP token\n     **/\n    function registerLP(address lp) external onlyAdmin {\n        lps[lp].underlyingTokens[0] = IUniswapV2Pair(lp).token0();\n        lps[lp].underlyingTokens[1] = IUniswapV2Pair(lp).token1();\n    }\n\n    function isAdapterLP(address asset) public view returns (bool) {\n        return lps[asset].underlyingTokens[0] != address(0);\n    }\n\n    function getFiatPrice1e18(address asset) external view returns (uint256) {\n        revert LPOracleNotReady();\n        // Below it's unsafe oracle implementation\n//        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n//        QuickSwapLPInfo memory lpInfo = lps[asset];\n//\n//        (uint112 _reserve0, uint112 _reserve1,) = IUniswapV2Pair(asset).getReserves();\n//        uint256 sumBalances = _reserve0 * ORACLE.getFiatPrice1e18(lpInfo.underlyingTokens[0])\n//            + _reserve1 * ORACLE.getFiatPrice1e18(lpInfo.underlyingTokens[1]);\n//\n//        return sumBalances / IUniswapV2Pair(asset).totalSupply();\n    }\n\n    function withdraw(address asset, uint256 amount) external returns (WithdrawResult[] memory results) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount);\n        QuickSwapLPInfo memory lpInfo = lps[asset];\n\n        results = new WithdrawResult[](2);\n\n        if (IUniswapV2Pair(asset).allowance(address(this), ROUTER) < amount) {\n            IERC20(asset).approve(ROUTER, amount);\n        }\n\n        uint256[2] memory balancesBefore = [\n            IERC20(lpInfo.underlyingTokens[0]).balanceOf(address(this)),\n            IERC20(lpInfo.underlyingTokens[1]).balanceOf(address(this))\n        ];\n\n        IUniswapV2Router01(ROUTER).removeLiquidity(\n            lpInfo.underlyingTokens[0],\n            lpInfo.underlyingTokens[1],\n            amount,\n            0, // we can set amountAMin to 0 because it's used only in 1 line: require(amountA >= amountAMin, '...');\n            0, // the same for amountBMin\n            address(this), // In future we can decrease transfers and unwrap directly to user\n            block.timestamp\n        );\n\n        for (uint i = 0; i < 2; ++i) {\n            address underlyingToken = lpInfo.underlyingTokens[i];\n            uint256 underlineTokenAmount = IERC20(underlyingToken).balanceOf(address(this)) - balancesBefore[i];\n            results[i] = WithdrawResult({ token: underlyingToken, amount: underlineTokenAmount });\n            TransferHelper.safeTransfer(underlyingToken, msg.sender, underlineTokenAmount);\n        }\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/periphery/contracts/adapters/PendleAdapter.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"@pendle/core-v2/contracts/oracles/PendleLpOracleLib.sol\";\nimport \"@pendle/core-v2/contracts/offchain-helpers/BoringLpSeller.sol\";\n\nimport \"../access-control/SuAuthenticated.sol\";\nimport \"../interfaces/adapters/ILPAdapter.sol\";\nimport \"../interfaces/oracle/ISuOracleAggregator.sol\";\n\n/**\n * @title PendleLPInfo\n * @notice Struct with info about each  Pendle LP\n * @param market - address of LPs market (maybe can be removed, because LP address == market address)\n * @param SY - StandardizedYield, we need it to get underlyingTokens and best token to get after unwrap\n * @param PT - PrincipalToken, we need it only to check getFiatPrice1e18Unsafe, can be deleted\n * @param YT - YieldToken, we need it only to check getFiatPrice1e18Unsafe, can be deleted\n * @param underlyingTokens - all tokens that we can receive after unwrapping LP\n * @param mainUnderlyingToken - main LPs underlying token, rate in getFiatPrice is calculated in this token\n */\nstruct PendleLPInfo {\n    IPMarket market;\n    IStandardizedYield SY;\n    IPPrincipalToken PT;\n    IPYieldToken YT;\n    address[] underlyingTokens;\n    address mainUnderlyingToken;\n}\n\n/**\n * @title PendleAdapter\n * @notice Adapter for Pendle LP token.\n * @dev See ILPAdapter interface for full details.\n */\ncontract PendleAdapter is SuAuthenticated, ILPAdapter, BoringLpSeller {\n    using PendleLpOracleLib for IPMarket;\n\n    mapping(address => PendleLPInfo) public lps; // Mapping from LP token to pool\n    ISuOracleAggregator public ORACLE;\n\n    function initialize(address _authControl, address _oracle) public initializer {\n        __suAuthenticatedInit(_authControl);\n        ORACLE = ISuOracleAggregator(_oracle);\n    }\n\n    /**\n      * @notice Register the given LP token address and set the LP info\n      * @param lp address of LP token\n      * @param market market for LP token\n     **/\n    // Is LP == market?\n    function registerLP(address lp, IPMarket market, address mainUnderlyingToken) external onlyAdmin {\n        lps[lp].market = market;\n        (lps[lp].SY, lps[lp].PT, lps[lp].YT) = market.readTokens();\n        lps[lp].underlyingTokens = lps[lp].SY.getTokensOut();\n        lps[lp].mainUnderlyingToken = mainUnderlyingToken;\n    }\n\n    function isAdapterLP(address asset) public view returns (bool) {\n        return lps[asset].underlyingTokens.length != 0;\n    }\n\n    /// @notice Is depreceted, only for tests usage\n    function getFiatPrice1e18Unsafe(address asset) external view returns (uint256) {\n        PendleLPInfo memory lpInfo = lps[asset];\n\n        uint256 assetPrice = ORACLE.getFiatPrice1e18(lpInfo.SY.yieldToken());\n        uint256 underlyingTokensValue =\n            (IERC20(lpInfo.SY).balanceOf(asset)\n            + IERC20(lpInfo.PT).balanceOf(asset)\n            + IERC20(lpInfo.YT).balanceOf(asset)) * assetPrice;\n//        address[] memory rewardTokens = lpInfo.market.getRewardTokens();\n//        for (uint16 i = 0; i < rewardTokens.length; ++i) {\n//            address token = rewardTokens[i];\n//            underlyingTokensValue += IERC20(token).balanceOf(asset) * ORACLE.getFiatPrice1e18(token);\n//        }\n        return underlyingTokensValue / lpInfo.market.totalSupply();\n    }\n\n    function getFiatPrice1e18(address asset) external view returns (uint256) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        PendleLPInfo memory lpInfo = lps[asset];\n\n        uint256 lpRate = lpInfo.market.getLpToAssetRate(300); // TWAPDuration is 5min\n        uint256 assetPrice = ORACLE.getFiatPrice1e18(lpInfo.mainUnderlyingToken);\n        // TODO: check decimals\n        return assetPrice * lpRate / 1e18;\n    }\n\n    /**\n     * @notice Pendle unwrap LP only to 1 token, but our ILPAdapter is more general,\n     * so we need to return here the array of WithdrawResult.\n    **/\n    function withdraw(address asset, uint256 amount) external returns (WithdrawResult[] memory results) {\n        if (!isAdapterLP(asset)) revert IsNotLP(asset);\n        TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount);\n        PendleLPInfo memory lpInfo = lps[asset];\n\n        uint256 nTokens = lpInfo.underlyingTokens.length;\n        results = new WithdrawResult[](1);\n\n        // In other adapters there is the method that unwrap LP to all underlyingTokens,\n        // but here we have Pendle library, that can swap LP only for one token.\n        // So we need to check what token will have the best USD value. For that we need to multiply token price and\n        // amount we could receive after this swap.\n        // This swap in depth is doing by lpInfo.SY, so there is previewRedeem function to check this amount after swap.\n        address bestTokenOut;\n        uint256 bestTokenAmountOut;\n        for (uint16 i = 0; i < nTokens; ++i) {\n            address tokenToPreview = lpInfo.underlyingTokens[i];\n            if (ORACLE.hasPriceForAsset(tokenToPreview)) {\n                uint256 previewAmount =\n                    lpInfo.SY.previewRedeem(tokenToPreview, amount) * ORACLE.getFiatPrice1e18(tokenToPreview);\n                if (previewAmount > bestTokenAmountOut) {\n                    bestTokenAmountOut = previewAmount;\n                    bestTokenOut = tokenToPreview;\n                }\n            }\n        }\n\n        uint256 netTokenOut = _sellLpForToken(address(lpInfo.market), amount, bestTokenOut);\n\n        results[0] = WithdrawResult({ token: bestTokenOut, amount: netTokenOut });\n        TransferHelper.safeTransfer(bestTokenOut, msg.sender, netTokenOut);\n    }\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/periphery/contracts/interfaces/access-control/ISuAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"../../access-control/SuAccessRoles.sol\";\n\n/**\n * @notice Access control for contracts\n * @dev External interface of AccessControl declared to support ERC165 detection.\n **/\ninterface ISuAccessControl is IAccessControlUpgradeable, IERC165Upgradeable {\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n}\n"
    },
    "contracts/periphery/contracts/interfaces/adapters/deprecated/IBalancerPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface for querying historical data from a Pool that can be used as a Price Oracle.\n *\n * This lets third parties retrieve average prices of tokens held by a Pool over a given period of time, as well as the\n * price of the Pool share token (BPT) and invariant. Since the invariant is a sensible measure of Pool liquidity, it\n * can be used to compare two different price sources, and choose the most liquid one.\n *\n * Once the oracle is fully initialized, all queries are guaranteed to succeed as long as they require no data that\n * is not older than the largest safe query window.\n */\ninterface IBalancerPriceOracle {\n    // The three values that can be queried:\n    //\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n    //\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n    //\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\n    enum Variable { PAIR_PRICE, BPT_PRICE, INVARIANT }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n    external\n    view\n    returns (uint256[] memory results);\n\n    /**\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\n     */\n    function getLatest(Variable variable) external view returns (uint256);\n\n    /**\n     * @dev Information for a Time Weighted Average query.\n     *\n     * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\n     * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\n     * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\n     */\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    /**\n     * @dev Returns largest time window that can be safely queried, where 'safely' means the Oracle is guaranteed to be\n     * able to produce a result and not revert.\n     *\n     * If a query has a non-zero `ago` value, then `secs + ago` (the oldest point in time) must be smaller than this\n     * value for 'safe' queries.\n     */\n    function getLargestSafeQueryWindow() external view returns (uint256);\n\n    /**\n     * @dev Returns the accumulators corresponding to each of `queries`.\n     */\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n    external\n    view\n    returns (int256[] memory results);\n\n    /**\n     * @dev Information for an Accumulator query.\n     *\n     * Each query estimates the accumulator at a time `ago` seconds ago.\n     */\n    struct OracleAccumulatorQuery {\n        Variable variable;\n        uint256 ago;\n    }\n}"
    },
    "contracts/periphery/contracts/interfaces/adapters/IBasePoolExtended.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../vendor/balancer/IVault.sol\";\n\n// We use that because BasePool use solidity 0.7.0 and we don't need whole implementation, only interface\n// We also don't import \"@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol\"\n// because it's a problem with their copy of IERC20.\ninterface IBasePoolExtended is IERC20 {\n    /**\n     * @dev Returns this Pool's ID, used when interacting with the Vault (to e.g. join the Pool or swap with it).\n     */\n    function getPoolId() external view returns (bytes32);\n\n    /**\n     * @notice Returns the Balancer Vault\n     */\n    function getVault() external view returns (IVault);\n}"
    },
    "contracts/periphery/contracts/interfaces/adapters/ILPAdapter.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"../oracle/ISuOracle.sol\";\n\nstruct WithdrawResult {\n    address token;\n    uint256 amount;\n}\n\ninterface ILPAdapter is ISuOracle {\n    /* ======================== ERRORS ======================== */\n    error IsNotLP(address asset);\n    error AlreadyRegistered(address asset);\n    error LPOracleNotReady();\n\n    /* ==================== MUTABLE METHODS ==================== */\n    /**\n      * @notice Unwrap LP token with depth = 2 (if underlying token is LP => it's also unwrapping)\n      * @param asset - address of LP token to withdraw/unwrap\n      * @param amount - amount of asset to withdraw/unwrap\n     **/\n    function withdraw(address asset, uint256 amount) external returns (WithdrawResult[] memory);\n\n    /* ====================== VIEW METHODS ==================== */\n    /**\n      * @notice Returns if asset ig Balancer LP token, registered in our adapter\n      * @param asset - address of LP token to check\n     **/\n    function isAdapterLP(address asset) external returns (bool);\n}"
    },
    "contracts/periphery/contracts/interfaces/adapters/IWeightedPool.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nimport \"./IBasePoolExtended.sol\";\n\n/**\n * @notice Interface for weighted pool that have 2 methods we need in flash-loan-safe Oracle\n */\ninterface IWeightedPool is IBasePoolExtended {\n    /**\n     * @notice Returns all normalized weights, in the same order as the Pool's tokens.\n     */\n    function getNormalizedWeights() external view returns (uint256[] memory);\n\n    /**\n     * @notice Is for weighted pool\n     */\n    function getLastInvariant() external view returns (uint256);\n}"
    },
    "contracts/periphery/contracts/interfaces/oracle/ISuChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./ISuOracle.sol\";\n\ninterface ISuChainlinkOracle is ISuOracle {\n    /* ===================== ERRORS ===================== */\n    error BadPriceAnswer();\n\n    /* ====================== VARS ====================== */\n    /**\n     * @notice Data feeds addresses from https://docs.chain.link/docs/ethereum-addresses/#Goerli%20Testnet\n     * each chainlink data feed has own decimals, see the link above\n     **/\n    function assetToFeed (address asset) external view returns ( address );\n    function assetToFeedDecimals (address asset) external view returns ( uint8 );\n\n    /* ==================== METHODS ==================== */\n    function setAssetFeed(address asset, address chainlinkDataFeed, uint8 chainlinkDataFeedDecimals) external;\n\n    function setPriceBase(address asset, bool _isPriceInETH) external;\n}\n"
    },
    "contracts/periphery/contracts/interfaces/oracle/ISuOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// solhint-disable compiler-version\npragma solidity >=0.7.6;\n\ninterface ISuOracle {\n    /**\n     * @notice WARNING! Read this description very carefully!\n     *     function getFiatPrice1e18(address asset) returns (uint256) that:\n     *         basicAmountOfAsset * getFiatPrice1e18(asset) / 1e18 === $$ * 1e18\n     *     in other words, it doesn't matter what's the erc20.decimals is,\n     *     you just multiply token balance in basic units on value from oracle and get dollar amount multiplied on 1e18.\n     *\n     * different assets have different deviation threshold (errors)\n     *     for wBTC it's <= 0.5%, read more https://data.chain.link/ethereum/mainnet/crypto-usd/btc-usd\n     *     for other asset is can be larger based on particular oracle implementation.\n     *\n     * examples:\n     *     market price of btc = $30k,\n     *     for 0.1 wBTC the unit256 amount is 0.1 * 1e18\n     *     0.1 * 1e18 * (price1e18 / 1e18) == $3000 == uint256(3000*1e18)\n     *     => price1e18 = 30000 * 1e18;\n     *\n     *     market price of usdt = $0.97,\n     *     for 1 usdt uint256 = 1 * 1e6\n     *     so 1*1e6 * price1e18 / 1e18 == $0.97 == uint256(0.97*1e18)\n     *     => 1*1e6 * (price1e18 / 1e18) / (0.97*1e18)   = 1\n     *     =>  price1e18 = 0.97 * (1e18/1e6) * 1e18\n     *\n     *    assume market price of wBTC = $31,503.77, oracle error = $158\n     *\n     *     case #1: small amount of wBTC\n     *         we have 0.0,000,001 wBTC that is worth v = $0.00315  $0.00001 = 0.00315*1e18 = 315*1e13  1*1e13\n     *         actual balance on the asset b = wBTC.balanceOf() =  0.0000001*1e18 = 1e11\n     *         oracle should return or = oracle.getFiatPrice1e18(wBTC) <=>\n     *         <=> b*or = v => v/b = 315*1e13 / 1e11 = 315*1e2  1e2\n     *         error = or.error * b = 1e2 * 1e11 = 1e13 => 1e13/1e18 usd = 1e-5 = 0.00001 usd\n     *\n     *     case #2: large amount of wBTC\n     *         v = 2,000,000 wBTC = $31,503.77 * 2m  158*2m = $63,007,540,000  $316,000,000 = 63,007*1e24  316*1e24\n     *         for calc convenience we increase error on 0.05 and have v = 63,000*24  300*1e24 = (630  3)*1e26\n     *         b = 2*1e6 * 1e18 = 2*1e24\n     *         or = v/b = (630  3)*1e26 / 2*1e24 = 315*1e2  1.5*1e2\n     *         error = or.error * b = 1.5*100 * 2*1e24 = 3*1e26 = 3*1e8*1e18 = $300,000,000 ~ $316,000,000\n     *\n     *     assume the market price of USDT = $0.97  $0.00485,\n     *\n     *     case #3: little amount of USDT\n     *         v = USDT amount 0.005 = 0.005*(0.97  0.00485) = 0.00485*1e18  0.00002425*1e18 = 485*1e13  3*1e13\n     *         we rounded error up on (3000-2425)/2425 ~= +24% for calculation convenience.\n     *         b = USDT.balanceOf() = 0.005*1e6 = 5*1e3\n     *         b*or = v => or = v/b = (485*1e13  3*1e13) / 5*1e3 = 970*1e9  6*1e9\n     *         error = 6*1e9 * 5*1e3 / 1e18 = 30*1e12/1e18 = 3*1e-5 = $0,00005\n     *\n     *     case #4: lot of USDT\n     *         v = we have 100,000,000,000 USDT = $97B = 97*1e9*1e18  0.5*1e9*1e18\n     *         b = USDT.balanceOf() = 1e11*1e6 = 1e17\n     *         or = v/b = (97*1e9*1e18  0.5*1e9*1e18) / 1e17 = 970*1e9  5*1e9\n     *         error = 5*1e9 * 1e17 = 5*1e26 = 0.5 * 1e8*1e18\n     *\n     * @param asset - address of erc20 token contract\n     * @return usdPrice1e18 such that asset.balanceOf() * getFiatPrice1e18(asset) / 1e18 == $$ * 1e18\n     **/\n    function getFiatPrice1e18(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/periphery/contracts/interfaces/oracle/ISuOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./ISuOracle.sol\";\n\ninterface ISuOracleAggregator is ISuOracle {\n    /* ===================== ERRORS ===================== */\n    error NoOracleFound(address asset);\n    error NoOracleImplementation();\n    error BadOracleId();\n\n    /* ====================== VARS ====================== */\n    function assetToOracle (address asset) external view returns ( uint256 );\n    function oracleImplementations (uint256 oracleId) external view returns ( ISuOracle );\n\n    /* ==================== METHODS ==================== */\n    /**\n       * @notice assign address of oracle implementation to the oracleId\n    * @param oracleId - number 0,1, etc to assign the oracle\n    * @param oracleImplementation - an address with ISuOracle implementation contract\n    **/\n    function setOracleImplementation(uint256 oracleId, ISuOracle oracleImplementation) external;\n\n    /**\n    * @notice specify what oracleId should be used for each assets. Checks that oracleId has an implementation\n    **/\n    function setOracleIdForAssets(address[] memory assets, uint256 oracleId) external;\n\n    /* ==================== VIEW METHODS ==================== */\n    /**\n    * @return true if oracle is set to this asset, false otherwise\n    **/\n    function hasPriceForAsset(address asset) external view returns(bool);\n}\n"
    },
    "contracts/periphery/contracts/interfaces/oracle/ISuUniV3Oracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"./ISuOracle.sol\";\n\n/**\n * @title SuUniV3Oracle\n * @dev SuUniV3Oracle is an implementation of the SuOracle interface for UniswapV3.\n **/\ninterface ISuUniV3Oracle is ISuOracle {\n    /* ===================== ERRORS ===================== */\n    error InvalidToken();\n\n    /* ====================== VARS ====================== */\n    function assetToPool (address asset) external view returns ( IUniswapV3Pool );\n\n    /* ==================== METHODS ==================== */\n    function enableAssetPool(address _asset, uint24 _fee) external;\n}\n"
    },
    "contracts/periphery/contracts/mocks/MockAuth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../access-control/SuAuthenticated.sol\";\n\n/**\n * @notice This Mock contract is to test some SuAuthenticated features.\n * For that we need some method with onlyRole modifier.\n * We have internal variable `a` that can be changed only by user with `SOME_NEW_ROLE` role.\n**/\ncontract MockAuth is SuAuthenticated {\n    uint256 internal a;\n    bytes32 public SOME_NEW_ROLE;\n\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n        a = 0;\n        SOME_NEW_ROLE = keccak256(\"SOME_NEW_ROLE\");\n    }\n\n    function changeA(uint256 _newValue) public onlyRole(SOME_NEW_ROLE) {\n        a = _newValue;\n    }\n\n    function getA() public view returns(uint256) {\n        return a;\n    }\n}\n"
    },
    "contracts/periphery/contracts/mocks/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/oracle/ISuOracle.sol\";\n\ncontract MockOracle is ISuOracle, Ownable {\n    mapping (address => uint256[]) assetsToPrices1e18;\n    string public constant FIAT_NAME = \"EUR\";\n\n    function getFiatPrice1e18(address asset) override external view returns (uint) {\n        uint256 len = assetsToPrices1e18[asset].length;\n        require(len > 0, \"MockOracle: asset isn't supported\");\n        return assetsToPrices1e18[asset][block.number % len];\n    }\n\n    function setFiatPrice1e18(address asset, uint256 price) public {\n        assetsToPrices1e18[asset] = [price];\n    }\n\n    function setFiatPrice1e18Array(address asset, uint256[] memory prices) public {\n        assetsToPrices1e18[asset] = prices;\n    }\n}\n"
    },
    "contracts/periphery/contracts/mocks/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// FluxAggregator\n// AggregatorV2V3Interface\ncontract MockV3Aggregator is AggregatorV3Interface {\n  uint256 override constant public version = 0;\n\n  uint8 override public decimals;\n  int256 public latestAnswer;\n  uint256 public latestTimestamp;\n  uint256 public latestRound;\n\n  mapping(uint256 => int256) public getAnswer;\n  mapping(uint256 => uint256) public getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(\n    uint8 _decimals,\n    int256 _initialAnswer\n  ) {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(\n    int256 _answer\n  ) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(\n    uint80 _roundId,\n    int256 _answer,\n    uint256 _timestamp,\n    uint256 _startedAt\n  ) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (\n      _roundId,\n      getAnswer[_roundId],\n      getStartedAt[_roundId],\n      getTimestamp[_roundId],\n      _roundId\n    );\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description()\n    external\n    pure\n    override\n    returns (string memory)\n  {\n    return \"\";\n  }  \n}"
    },
    "contracts/periphery/contracts/mocks/MockWBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract MockWBTC is ERC20 {\n    constructor() ERC20(\"test Wrapped Bitcoin\", \"tWBTC\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n}\n"
    },
    "contracts/periphery/contracts/mocks/SimpleFlashLoanOracleBalTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport \"../vendor/balancer/IVault.sol\";\nimport \"../vendor/balancer/WeightedPoolUserData.sol\";\nimport \"../vendor/aave/IAavePool.sol\";\nimport \"../interfaces/oracle/ISuOracle.sol\";\n\nstruct CallbackData {\n    address lpToken;\n    address lpVault;\n    address contractAddress;\n    bytes32 poolId;\n    address[] underlyingTokens;\n    address adapter;\n    uint256 tokenIndex;\n}\n\ninterface IAdapterUnsafePrice {\n    function getFiatPrice1e18Unsafe(address asset) external view returns (uint256);\n}\n\ncontract SimpleFlashLoanOracleBalTest {\n    address private AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\n    uint256 public priceAfterFlashLoan;\n    uint256 public priceUnsafeAfterFlashLoan;\n    ISuOracle public ORACLE;\n\n    constructor(address _oracle) {\n        ORACLE = ISuOracle(_oracle);\n    }\n\n    /**\n        @param lpToken Address of asset to check price of\n        @param lpVault Address of vault of LP token\n        @param poolId ID of pool of LP token\n        @param underlyingTokens Array of underlying tokens of LP token\n        @param assetToLoan Address of asset to loan\n        @param amountToLoan Amount of asset to loan\n    */\n    function checkLPOnFlashLoanAttack(\n        address lpToken,\n        address lpVault,\n        bytes32 poolId,\n        address[] memory underlyingTokens,\n        address assetToLoan,\n        uint256 amountToLoan,\n        uint256 tokenIndex,\n        address adapter\n    ) external {\n        bytes memory data = abi.encode(CallbackData({\n            lpToken: lpToken,\n            lpVault: lpVault,\n            poolId: poolId,\n            underlyingTokens: underlyingTokens,\n            adapter: adapter,\n            tokenIndex: tokenIndex,\n            contractAddress: address(this)\n        }));\n        IERC20(assetToLoan).approve(lpVault, amountToLoan);\n\n        IAavePool(AAVE_POOL).flashLoanSimple(address(this), assetToLoan, amountToLoan, data, 0);\n    }\n\n    function executeOperation(address asset, uint256 amount, uint256 fee, address sender, bytes calldata data) external returns (bool) {\n        CallbackData memory decoded = abi.decode(data, (CallbackData));\n\n        uint256 nTokens = decoded.underlyingTokens.length;\n        IAsset[] memory assets = new IAsset[](nTokens);\n        uint256[] memory maxAmountsIn = new uint[](nTokens);\n        uint256[] memory minAmountsOut = new uint[](nTokens);\n        for (uint16 i = 0; i < nTokens; ++i) {\n            assets[i] = IAsset(address(decoded.underlyingTokens[i]));\n            maxAmountsIn[i] = i == decoded.tokenIndex ? amount : 0;\n            minAmountsOut[i] = 0;\n        }\n\n        IVault(decoded.lpVault).joinPool(\n            decoded.poolId,\n            payable(decoded.contractAddress),\n            payable(decoded.contractAddress),\n            IVault.JoinPoolRequest({\n                assets: assets,\n                maxAmountsIn: maxAmountsIn,\n                userData: abi.encode(WeightedPoolUserData.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, 0),\n                fromInternalBalance: false\n            })\n        );\n        uint256 lpAmountAfterJoin = IERC20(decoded.lpToken).balanceOf(decoded.contractAddress);\n\n        priceAfterFlashLoan = ORACLE.getFiatPrice1e18(decoded.lpToken);\n        priceUnsafeAfterFlashLoan = IAdapterUnsafePrice(decoded.adapter).getFiatPrice1e18Unsafe(decoded.lpToken);\n\n        IVault(decoded.lpVault).exitPool(\n            decoded.poolId,\n            payable(decoded.contractAddress),\n            payable(decoded.contractAddress),\n            IVault.ExitPoolRequest({\n                assets: assets,\n                minAmountsOut: minAmountsOut,\n                userData: abi.encode(WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, lpAmountAfterJoin, decoded.tokenIndex),\n                toInternalBalance: false\n            })\n        );\n\n        TransferHelper.safeApprove(asset, AAVE_POOL, amount + fee);\n        return true;\n    }\n\n    function getPriceAfterFlashLoan() public view returns (uint256) {\n        return priceAfterFlashLoan;\n    }\n\n    function getUnsafePriceAfterFlashLoan() public view returns (uint256) {\n        return priceUnsafeAfterFlashLoan;\n    }\n}"
    },
    "contracts/periphery/contracts/mocks/SimpleFlashLoanOracleCrvTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport \"../vendor/balancer/WeightedPoolUserData.sol\";\nimport \"../vendor/aave/IAavePool.sol\";\nimport \"../vendor/curve/ICurveLP.sol\";\nimport \"../interfaces/oracle/ISuOracle.sol\";\n\nstruct CallbackData {\n    address lpToken;\n    address lpPool;\n    address contractAddress;\n    address adapter;\n}\n\ninterface IAdapterUnsafePrice {\n    function getFiatPrice1e18Unsafe(address asset) external view returns (uint256);\n}\n\ncontract SimpleFlashLoanOracleCrvTest {\n    address private AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\n    uint256 public priceAfterFlashLoan;\n    uint256 public priceUnsafeAfterFlashLoan;\n    ISuOracle public ORACLE;\n\n    constructor(address _oracle) {\n        ORACLE = ISuOracle(_oracle);\n    }\n\n    /**\n        @param lpToken Address of asset to check price of\n        @param lpPool Address of vault of LP token\n        @param assetToLoan Address of asset to loan\n        @param amountToLoan Amount of asset to loan\n    */\n    function checkLPOnFlashLoanAttack(\n        address lpToken,\n        address lpPool,\n        address assetToLoan,\n        uint256 amountToLoan,\n        address adapter\n    ) external {\n        bytes memory data = abi.encode(CallbackData({\n            lpToken: lpToken,\n            lpPool: lpPool,\n            adapter: adapter,\n            contractAddress: address(this)\n        }));\n        IERC20(assetToLoan).approve(lpPool, amountToLoan);\n\n        IAavePool(AAVE_POOL).flashLoanSimple(address(this), assetToLoan, amountToLoan, data, 0);\n    }\n\n    function executeOperation(address asset, uint256 amount, uint256 fee, address sender, bytes calldata data) external returns (bool) {\n        CallbackData memory decoded = abi.decode(data, (CallbackData));\n\n        uint256[3] memory amounts;\n        amounts[0] = amount;\n        amounts[1] = 0;\n        amounts[2] = 0;\n\n        ICurveLP(decoded.lpPool).add_liquidity(amounts, 0);\n        uint256 lpAmountAfterJoin = IERC20(decoded.lpToken).balanceOf(decoded.contractAddress);\n\n        priceAfterFlashLoan = ORACLE.getFiatPrice1e18(decoded.lpToken);\n        priceUnsafeAfterFlashLoan = IAdapterUnsafePrice(decoded.adapter).getFiatPrice1e18Unsafe(decoded.lpToken);\n\n        ICurveLP(decoded.lpPool).remove_liquidity_one_coin(lpAmountAfterJoin, 0, 0);\n\n        TransferHelper.safeApprove(asset, AAVE_POOL, amount + fee);\n        return true;\n    }\n\n    function getPriceAfterFlashLoan() public view returns (uint256) {\n        return priceAfterFlashLoan;\n    }\n\n    function getUnsafePriceAfterFlashLoan() public view returns (uint256) {\n        return priceUnsafeAfterFlashLoan;\n    }\n}"
    },
    "contracts/periphery/contracts/mocks/SimpleFlashLoanOraclePendleTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"@pendle/core-v2/contracts/interfaces/IPMarket.sol\";\n\nimport \"../interfaces/oracle/ISuOracle.sol\";\nimport \"../interfaces/adapters/ILPAdapter.sol\";\n\ninterface IAdapterUnsafePrice {\n    function getFiatPrice1e18Unsafe(address asset) external view returns (uint256);\n}\n\ncontract SimpleFlashLoanOraclePendleTest {\n    uint256 public priceAfterFlashLoan;\n    uint256 public priceUnsafeAfterFlashLoan;\n    ISuOracle public ORACLE;\n\n    constructor(address _oracle) {\n        ORACLE = ISuOracle(_oracle);\n    }\n\n    function increaseObservationsCardinalityNext(address market, uint16 duration) external {\n        IPMarket(market).increaseObservationsCardinalityNext(duration);\n    }\n\n    /**\n        @param lpToken Address of asset to check price of\n        @param lpAmount Amount of LP to withdraw\n        @param adapter Address of LP Adapter\n    */\n    function checkLPOnFlashLoanAttack(\n        address lpToken,\n        uint256 lpAmount,\n        address adapter\n    ) external {\n        IERC20(lpToken).approve(adapter, lpAmount);\n        ILPAdapter(adapter).withdraw(lpToken, lpAmount);\n        priceAfterFlashLoan = ORACLE.getFiatPrice1e18(lpToken);\n        priceUnsafeAfterFlashLoan = IAdapterUnsafePrice(adapter).getFiatPrice1e18Unsafe(lpToken);\n    }\n\n    function getPriceAfterFlashLoan() public view returns (uint256) {\n        return priceAfterFlashLoan;\n    }\n\n    function getUnsafePriceAfterFlashLoan() public view returns (uint256) {\n        return priceUnsafeAfterFlashLoan;\n    }\n}"
    },
    "contracts/periphery/contracts/oracle/SuChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/oracle/ISuChainlinkOracle.sol\";\nimport \"../access-control/SuAuthenticated.sol\";\n\n/**\n * @title SuChainlinkOracle\n * @notice Oracle that use Chainlink prices\n * @dev See ISuChainlinkOracle interface for full details.\n */\ncontract SuChainlinkOracle is ISuChainlinkOracle, SuAuthenticated {\n    mapping (address => address) public assetToFeed;\n    mapping (address => uint8) public assetToFeedDecimals;\n    mapping (address => bool) public isPriceInETH; // We need to know is the feed price in USD or in ETH\n\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n    }\n\n    function setPriceBase(address asset, bool _isPriceInETH) external onlyDAO {\n        isPriceInETH[asset] = _isPriceInETH;\n    }\n\n    function setAssetFeed(address asset, address chainlinkDataFeed, uint8 chainlinkDataFeedDecimals) external onlyDAO {\n        assetToFeed[asset] = chainlinkDataFeed;\n        // some decimals are different from real token decimals, so we need to store them\n        assetToFeedDecimals[asset] = chainlinkDataFeedDecimals;\n    }\n\n    function getFiatPrice1e18(address asset) public view returns (uint256) {\n        address feed = assetToFeed[asset];\n        uint8 decimals = assetToFeedDecimals[asset];\n        (\n        /*uint80 roundID*/,\n            int256 answer,\n        /*uint256 startedAt*/,\n        /*uint256 updatedAt*/,\n        /*uint80 answeredInRound*/\n        ) = AggregatorV3Interface(feed).latestRoundData();\n        if (answer <= 0) revert BadPriceAnswer();\n        // examples of answers and what we want to get:\n        // ETH/USD = 134165000000 = 1341.65*1e8 =>(want) 1341*1e18\n        // BTC/USD = 1928068190485 = 19,280.68190485*1e8 =>(want) 19k*1e18 * (18-8)[for asset decimals]\n        // USDC/USD = 99990000 = 0.99990000*1e8 =>(want) => 0.9(9) * 1e18 * (18-6)[for asset decimals]\n        int256 priceFeed1e18 = scalePrice(answer, decimals, 18);\n        if (asset == address(0)) {\n            return uint256(priceFeed1e18);\n        } else {\n            // TODO: add tests with different assets with different decimals in ETH\n            uint8 assetDecimals = IERC20Metadata(asset).decimals();\n            int256 scaledPrice1e18 = scalePrice(priceFeed1e18, assetDecimals, 18);\n            if (isPriceInETH[asset]) {\n                // address(0) mean ETH, that should be added in chainlink config\n                return uint256(scaledPrice1e18) * getFiatPrice1e18(address(0)) / 1e18;\n            } else {\n                return uint256(scaledPrice1e18);\n            }\n        }\n\n    }\n\n    function scalePrice(int256 _price, uint8 _priceDecimals, uint8 _decimals) internal pure returns (int256) {\n        if (_priceDecimals < _decimals) {\n            return _price * int256(10 ** uint256(_decimals - _priceDecimals));\n        } else if (_priceDecimals > _decimals) {\n            return _price / int256(10 ** uint256(_priceDecimals - _decimals));\n        }\n        return _price;\n    }\n}\n"
    },
    "contracts/periphery/contracts/oracle/SuOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\n/*\n    OracleAggregator aggregates several oracles inside, such as: getUsdPrice asset -> id -> call to implementation\n    We have several oracle implementations of ISuOracle (they are inside this folder)\n*/\n\nimport \"../access-control/SuAuthenticated.sol\";\nimport \"../interfaces/oracle/ISuOracleAggregator.sol\";\n\n/**\n * @title SuChainlinkOracle\n * @notice Oracle that aggregate all oracles, like router\n * @dev See ISuOracleAggregator interface for full details.\n */\ncontract SuOracleAggregator is ISuOracleAggregator, SuAuthenticated {\n    mapping (address => uint256) public assetToOracle;\n    mapping (uint256 => ISuOracle) public oracleImplementations;\n\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n    }\n\n    function hasPriceForAsset(address asset) public view returns (bool) {\n        return assetToOracle[asset] != 0;\n    }\n\n    function getFiatPrice1e18(address asset) external view returns (uint256) {\n        uint256 oracleId = assetToOracle[asset];\n        if (oracleId == 0) revert NoOracleFound(asset);\n        ISuOracle oracleImplementation = oracleImplementations[oracleId];\n        if (address(oracleImplementation) == address(0)) revert NoOracleImplementation();\n        return oracleImplementation.getFiatPrice1e18(asset);\n    }\n\n    function setOracleImplementation(uint256 oracleId, ISuOracle oracleImplementation) external onlyDAO {\n        if (oracleId == 0) revert BadOracleId();\n        if (address(oracleImplementation) == address(0)) revert NoOracleImplementation();\n        oracleImplementations[oracleId] = oracleImplementation;\n    }\n\n    function setOracleIdForAssets(address[] memory assets, uint256 oracleId) external onlyDAO {\n        if (address(oracleImplementations[oracleId]) == address(0)) revert NoOracleImplementation();\n        for (uint256 i = 0; i < assets.length; ++i) {\n            assetToOracle[assets[i]] = oracleId;\n        }\n    }\n}\n"
    },
    "contracts/periphery/contracts/oracle/SuUniV3Oracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"../vendor/uniswap/PoolAddress.sol\";\nimport \"../vendor/uniswap/OracleLibrary.sol\";\nimport \"../interfaces/oracle/ISuUniV3Oracle.sol\";\nimport \"../access-control/SuAuthenticated.sol\";\n\n/**\n * @notice check SuUniV3Oracle section in ORACLE_ARCHITECTURE.md\n * @dev Here we calculate only the price of asset in USDT, not USD.\n * Before that we need to enableAssetPool, to know what pool use for that asset (what fees).\n * See ISuUniV3Oracle interface for full details.\n**/\ncontract SuUniV3Oracle is SuAuthenticated, ISuUniV3Oracle {\n    mapping (address => IUniswapV3Pool) public override assetToPool;\n\n    address public UNISWAP_FACTORY;\n    address public USDT;\n    address public ORACLE;\n\n    function initialize(\n        address _authControl,\n        address _UNISWAP_FACTORY,\n        address _USDT,\n        address _ORACLE\n    ) public initializer {\n        __suAuthenticatedInit(_authControl);\n        UNISWAP_FACTORY = _UNISWAP_FACTORY;\n        USDT = _USDT;\n        ORACLE = _ORACLE;\n    }\n\n    function getPool(address _asset, uint24 _fee) internal view returns (IUniswapV3Pool pool) {\n        pool = IUniswapV3Pool(PoolAddress.computeAddress(UNISWAP_FACTORY, PoolAddress.getPoolKey(_asset, USDT, _fee)));\n    }\n\n    function enableAssetPool(address _asset, uint24 _fee) external override onlyAdmin {\n        assetToPool[_asset] = getPool(_asset, _fee);\n    }\n\n    function getFiatPrice1e18(address asset) public override view returns (uint256) {\n        return ISuOracle(ORACLE).getFiatPrice1e18(USDT) * estimateAmountOut(assetToPool[asset], asset, 1e18, 10) / 1e18;\n    }\n\n    function estimateAmountOut(\n        IUniswapV3Pool pool,\n        address tokenIn,\n        uint128 amountIn,\n        uint32 secondsAgo\n    ) internal view returns (uint256 amountOut) {\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n        if (tokenIn != token0 && tokenIn != token1) revert InvalidToken();\n\n        address tokenOut = tokenIn == token0 ? token1 : token0;\n\n        // (int24 tick, ) = OracleLibrary.consult(pool, secondsAgo);\n        // Gas optimization: code copied from OracleLibrary.sol, consult()\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        int24 tick = int24(tickCumulativesDelta / int56(uint56(secondsAgo)));\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0)) tick--;\n\n        amountOut = OracleLibrary.getQuoteAtTick(\n            tick,\n            amountIn,\n            tokenIn,\n            tokenOut\n        );\n    }\n}\n"
    },
    "contracts/periphery/contracts/vendor/aave/IAavePool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n// import {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n// import {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IAavePool {\n    /**\n     * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n    event MintUnbacked(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n    event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n    /**\n     * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n    event Supply(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n//    event Borrow(\n//        address indexed reserve,\n//        address user,\n//        address indexed onBehalfOf,\n//        uint256 amount,\n//        DataTypes.InterestRateMode interestRateMode,\n//        uint256 borrowRate,\n//        uint16 indexed referralCode\n//    );\n\n    /**\n     * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n    event Repay(\n        address indexed reserve,\n        address indexed user,\n        address indexed repayer,\n        uint256 amount,\n        bool useATokens\n    );\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n//    event SwapBorrowRateMode(\n//        address indexed reserve,\n//        address indexed user,\n//        DataTypes.InterestRateMode interestRateMode\n//    );\n\n    /**\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n    /**\n     * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n    event UserEModeSet(address indexed user, uint8 categoryId);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n//    event FlashLoan(\n//        address indexed target,\n//        address initiator,\n//        address indexed asset,\n//        uint256 amount,\n//        DataTypes.InterestRateMode interestRateMode,\n//        uint256 premium,\n//        uint16 indexed referralCode\n//    );\n\n    /**\n     * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n    /**\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n    function mintUnbacked(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n    function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    /**\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n\n    /**\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n    /**\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external returns (uint256);\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n    function repayWithATokens(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n    function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n    /**\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n    function getUserAccountData(\n        address user\n    )\n    external\n    view\n    returns (\n        uint256 totalCollateralBase,\n        uint256 totalDebtBase,\n        uint256 availableBorrowsBase,\n        uint256 currentLiquidationThreshold,\n        uint256 ltv,\n        uint256 healthFactor\n    );\n\n    /**\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n    function initReserve(\n        address asset,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n    function dropReserve(address asset) external;\n\n    /**\n     * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address rateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n//    function setConfiguration(\n//        address asset,\n//        DataTypes.ReserveConfigurationMap calldata configuration\n//    ) external;\n\n    /**\n     * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n//    function getConfiguration(\n//        address asset\n//    ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n//    function getUserConfiguration(\n//        address user\n//    ) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n//    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    /**\n     * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external;\n\n    /**\n     * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n    function getReservesList() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n    function getReserveAddressById(uint16 id) external view returns (address);\n\n    /**\n     * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n    /**\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n    function updateFlashloanPremiums(\n        uint128 flashLoanPremiumTotal,\n        uint128 flashLoanPremiumToProtocol\n    ) external;\n\n    /**\n     * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n//    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n    /**\n     * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n//    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n    /**\n     * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n    function setUserEMode(uint8 categoryId) external;\n\n    /**\n     * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n    function getUserEMode(address user) external view returns (uint256);\n\n    /**\n     * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n    function resetIsolationModeTotalDebt(address asset) external;\n\n    /**\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n    /**\n     * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n    /**\n     * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n    /**\n     * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n    /**\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n    /**\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n    function mintToTreasury(address[] calldata assets) external;\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n    function rescueTokens(address token, address to, uint256 amount) external;\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "contracts/periphery/contracts/vendor/balancer/IAsset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}"
    },
    "contracts/periphery/contracts/vendor/balancer/IAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IAuthorizer {\n    /**\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\n     */\n    function canPerform(\n        bytes32 actionId,\n        address account,\n        address where\n    ) external view returns (bool);\n}"
    },
    "contracts/periphery/contracts/vendor/balancer/IFlashLoanRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\n// Inspired by Aave Protocol's IFlashLoanReceiver.\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IFlashLoanRecipient {\n    /**\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\n     *\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\n     * Vault, or else the entire flash loan will revert.\n     *\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) external;\n}"
    },
    "contracts/periphery/contracts/vendor/balancer/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport \"./IWETH.sol\";\nimport \"./IAsset.sol\";\nimport \"./IAuthorizer.sol\";\nimport \"./IFlashLoanRecipient.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don't override one of these declarations.\n */\ninterface IVault {\n    // Generalities about the Vault:\n    //\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\n    //\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\n    //\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\n\n    // Authorizer\n    //\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\n    // can perform a given action.\n\n    /**\n     * @dev Returns the Vault's Authorizer.\n     */\n    function getAuthorizer() external view returns (IAuthorizer);\n\n    /**\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\n     *\n     * Emits an `AuthorizerChanged` event.\n     */\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\n\n    /**\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\n     */\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\n\n    // Relayers\n    //\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\n    // this power, two things must occur:\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\n    //    functions.\n    //  - Each user must approve the relayer to act on their behalf.\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\n\n    /**\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\n     */\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n    /**\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\n     *\n     * Emits a `RelayerApprovalChanged` event.\n     */\n    function setRelayerApproval(\n        address sender,\n        address relayer,\n        bool approved\n    ) external;\n\n    /**\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\n     */\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user's Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\n\n    /**\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n    /**\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n    // Pools\n    //\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n    // functionality:\n    //\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n    // which increase with the number of registered tokens.\n    //\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n    // independent of the number of registered tokens.\n    //\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n\n    /**\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n    /**\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n    /**\n     * @dev Returns a Pool's contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    /**\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external;\n\n    /**\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n    /**\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n\n    /**\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n    /**\n     * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n    external\n    view\n    returns (\n        uint256 cash,\n        uint256 managed,\n        uint256 lastChangeBlock,\n        address assetManager\n    );\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n    external\n    view\n    returns (\n        IERC20[] memory tokens,\n        uint256[] memory balances,\n        uint256 lastChangeBlock\n    );\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n    event PoolBalanceChanged(\n        bytes32 indexed poolId,\n        address indexed liquidityProvider,\n        IERC20[] tokens,\n        int256[] deltas,\n        uint256[] protocolFeeAmounts\n    );\n\n    enum PoolBalanceChangeKind { JOIN, EXIT }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool's internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    // Flash Loans\n\n    /**\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\n     *\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\n     * for each token contract. `tokens` must be sorted in ascending order.\n     *\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\n     * `receiveFlashLoan` call.\n     *\n     * Emits `FlashLoan` events.\n     */\n    function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n\n    /**\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\n     */\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\n\n    // Asset Management\n    //\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\n    //\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\n    //\n    // This concept is unrelated to the IAsset interface.\n\n    /**\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\n     *\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\n     * operations of different kinds, with different Pools and tokens, at once.\n     *\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\n     */\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n    struct PoolBalanceOp {\n        PoolBalanceOpKind kind;\n        bytes32 poolId;\n        IERC20 token;\n        uint256 amount;\n    }\n\n    /**\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\n     *\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\n     *\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\n     */\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\n\n    /**\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\n     */\n    event PoolBalanceManaged(\n        bytes32 indexed poolId,\n        address indexed assetManager,\n        IERC20 indexed token,\n        int256 cashDelta,\n        int256 managedDelta\n    );\n\n    // Protocol Fees\n    //\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\n    // permissioned accounts.\n    //\n    // There are two kinds of protocol fees:\n    //\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\n    //\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\n    // exiting a Pool in debt without first paying their share.\n\n//    /**\n//     * @dev Returns the current protocol fee module.\n//     */\n//    function getProtocolFeesCollector() external view returns (ProtocolFeesCollector);\n\n    /**\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\n     * error in some part of the system.\n     *\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\n     *\n     * While the contract is paused, the following features are disabled:\n     * - depositing and transferring internal balance\n     * - transferring external balance (using the Vault's allowance)\n     * - swaps\n     * - joining Pools\n     * - Asset Manager interactions\n     *\n     * Internal Balance can still be withdrawn, and Pools exited.\n     */\n    function setPaused(bool paused) external;\n\n    /**\n     * @dev Returns the Vault's WETH instance.\n     */\n    function WETH() external view returns (IWETH);\n    // solhint-disable-previous-line func-name-mixedcase\n}\n"
    },
    "contracts/periphery/contracts/vendor/balancer/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Interface for the WETH token contract used internally for wrapping and unwrapping, to support\n * sending and receiving ETH in joins, swaps, and internal balance deposits and withdrawals.\n */\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/periphery/contracts/vendor/balancer/WeightedPoolUserData.sol": {
      "content": "//copied from node_modules/@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol,\n// but import of custom IERC20 removed\n// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary WeightedPoolUserData {\n    // In order to preserve backwards compatibility, make sure new join and exit kinds are added at the end of the enum.\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT, ALL_TOKENS_IN_FOR_EXACT_BPT_OUT }\n    enum ExitKind { EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT }\n\n    function joinKind(bytes memory self) internal pure returns (JoinKind) {\n        return abi.decode(self, (JoinKind));\n    }\n\n    function exitKind(bytes memory self) internal pure returns (ExitKind) {\n        return abi.decode(self, (ExitKind));\n    }\n\n    // Joins\n\n    function initialAmountsIn(bytes memory self) internal pure returns (uint256[] memory amountsIn) {\n        (, amountsIn) = abi.decode(self, (JoinKind, uint256[]));\n    }\n\n    function exactTokensInForBptOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsIn, uint256 minBPTAmountOut)\n    {\n        (, amountsIn, minBPTAmountOut) = abi.decode(self, (JoinKind, uint256[], uint256));\n    }\n\n    function tokenInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut, uint256 tokenIndex) {\n        (, bptAmountOut, tokenIndex) = abi.decode(self, (JoinKind, uint256, uint256));\n    }\n\n    function allTokensInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut) {\n        (, bptAmountOut) = abi.decode(self, (JoinKind, uint256));\n    }\n\n    // Exits\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (ExitKind, uint256, uint256));\n    }\n\n    function exactBptInForTokensOut(bytes memory self) internal pure returns (uint256 bptAmountIn) {\n        (, bptAmountIn) = abi.decode(self, (ExitKind, uint256));\n    }\n\n    function bptInForExactTokensOut(bytes memory self)\n        internal\n        pure\n        returns (uint256[] memory amountsOut, uint256 maxBPTAmountIn)\n    {\n        (, amountsOut, maxBPTAmountIn) = abi.decode(self, (ExitKind, uint256[], uint256));\n    }\n}\n"
    },
    "contracts/periphery/contracts/vendor/curve/ICurveLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICurveLP {\n    function add_liquidity(uint256[2] memory, uint256) external;\n    function add_liquidity(uint256[3] memory, uint256) external;\n\n    function remove_liquidity(uint256, uint256[2] memory) external;\n    function remove_liquidity(uint256, uint256[3] memory) external;\n\n    // function remove_liquidity(uint256, uint256[3] memory) external returns (uint256[3] memory);\n\n    /// @notice Removes liquidity from the pool in a specified asset\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 minAmount) external;\n\n    function coins(uint256 i) external view returns (address);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function calc_add_one_coin(uint256[] memory amounts, bool deposit) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    // only for V2 Pools\n    function lp_price() external view returns (uint256);\n}\n"
    },
    "contracts/periphery/contracts/vendor/quickswap/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/periphery/contracts/vendor/quickswap/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/periphery/contracts/vendor/uniswap/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n        // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n            require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n        // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n        // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n        // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}"
    },
    "contracts/periphery/contracts/vendor/uniswap/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./FullMath.sol\";\nimport \"./TickMath.sol\";\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n    internal\n    view\n    returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = IUniswapV3Pool(pool)\n            .observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] -\n                        secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(secondsAgo)));\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations(\n            (observationIndex + 1) % observationCardinality\n        );\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        unchecked {\n            secondsAgo = uint32(block.timestamp) - observationTimestamp;\n        }\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (\n            uint32 observationTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n\n        ) = IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - int56(uint56(prevTickCumulative))) / int56(uint56(delta)));\n        uint128 liquidity = uint128(\n            (uint192(delta) * type(uint160).max) /\n            (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n        );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n    internal\n    pure\n    returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(uint256(weightedTickData[i].weight));\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n    internal\n    pure\n    returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}\n"
    },
    "contracts/periphery/contracts/vendor/uniswap/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/periphery/contracts/vendor/uniswap/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n        // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}"
    },
    "contracts/reward/RewardChefV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"../interfaces/IRewardChefV2.sol\";\nimport \"../periphery/contracts/access-control/SuAuthenticated.sol\";\nimport \"../periphery/contracts/interfaces/oracle/ISuOracle.sol\";\n\n/**\n * @title RewardChefV2\n * @dev See IRewardChefV2 interface for full details.\n**/\ncontract RewardChefV2 is IRewardChefV2, SuAuthenticated {\n    using SafeCastUpgradeable for uint256;\n    using SafeCastUpgradeable for uint128;\n    using SafeCastUpgradeable for uint64;\n    using SafeCastUpgradeable for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    /**\n     * @notice Info of each MCV2 pool. SuDAO: instead of pool Ids (pid) we use address of the asset directly.\n     * Also, there aren't just LPs but regular assets as well\n     **/\n    mapping(address => PoolInfo) public poolInfo;\n\n    /**\n     * @notice Info of each user that stakes tokens. userInfo[_asset][_user]\n     **/\n    mapping(address => mapping(address => UserInfo)) public userInfo;\n\n    uint256 public totalAllocPoint;\n\n    /**\n     * @notice Set of reward-able assets\n     **/\n    EnumerableSetUpgradeable.AddressSet private assetSet;\n    uint256 private constant ACC_REWARD_TOKEN_PRECISION = 1e12; // TODO*: make it 1e18? check values overflow\n\n    // ==========================REWARDER================================\n    IERC20Upgradeable public REWARD_TOKEN;\n    ISuOracle public ORACLE;\n    uint256 public rewardPerBlock;\n    uint256 public rewardEndBlock;\n\n    function refillReward(uint256 amount, uint64 endBlock) public onlyAdmin {\n        if (endBlock <= block.number) revert BadEndBlockForRefill();\n        updateAllPools(); // TODO: gas optimization\n\n        REWARD_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 rewardLeftAmount;\n        // if there are active rewards leftovers\n        if (rewardEndBlock > 0) {\n            // if we call refillReward before old endBlock ends\n            if (block.number < rewardEndBlock) {\n                rewardLeftAmount = rewardPerBlock * (rewardEndBlock - block.number);\n            } else {\n                // if we start the new reward interval that has nothing in common with the old noe\n                rewardLeftAmount = 0;\n            }\n        }\n        rewardPerBlock = (rewardLeftAmount + amount) / (endBlock - block.number);\n        rewardEndBlock = endBlock;\n    }\n\n    function rewardsBetweenBlocks(uint256 startBlock, uint256 endBlock) public view returns (uint256) {\n        // if all rewards were allocation before our range - then answer is 0\n        if (rewardEndBlock <= startBlock) {\n            return 0;\n        } else {\n            // if rewards allocates on the whole range, than just calc rectangle area\n            if (endBlock < rewardEndBlock) {\n                return (endBlock - startBlock) * rewardPerBlock;\n            } else {\n                // other-vice, rewards end its allocation during our rage, so we have to calc only until rewardEndBlock\n                return (rewardEndBlock - startBlock) * rewardPerBlock;\n            }\n        }\n    }\n\n    /* ==========================LOCKUP LOGIC========================================= */\n    mapping(uint256 => uint256) public multiplicator1e18ForLockupPeriod;\n    EnumerableSetUpgradeable.UintSet private possibleLockupPeriodsSeconds;\n\n    function getPossibleLockupPeriodsSeconds() external view returns (ILockupPeriod[] memory) {\n        uint256[] memory periods = possibleLockupPeriodsSeconds.values();\n        uint256 len = periods.length;\n        ILockupPeriod[] memory lockupPeriods = new ILockupPeriod[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            lockupPeriods[i] = ILockupPeriod({\n                lockupPeriodSeconds : periods[i],\n                multiplicator1e18 : multiplicator1e18ForLockupPeriod[periods[i]]\n            });\n        }\n        return lockupPeriods;\n    }\n\n    function setPossibleLockupPeriodsSeconds(uint256 lockupPeriodSeconds, uint256 multiplicator1e18) external onlyDAO {\n        if (lockupPeriodSeconds == 0) revert ZeroLockupPeriod();\n        multiplicator1e18ForLockupPeriod[lockupPeriodSeconds] = multiplicator1e18;\n        if (multiplicator1e18 == 0) {\n            possibleLockupPeriodsSeconds.remove(lockupPeriodSeconds);\n        } else {\n            possibleLockupPeriodsSeconds.add(lockupPeriodSeconds);\n        }\n    }\n    /* =================================================================== */\n\n    /**\n      * @notice _rewardToken The REWARD_TOKEN token contract address.\n     **/\n    function initialize(address _authControl, IERC20Upgradeable _rewardToken, ISuOracle _oracle) public initializer {\n        __suAuthenticatedInit(_authControl);\n\n        REWARD_TOKEN = _rewardToken;\n        ORACLE = _oracle;\n    }\n\n    function add(uint256 allocPoint, address _asset) public onlyAdmin {\n        if (poolInfo[_asset].lastRewardBlock != 0) revert PoolExist();\n\n        totalAllocPoint = totalAllocPoint + allocPoint;\n        assetSet.add(_asset);\n\n        poolInfo[_asset] = PoolInfo({\n            allocPoint : allocPoint.toUint64(),\n            lastRewardBlock : block.number.toUint64(),\n            accSushiPerShare : 0,\n            lpSupply : 0\n        });\n\n        emit LogPoolAddition(_asset, allocPoint);\n    }\n\n    function set(address _asset, uint256 _allocPoint) public onlyAdmin {\n        if (poolInfo[_asset].lastRewardBlock == 0) revert PoolNotExist();\n        // TODO: why was it in legal in MVC2 to call this function without mandatory update method?\n        updatePool(_asset);\n\n        uint64 oldAllocPoint = poolInfo[_asset].allocPoint;\n        totalAllocPoint = totalAllocPoint - oldAllocPoint + _allocPoint;\n        poolInfo[_asset].allocPoint = _allocPoint.toUint64();\n        if (_allocPoint == 0) {\n            // we don't need to call updatePool(_asset) again\n            // because the result of the second time call in the same block doesn't change anything\n            assetSet.remove(_asset);\n        } else if (oldAllocPoint == 0) {\n            // when pool exists, but asset was removed from assetSet\n            assetSet.add(_asset);\n        }\n        emit LogSetPool(_asset, _allocPoint);\n    }\n\n    function pendingSushi(address _asset, address _user) public view returns (uint256 pending) {\n        PoolInfo memory pool = poolInfo[_asset];\n        UserInfo memory user = userInfo[_asset][_user];\n        uint256 accSushiPerShare = pool.accSushiPerShare;\n        // we don't have real balances anymore, so instead of lpSupply = lpTokens[_pid].balanceOf(address(this));\n        // we use virtual total balance\n        uint256 lpSupply = poolInfo[_asset].lpSupply;\n        if (block.number > pool.lastRewardBlock && lpSupply != 0 && totalAllocPoint != 0) {\n            // then we need to get updated accSushiPerShare, similar as in updatePool\n            // totalSushiReward - how much reward were minted since last update pool.lastRewardBlock\n            uint256 totalSushiReward = rewardsBetweenBlocks(pool.lastRewardBlock, block.number);\n            uint256 poolSushiReward = totalSushiReward * pool.allocPoint / totalAllocPoint;\n            // account it into share value\n            accSushiPerShare = accSushiPerShare + (poolSushiReward * ACC_REWARD_TOKEN_PRECISION / lpSupply);\n        }\n        pending = (\n            (user.amount * accSushiPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256() - user.rewardDebt\n        ).toUint256();\n    }\n\n    function updatePool(address asset) public returns (PoolInfo memory pool) {\n        pool = poolInfo[asset];\n        if (block.number > pool.lastRewardBlock) {\n            uint256 lpSupply = pool.lpSupply;\n            if (lpSupply > 0 && pool.allocPoint > 0) {\n                // calc how much rewards are minted since pool.lastRewardBlock for the pool\n                uint256 totalSushiReward = rewardsBetweenBlocks(pool.lastRewardBlock, block.number);\n                uint256 poolSushiReward = totalSushiReward * pool.allocPoint / totalAllocPoint;\n                pool.accSushiPerShare = pool.accSushiPerShare +\n                            (poolSushiReward * ACC_REWARD_TOKEN_PRECISION / lpSupply).toUint128();\n            }\n            pool.lastRewardBlock = block.number.toUint64();\n            poolInfo[asset] = pool;\n            emit LogUpdatePool(asset, pool.lastRewardBlock, lpSupply, pool.accSushiPerShare);\n        }\n    }\n\n    function updateAllPools() public {\n        address[] memory assets = assetSet.values();\n        uint256 len = assets.length;\n        for (uint256 i = 0; i < len; ++i) {\n            updatePool(assets[i]);\n        }\n    }\n\n    function increaseAmount(\n        address asset,\n        address to,\n        uint256 amountEDecimal,\n        uint256 lockupPeriodSeconds\n    ) public onlyRewardAccess {\n        PoolInfo memory pool = updatePool(asset);\n        UserInfo storage user = userInfo[asset][to];\n\n        if (user.lockupPeriodSeconds == 0) {// it means there's no deposit yet\n            user.multiplicator1e18 = multiplicator1e18ForLockupPeriod[lockupPeriodSeconds];\n            user.lockupPeriodSeconds = lockupPeriodSeconds;\n            user.lockupStartTimestamp = block.timestamp;\n        } else if (user.lockupPeriodSeconds != lockupPeriodSeconds) revert DifferentLockup();\n\n        if (user.multiplicator1e18 == 0) revert ZeroMultiplicator();\n\n        // Effects\n        // user.amount = user.amount + amountEDecimal;\n        uint256 additionalAmount = amountEDecimal * user.multiplicator1e18 / 1e18;\n        user.amount = user.amount + additionalAmount;\n        user.rewardDebt = user.rewardDebt +\n                    (additionalAmount * pool.accSushiPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256();\n        // we don't need, since the balances are virtual\n        // lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\n        // but we need to calc total supply of virtual tokens\n        pool.lpSupply = pool.lpSupply + additionalAmount;\n        poolInfo[asset] = pool;\n\n        emit VirtualDeposit(to, asset, additionalAmount);\n    }\n\n    function decreaseAmount(address asset, address to, uint256 amountEDecimal) public onlyRewardAccess {\n        PoolInfo memory pool = updatePool(asset);\n        UserInfo storage user = userInfo[asset][to];\n\n        if (user.multiplicator1e18 == 0) revert ZeroMultiplicator();\n\n        // if we decreasing before time-lock is over => there is penalty\n        uint256 penalty = block.timestamp < user.lockupStartTimestamp + user.lockupPeriodSeconds\n            ? getDecreaseAmountRewardPenalty(asset, to, amountEDecimal)\n            : 0;\n\n        // Effects\n        uint256 subtractAmount = amountEDecimal * user.multiplicator1e18 / 1e18;\n        user.rewardDebt = user.rewardDebt -\n                    (subtractAmount * pool.accSushiPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256() +\n                            penalty.toInt256();\n        user.amount = user.amount - subtractAmount;\n\n        if (user.amount == 0 && user.rewardDebt == 0) {\n            // Reset lockupPeriod\n            user.lockupStartTimestamp = block.timestamp;\n            user.lockupPeriodSeconds = 0;\n            user.multiplicator1e18 = 0;\n        }\n\n        pool.lpSupply = pool.lpSupply - subtractAmount;\n        poolInfo[asset] = pool;\n\n        emit VirtualWithdraw(to, asset, subtractAmount);\n    }\n\n    function getDecreaseAmountRewardPenalty(\n        address asset, address to, uint256 amountEDecimal\n    ) public view returns (uint256) {\n        UserInfo memory user = userInfo[asset][to];\n\n        if (user.multiplicator1e18 == 0) {\n            return 0;\n        }\n\n        uint256 subtractAmount = amountEDecimal * user.multiplicator1e18 / 1e18;\n\n        uint256 pending = pendingSushi(asset, to);\n        return pending * subtractAmount / user.amount;\n    }\n\n    function harvest(address asset, address to, uint256 newLockupPeriodSeconds) public {\n        PoolInfo memory pool = updatePool(asset);\n        UserInfo storage user = userInfo[asset][msg.sender];\n\n        if (user.lockupStartTimestamp + user.lockupPeriodSeconds > block.timestamp) revert HarvestBeforeLockup();\n        if (user.multiplicator1e18 == 0) revert ZeroMultiplicator();\n\n        int256 accumulatedSushi = (user.amount * pool.accSushiPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256();\n        uint256 _pendingSushi = (accumulatedSushi - user.rewardDebt).toUint256();\n\n        // Effects\n        user.rewardDebt = accumulatedSushi;\n        // accumulatedSushi = user.rewardDebt + _pendingSushi;\n\n        // Interactions\n        if (_pendingSushi > 0) {\n            REWARD_TOKEN.safeTransfer(to, _pendingSushi);\n        }\n\n        // Reset lockupPeriod\n        user.lockupStartTimestamp = block.timestamp;\n        // it's possible to remove code duplicates by using signed amount, but for simplicity I'll leave as it is\n        uint256 newMultiplicator1e18 = multiplicator1e18ForLockupPeriod[newLockupPeriodSeconds];\n        if (newMultiplicator1e18 == 0) revert ZeroMultiplicator();\n        if (user.multiplicator1e18 < newMultiplicator1e18) {\n            // since multiplicator increases, we need to increase amount\n            uint256 additionalAmount = user.amount * newMultiplicator1e18 / user.multiplicator1e18 - user.amount;\n\n            user.amount = user.amount + additionalAmount;\n            user.rewardDebt = user.rewardDebt +\n                        (additionalAmount * pool.accSushiPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256();\n        } else if (user.multiplicator1e18 > newMultiplicator1e18) {\n            uint256 subtractAmount = user.amount - user.amount * newMultiplicator1e18 / user.multiplicator1e18;\n\n            user.rewardDebt = user.rewardDebt -\n                        (subtractAmount * pool.accSushiPerShare / ACC_REWARD_TOKEN_PRECISION).toInt256();\n            user.amount = user.amount - subtractAmount;\n        }\n        user.multiplicator1e18 = newMultiplicator1e18;\n\n        emit Harvest(msg.sender, asset, _pendingSushi);\n    }\n\n    function resetAmount(address asset, address to) public {\n        PoolInfo storage pool = poolInfo[asset];\n        UserInfo storage user = userInfo[asset][msg.sender];\n\n        uint256 userAmount = user.amount;\n        uint256 userLockupPeriodSeconds = user.lockupPeriodSeconds;\n\n        pool.lpSupply = pool.lpSupply - userAmount;\n        poolInfo[asset] = pool;\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        // Reset lockupPeriod\n        user.lockupStartTimestamp = block.timestamp;\n        user.lockupPeriodSeconds = 0;\n        user.multiplicator1e18 = 0;\n\n        emit ResetAmount(msg.sender, asset, to, userAmount, userLockupPeriodSeconds);\n    }\n\n    /* ================================VIEW METHODS====================================== */\n\n    function getPoolApr(address asset) public view returns (uint256) {\n        // We use require to directly show this messages in frontend\n        /* solhint-disable custom-errors */\n        require(poolInfo[asset].lpSupply != 0, \"RewardChef: Pool doesn't have liquidity\");\n        require(totalAllocPoint != 0, \"RewardChef: Total allocation point is 0\");\n        require(rewardEndBlock > block.number, \"RewardChef: Vesting is already finished\");\n        /* solhint-enable custom-errors */\n\n        uint256 rewardPerBlockForPool = rewardPerBlock * poolInfo[asset].allocPoint / totalAllocPoint;\n        uint256 rewardTokenPrice = ORACLE.getFiatPrice1e18(address(REWARD_TOKEN));\n        uint256 usdRewardYearForPool = rewardPerBlockForPool * 4 * 60 * 24 * 366 * rewardTokenPrice;\n        // TODO: fix decimals and unify oracle answer\n        uint256 decimals = IERC20Metadata(asset).decimals();\n        uint256 usdValuePool = ORACLE.getFiatPrice1e18(asset) * poolInfo[asset].lpSupply / 10 ** decimals;\n        return usdRewardYearForPool / usdValuePool;\n    }\n\n    function getHarvestLockupEndTimestamp(address _asset, address _user) public view returns (uint256) {\n        UserInfo memory user = userInfo[_asset][_user];\n\n        return user.lockupStartTimestamp + user.lockupPeriodSeconds;\n    }\n}\n"
    },
    "contracts/StablePro.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"./periphery/contracts/access-control/SuAuthenticated.sol\";\nimport \"./gain-erc20/GainErc20v3Upgradeable.sol\";\n\n/**\n * @title StablePro\n * @notice ERC-20 token with GainableERC20 feature\n * @dev See GainableERC20v3Upgradeable contract for more details.\n**/\ncontract StablePro is GainableERC20v3Upgradeable {\n    function initialize(address _authControl) public initializer {\n        // TODO: rename on mainnet\n        __ERC20_init(_authControl, \"Some USD\", \"SomeUSD\");\n    }\n\n    /**\n      * @notice Only Vault can mint StablePro. Dollars can be minted by vault (once user deposited collateral)\n      * @dev Mints 'amount' of tokens to address 'to', and MUST fire the\n      * Transfer event\n      * @param to The address of the recipient\n      * @param amount The amount of token to be minted\n     **/\n    function mint(address to, uint256 amount) external onlyMintAccess {\n        _mint(to, amount);\n    }\n\n    /**\n     * @notice dollars can be burned by manager but only his own dollars\n     * which managers will be using this feature? burning protocol fees?\n     **/\n    function burn(uint256 amount) external onlyMintAccess {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @notice also vault is allowed to burn dollars of any account\n     * when user repays his loan and takes back his collateral\n     **/\n    function burn(address from, uint256 amount) external onlyMintAccess {\n        _burn(from, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}