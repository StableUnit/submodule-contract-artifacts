{
  "language": "Solidity",
  "sources": {
    "contracts/lib/ds-auth/src/auth.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(address(0))) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"
    },
    "contracts/lib/ds-note/src/note.sol": {
      "content": "/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        _;\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n    }\n}\n"
    },
    "contracts/makerdao/core/DssCdpManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// DssCdpManager.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.12;\n\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/IDssCdpManager.sol\";\n\ncontract CdpHandler {\n    constructor(ISafeEngine safeEngine) public {\n        safeEngine.approveSAFEModification(msg.sender);\n    }\n}\n\ncontract DssCdpManager is IDssCdpManager {\n    ISafeEngine               public safeEngine;\n    uint                      public cdpi;      // Auto incremental\n    mapping (uint => address) public safes;      // CDPId => CdpHandler\n    mapping (uint => List)    public list;      // CDPId => Prev & Next CDPIds (double linked list)\n    mapping (uint => address) public owns;      // CDPId => Owner\n    mapping (uint => bytes32) public collateralTypes;      // CDPId => CollateralType\n\n    mapping (address => uint) public firstCdpId;     // Owner => First CDPId\n    mapping (address => uint) public lastCdpId;      // Owner => Last CDPId\n    mapping (address => uint) public cdpCount;     // Owner => Amount of CDPs\n\n    mapping (\n        address => mapping (\n            uint => mapping (\n                address => uint\n            )\n        )\n    ) public cdpCan;                            // Owner => CDPId => Allowed Addr => True/False\n\n    mapping (\n        address => mapping (\n            address => uint\n        )\n    ) public handlerCan;                            // Cdp => Allowed Addr => True/False\n    \n    modifier cdpAllowed(uint cdp) {\n        require(msg.sender == owns[cdp] || cdpCan[owns[cdp]][cdp][msg.sender] == 1, \"cdp-not-allowed\");\n        _;\n    }\n\n    modifier handlerAlloweded(address urn) {\n        require(msg.sender == urn || handlerCan[urn][msg.sender] == 1, \"urn-not-allowed\");\n        _;\n    }\n\n    constructor(address safeEngine_) public {\n        safeEngine = ISafeEngine(safeEngine_);\n    }\n\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function _sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function toInt(uint x) internal pure returns (int y) {\n        y = int(x);\n        require(y >= 0);\n    }\n\n    function cdpAllow(uint cdp, address usr, uint ok) public override cdpAllowed(cdp) {\n        cdpCan[owns[cdp]][cdp][usr] = ok;\n    }\n\n    function allowHandler(address usr, uint ok) public override {\n        handlerCan[msg.sender][usr] = ok;\n    }\n\n    function openSafe(bytes32 collateralType, address usr) public override returns (uint) {\n        require(usr != address(0), \"usr-address-0\");\n\n        cdpi = _add(cdpi, 1);\n        safes[cdpi] = address(new CdpHandler(safeEngine));\n        owns[cdpi] = usr;\n        collateralTypes[cdpi] = collateralType;\n\n        // Add new CDP to double linked list and pointers\n        if (firstCdpId[usr] == 0) {\n            firstCdpId[usr] = cdpi;\n        }\n        if (lastCdpId[usr] != 0) {\n            list[cdpi].prev = lastCdpId[usr];\n            list[lastCdpId[usr]].next = cdpi;\n        }\n        lastCdpId[usr] = cdpi;\n        cdpCount[usr] = _add(cdpCount[usr], 1);\n\n        emit NewCdp(msg.sender, usr, cdpi);\n        return cdpi;\n    }\n\n    function transferSafeOwnership(uint cdp, address dst) public override cdpAllowed(cdp) {\n        require(dst != address(0), \"dst-address-0\");\n        require(dst != owns[cdp], \"dst-already-owner\");\n\n        // Remove transferred CDP from double linked list of origin user and pointers\n        if (list[cdp].prev != 0) {\n            list[list[cdp].prev].next = list[cdp].next;         // Set the next pointer of the prev cdp (if exists) to the next of the transferred one\n        }\n        if (list[cdp].next != 0) {                              // If wasn't the last one\n            list[list[cdp].next].prev = list[cdp].prev;         // Set the prev pointer of the next cdp to the prev of the transferred one\n        } else {                                                // If was the last one\n            lastCdpId[owns[cdp]] = list[cdp].prev;                   // Update last pointer of the owner\n        }\n        if (firstCdpId[owns[cdp]] == cdp) {                          // If was the first one\n            firstCdpId[owns[cdp]] = list[cdp].next;                  // Update first pointer of the owner\n        }\n        cdpCount[owns[cdp]] = _sub(cdpCount[owns[cdp]], 1);\n\n        // Transfer ownership\n        owns[cdp] = dst;\n\n        // Add transferred CDP to double linked list of destiny user and pointers\n        list[cdp].prev = lastCdpId[dst];\n        list[cdp].next = 0;\n        if (lastCdpId[dst] != 0) {\n            list[lastCdpId[dst]].next = cdp;\n        }\n        if (firstCdpId[dst] == 0) {\n            firstCdpId[dst] = cdp;\n        }\n        lastCdpId[dst] = cdp;\n        cdpCount[dst] = _add(cdpCount[dst], 1);\n    }\n\n    function modifySAFECollateralization(\n        uint cdp,\n        int deltaCollateral,\n        int deltaDebt\n    ) public override cdpAllowed(cdp) {\n        address urn = safes[cdp];\n        safeEngine.modifySAFECollateralization(\n            collateralTypes[cdp],\n            urn,\n            urn,\n            urn,\n            deltaCollateral,\n            deltaDebt\n        );\n    }\n\n    function transferCollateral(\n        uint cdp,\n        address dst,\n        uint wad\n    ) public override cdpAllowed(cdp) {\n        safeEngine.transferCollateral(collateralTypes[cdp], safes[cdp], dst, wad);\n    }\n\n    function transferCollateral(\n        bytes32 ilk,\n        uint cdp,\n        address dst,\n        uint wad\n    ) public override cdpAllowed(cdp) {\n        safeEngine.transferCollateral(ilk, safes[cdp], dst, wad);\n    }\n\n    function transferInternalCoins(uint cdp, address dst, uint rad) public override cdpAllowed(cdp) {\n        safeEngine.transferInternalCoins(safes[cdp], dst, rad);\n    }\n\n    function quit(uint cdp, address dst) public override cdpAllowed(cdp) handlerAlloweded(dst) {\n        (uint lockedCollateral, uint generatedDebt) = safeEngine.safes(collateralTypes[cdp], safes[cdp]);\n        safeEngine.transferSAFECollateralAndDebt(\n            collateralTypes[cdp],\n            safes[cdp],\n            dst,\n            toInt(lockedCollateral),\n            toInt(generatedDebt)\n        );\n    }\n\n    function enter(address src, uint cdp) public override handlerAlloweded(src) cdpAllowed(cdp) {\n        (uint lockedCollateral, uint generatedDebt) = safeEngine.safes(collateralTypes[cdp], src);\n        safeEngine.transferSAFECollateralAndDebt(\n            collateralTypes[cdp],\n            src,\n            safes[cdp],\n            toInt(lockedCollateral),\n            toInt(generatedDebt)\n        );\n    }\n\n    function moveSAFE(uint cdpSrc, uint cdpDst) public override cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\n        require(collateralTypes[cdpSrc] == collateralTypes[cdpDst], \"non-matching-cdps\");\n        (uint lockedCollateral, uint generatedDebt) = safeEngine.safes(collateralTypes[cdpSrc], safes[cdpSrc]);\n        safeEngine.transferSAFECollateralAndDebt(\n            collateralTypes[cdpSrc],\n            safes[cdpSrc],\n            safes[cdpDst],\n            toInt(lockedCollateral),\n            toInt(generatedDebt)\n        );\n    }\n}\n"
    },
    "contracts/makerdao/core/OracleRelayer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// OracleRelayer.sol -- OracleRelayer\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../utils/AuthWithoutContractEnabled.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract OracleRelayer is AuthWithoutContractEnabled {\n    // --- Data ---\n    struct CollateralType {\n        IPriceFeed priceFeed;\n        uint256 liquidationRatio; // [ray]\n    }\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    ISafeEngine public safeEngine;\n    uint256 public redemptionPrice;  // ref per dai [ray]\n\n    // --- Events ---\n    event Poke(\n      bytes32 collateralType,\n      bytes32 val,  // [wad]\n      uint256 safetyPrice  // [ray]\n    );\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n        redemptionPrice = ONE;\n        contractEnabled = 1;\n    }\n\n    // --- Math ---\n    uint constant ONE = 10 ** 27;\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = mul(x, ONE) / y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 collateralType, bytes32 what, address priceFeed_) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/not-contractEnabled\");\n        if (what == \"priceFeed\") collateralTypes[collateralType].priceFeed = IPriceFeed(priceFeed_);\n        else revert(\"OracleRelayer/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 what, uint data) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/not-contractEnabled\");\n        if (what == \"redemptionPrice\") redemptionPrice = data;\n        else revert(\"OracleRelayer/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/not-contractEnabled\");\n        if (what == \"liquidationRatio\") collateralTypes[collateralType].liquidationRatio = data;\n        else revert(\"OracleRelayer/modifyParameters-unrecognized-param\");\n    }\n\n    // --- Update value ---\n    function updateSafetyPrice(bytes32 collateralType) external {\n        (bytes32 val, bool has) = collateralTypes[collateralType].priceFeed.peek();\n        uint256 safetyPrice = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), redemptionPrice), collateralTypes[collateralType].liquidationRatio) : 0;\n        safeEngine.modifyParameters(collateralType, \"safetyPrice\", safetyPrice);\n        emit Poke(collateralType, val, safetyPrice);\n    }\n}\n"
    },
    "contracts/makerdao/core/ProxyRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// ProxyRegistry.sol\n\n// Copyright (C) 2018-2021 Dai Foundation\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.0;\n\nimport \"../utils/proxy.sol\";\n\n// This Registry deploys new proxy instances through DSProxyFactory.build(address) and keeps a registry of owner => proxy\ncontract ProxyRegistry {\n    mapping(address => DSProxy) public proxies;\n    DSProxyFactory factory;\n\n    constructor(address factory_) public {\n        factory = DSProxyFactory(factory_);\n    }\n\n    // deploys a new proxy instance\n    // sets owner of proxy to caller\n    function build() public returns (address payable proxy) {\n        proxy = build(msg.sender);\n    }\n\n    // deploys a new proxy instance\n    // sets custom owner of proxy\n    function build(address owner) public returns (address payable proxy) {\n        require(proxies[owner] == DSProxy(0) || proxies[owner].owner() != owner); // Not allow new proxy if the user already has one and remains being the owner\n        proxy = factory.build(owner);\n        proxies[owner] = DSProxy(proxy);\n    }\n}\n"
    },
    "contracts/makerdao/core/SafeEngine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// SAFEEngine.sol -- Dai CDP database\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\nimport {AuthWithContractEnabled} from \"../utils/AuthWithContractEnabled.sol\";\nimport {Math} from \"../utils/Math.sol\";\nimport {ISafeEngine} from \"../interfaces/ISafeEngine.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract SafeEngine is AuthWithContractEnabled, Math, ISafeEngine {\n    // --- Auth ---\n    // Who can transfer collateral & debt in/out of a CDP\n    mapping(address => mapping (address => uint)) public cdpRights;\n\n    function approveSAFEModification(address usr) external override { cdpRights[msg.sender][usr] = 1; }\n\n    function denySAFEModification(address usr) external override { cdpRights[msg.sender][usr] = 0; }\n\n    function canModifySAFE(address cdp, address account) internal view returns (bool) {\n        return either(cdp == account, cdpRights[cdp][account] == 1);\n    }\n\n    /// Total User Debt (drawn dai + stability fee accrued) = SAFE.generatedDebt * CollateralType.accumulatedRate;\n\n    // Data about each collateral type\n    mapping (bytes32 => CollateralType)            public override collateralTypes;\n    // Data about each SAFE\n    mapping (bytes32 => mapping (address => SAFE)) public override safes;\n    // Balance of each collateral type\n    mapping (bytes32 => mapping (address => uint)) public tokenCollateral; // [wad]\n    // Internal balance of pegged-coins\n    mapping (address => uint256)                   public coinBalance;     // [rad]\n    // Amount of debt held by an account. Coin & debt are like matter and antimatter. They nullify each other\n    mapping (address => uint256)                   public debtBalance;     // [rad]\n\n    uint256 public globalDebt;          // Total amount of debt (coins) currently issued [rad]\n    uint256 public globalUnbackedDebt;  // 'Bad' debt that's not covered by collateral   [rad]\n    uint256 public globalDebtCeiling;   // Maximum amount of debt that can be issued     [rad]\n\n    // --- Init ---\n    constructor() public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n    }\n\n    // --- Administration ---\n    function initializeCollateralType(bytes32 collateralType) external override isAuthorized {\n        require(collateralTypes[collateralType].accumulatedRate == 0, \"SafeEngine/collateral-type-already-init\");\n        collateralTypes[collateralType].accumulatedRate = 10 ** 27;\n    }\n    function modifyParameters(bytes32 what, uint data) external override isAuthorized {\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n        if (what == \"globalDebtCeiling\") globalDebtCeiling = data;\n        else revert(\"SafeEngine/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external override isAuthorized {\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n        if (what == \"safetyPrice\") collateralTypes[collateralType].safetyPrice = data;\n        else if (what == \"debtCeiling\") collateralTypes[collateralType].debtCeiling = data;\n        else if (what == \"debtFloor\") collateralTypes[collateralType].debtFloor = data;\n        else revert(\"SafeEngine/modifyParameters-unrecognized-param\");\n    }\n\n    // --- Fungibility ---\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external override isAuthorized {\n        tokenCollateral[collateralType][usr] = _add(tokenCollateral[collateralType][usr], wad);\n    }\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external override {\n        require(canModifySAFE(src, msg.sender), \"SafeEngine/not-allowed\");\n        tokenCollateral[collateralType][src] = _sub(tokenCollateral[collateralType][src], wad);\n        tokenCollateral[collateralType][dst] = _add(tokenCollateral[collateralType][dst], wad);\n    }\n    function transferInternalCoins(address src, address dst, uint256 rad) external override {\n        require(canModifySAFE(src, msg.sender), \"SafeEngine/not-allowed\");\n        coinBalance[src] = _sub(coinBalance[src], rad);\n        coinBalance[dst] = _add(coinBalance[dst], rad);\n    }\n\n    // --- CDP Manipulation ---\n    function modifySAFECollateralization(bytes32 collateralType, address cdp, address collateralSource, address debtDestination, int deltaCollateral, int deltaDebt) external override {\n        // system is contractEnabled\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n\n        SAFE memory safe_ = safes[collateralType][cdp];\n        CollateralType memory collateralType_ = collateralTypes[collateralType];\n        // collateralType has been initialised\n        require(collateralType_.accumulatedRate != 0, \"SafeEngine/collateral-type-not-init\");\n\n        safe_.lockedCollateral = _add(safe_.lockedCollateral, deltaCollateral);\n        safe_.generatedDebt = _add(safe_.generatedDebt, deltaDebt);\n        collateralType_.debtAmount = _add(collateralType_.debtAmount, deltaDebt);\n\n        int dAmountToRaise = _mul(collateralType_.accumulatedRate, deltaDebt);\n        uint amountToRaise = _mul(collateralType_.accumulatedRate, safe_.generatedDebt);\n        globalDebt = _add(globalDebt, dAmountToRaise);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        require(either(deltaDebt <= 0, both(_mul(collateralType_.debtAmount, collateralType_.accumulatedRate) <= collateralType_.debtCeiling, globalDebt <= globalDebtCeiling)), \"SafeEngine/ceiling-exceeded\");\n        // safe is either less risky than before, or it is safe\n        require(either(both(deltaDebt <= 0, deltaCollateral >= 0), amountToRaise <= _mul(safe_.lockedCollateral, collateralType_.safetyPrice)), \"SafeEngine/not-safe\");\n\n        // safe is either more safe, or the owner consents\n        require(either(both(deltaDebt <= 0, deltaCollateral >= 0), canModifySAFE(cdp, msg.sender)), \"SafeEngine/not-allowed-u\");\n        // collateral src consents\n        require(either(deltaCollateral <= 0, canModifySAFE(collateralSource, msg.sender)), \"SafeEngine/not-allowed-v\");\n        // debt dst consents\n        require(either(deltaDebt >= 0, canModifySAFE(debtDestination, msg.sender)), \"SafeEngine/not-allowed-w\");\n\n        // safe has no debt, or a non-dusty amount\n        require(either(safe_.generatedDebt == 0, amountToRaise >= collateralType_.debtFloor), \"SafeEngine/debtFloor\");\n\n            tokenCollateral[collateralType][collateralSource] = _sub(tokenCollateral[collateralType][collateralSource], deltaCollateral);\n        coinBalance[debtDestination]    = _add(coinBalance[debtDestination],    dAmountToRaise);\n\n        safes[collateralType][cdp]      = safe_;\n        collateralTypes[collateralType] = collateralType_;\n    }\n    // --- CDP Fungibility ---\n    function transferSAFECollateralAndDebt(bytes32 collateralType, address src, address dst, int deltaCollateral, int deltaDebt) external override {\n        SAFE storage srcCDP = safes[collateralType][src];\n        SAFE storage dstCDP = safes[collateralType][dst];\n        CollateralType storage col = collateralTypes[collateralType];\n\n        srcCDP.lockedCollateral = _sub(srcCDP.lockedCollateral, deltaCollateral);\n        srcCDP.generatedDebt = _sub(srcCDP.generatedDebt, deltaDebt);\n        dstCDP.lockedCollateral = _add(dstCDP.lockedCollateral, deltaCollateral);\n        dstCDP.generatedDebt = _add(dstCDP.generatedDebt, deltaDebt);\n\n        uint srcAmountToRaise = _mul(srcCDP.generatedDebt, col.accumulatedRate);\n        uint dstAmountToRaise = _mul(dstCDP.generatedDebt, col.accumulatedRate);\n\n        // both sides consent\n        require(both(canModifySAFE(src, msg.sender), canModifySAFE(dst, msg.sender)), \"SafeEngine/not-allowed\");\n\n        // both sides safe\n        require(srcAmountToRaise <= _mul(srcCDP.lockedCollateral, col.safetyPrice), \"SafeEngine/not-safe-src\");\n        require(dstAmountToRaise <= _mul(dstCDP.lockedCollateral, col.safetyPrice), \"SafeEngine/not-safe-dst\");\n\n        // both sides non-dusty\n        require(either(srcAmountToRaise >= col.debtFloor, srcCDP.generatedDebt == 0), \"SafeEngine/debtFloor-src\");\n        require(either(dstAmountToRaise >= col.debtFloor, dstCDP.generatedDebt == 0), \"SafeEngine/debtFloor-dst\");\n    }\n    // --- CDP Confiscation ---\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address cdp, address collateralCounterparty, address debtCounterparty, int deltaCollateral, int deltaDebt) external override isAuthorized {\n        SAFE storage safe_ = safes[collateralType][cdp];\n        CollateralType storage collateralType_ = collateralTypes[collateralType];\n\n        safe_.lockedCollateral = _add(safe_.lockedCollateral, deltaCollateral);\n        safe_.generatedDebt = _add(safe_.generatedDebt, deltaDebt);\n        collateralType_.debtAmount = _add(collateralType_.debtAmount, deltaDebt);\n\n        int deltaTotalIssuedDebt = _mul(collateralType_.accumulatedRate, deltaDebt);\n\n        tokenCollateral[collateralType][collateralCounterparty] = _sub(tokenCollateral[collateralType][collateralCounterparty], deltaCollateral);\n        debtBalance[debtCounterparty]    = _sub(debtBalance[debtCounterparty], deltaTotalIssuedDebt);\n        globalUnbackedDebt      = _sub(globalUnbackedDebt, deltaTotalIssuedDebt);\n    }\n\n    // --- Settlement ---\n\n    function settleDebt(uint rad) external override {\n        address account      = msg.sender;\n        debtBalance[account] = _sub(debtBalance[account], rad);\n        coinBalance[account] = _sub(coinBalance[account], rad);\n        globalUnbackedDebt   = _sub(globalUnbackedDebt,   rad);\n        globalDebt           = _sub(globalDebt,   rad);\n    }\n\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external override isAuthorized {\n        debtBalance[debtDestination] = _add(debtBalance[debtDestination], rad);\n        coinBalance[coinDestination] = _add(coinBalance[coinDestination], rad);\n        globalUnbackedDebt           = _add(globalUnbackedDebt,   rad);\n        globalDebt                   = _add(globalDebt,   rad);\n    }\n\n    // --- Rates ---\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external override isAuthorized {\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n        CollateralType storage collateralType_ = collateralTypes[collateralType];\n        collateralType_.accumulatedRate        = _add(collateralType_.accumulatedRate, accumulatedRate);\n        int deltaSurplus                       = _mul(collateralType_.debtAmount, accumulatedRate);\n        coinBalance[surplusDst]                = _add(coinBalance[surplusDst], deltaSurplus);\n        globalDebt                             = _add(globalDebt, deltaSurplus);\n    }\n}\n"
    },
    "contracts/makerdao/core/TaxCollector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// TaxCollector.sol -- Dai Lending Rate\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/ITaxCollector.sol\";\nimport {AuthWithoutContractEnabled} from \"../utils/AuthWithoutContractEnabled.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract TaxCollector is ITaxCollector, AuthWithoutContractEnabled {\n    mapping (bytes32 => CollateralType) public collateralTypes;\n    ISafeEngine public safeEngine;   // CDP Engine\n    address public primaryTaxReceiver;   // Debt Engine\n    uint256 public base;  // Global, per-second stability fee contribution [ray]\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n    }\n\n    // --- Math ---\n    function _rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n      assembly {\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n        default {\n          switch mod(n, 2) case 0 { z := b } default { z := x }\n          let half := div(b, 2)  // for rounding.\n          for { n := div(n, 2) } n { n := div(n,2) } {\n            let xx := mul(x, x)\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n            let xxRound := add(xx, half)\n            if lt(xxRound, xx) { revert(0,0) }\n            x := div(xxRound, b)\n            if mod(n,2) {\n              let zx := mul(z, x)\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n              let zxRound := add(zx, half)\n              if lt(zxRound, zx) { revert(0,0) }\n              z := div(zxRound, b)\n            }\n          }\n        }\n      }\n    }\n    uint256 constant ONE = 10 ** 27;\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function _diff(uint x, uint y) internal pure returns (int z) {\n        z = int(x) - int(y);\n        require(int(x) >= 0 && int(y) >= 0);\n    }\n    function _rmul(uint x, uint y) internal pure returns (uint z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / ONE;\n    }\n\n    // --- Administration ---\n    function initializeCollateralType(bytes32 collateralType) external override isAuthorized {\n        CollateralType storage i = collateralTypes[collateralType];\n        require(i.stabilityFee == 0, \"TaxCollector/collateralType-already-init\");\n        i.stabilityFee = ONE;\n        i.latestUpdateTime  = now;\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external override isAuthorized {\n        require(now == collateralTypes[collateralType].latestUpdateTime, \"TaxCollector/latestUpdateTime-not-updated\");\n        if (what == \"stabilityFee\") collateralTypes[collateralType].stabilityFee = data;\n        else revert(\"TaxCollector/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 what, uint data) external override isAuthorized {\n        if (what == \"base\") base = data;\n        else revert(\"TaxCollector/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 what, address data) external override isAuthorized {\n        if (what == \"primaryTaxReceiver\") primaryTaxReceiver = data;\n        else revert(\"TaxCollector/modifyParameters-unrecognized-param\");\n    }\n\n    function taxSingle(bytes32 collateralType) external override returns (uint rate) {\n        require(now >= collateralTypes[collateralType].latestUpdateTime, \"TaxCollector/invalid-now\");\n        (, uint prevRate,,,) = safeEngine.collateralTypes(collateralType);\n        /// rate = oldRate * (1 + StabilityRate)^(time since last taxSingle)\n        rate = _rmul(\n            _rpow(\n                _add(base, collateralTypes[collateralType].stabilityFee),\n                now - collateralTypes[collateralType].latestUpdateTime,\n                ONE\n            ),\n            prevRate\n        );\n        safeEngine.updateAccumulatedRate(collateralType, primaryTaxReceiver, _diff(rate, prevRate));\n        collateralTypes[collateralType].latestUpdateTime = now;\n    }\n}\n"
    },
    "contracts/makerdao/externalContracts/AccountingEngine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// AccountingEngine.sol -- Dai settlement module\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface DebtAuctionHouseLike {\n    function startAuction(address auctionIncomeRecipient, uint amountToSell, uint bidAmount) external returns (uint);\n    function disableContract() external;\n    function contractEnabled() external returns (uint);\n}\n\ninterface SurplusAuctionHouseLike {\n    function startAuction(uint amountToSell, uint bidAmount) external returns (uint);\n    function disableContract(uint) external;\n    function contractEnabled() external returns (uint);\n}\n\ninterface SafeEngineLike {\n    function coinBalance (address) external view returns (uint);\n    function debtBalance (address) external view returns (uint);\n    function settleDebt(uint256) external;\n    function approveSAFEModification(address) external;\n    function denySAFEModification(address) external;\n}\n\ncontract AccountingEngine {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized { require(contractEnabled == 1, \"AccountingEngine/not-contractEnabled\"); authorizedAccounts[usr] = 1; }\n    function removeAuthorization(address usr) external isAuthorized { authorizedAccounts[usr] = 0; }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"AccountingEngine/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    SafeEngineLike public safeEngine;        // CDP Engine\n    SurplusAuctionHouseLike public surplusAuctionHouse;   // Surplus Auction House\n    DebtAuctionHouseLike public debtAuctionHouse;   // Debt Auction House\n\n    mapping (uint256 => uint256) public debtQueue;  // debt queue\n    uint256 public totalQueuedDebt;   // Queued debt            [rad]\n    uint256 public totalOnAuctionDebt;   // On-auction debt        [rad]\n\n    uint256 public popDebtDelay;  // DebtAuctionHouse delay             [seconds]\n    uint256 public initialDebtAuctionMintedTokens;  // DebtAuctionHouse initial amountToSell size  [wad]\n    uint256 public debtAuctionBidSize;  // DebtAuctionHouse fixed bid size    [rad]\n\n    uint256 public surplusAuctionAmountToSell;  // SurplusAuctionHouse fixed amountToSell size    [rad]\n    uint256 public surplusBuffer;  // Surplus buffer         [rad]\n\n    uint256 public contractEnabled;  // Active Flag\n\n    // --- Init ---\n    constructor(address safeEngine_, address surplusAuctionHouse_, address debtAuctionHouse_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine     = SafeEngineLike(safeEngine_);\n        surplusAuctionHouse = SurplusAuctionHouseLike(surplusAuctionHouse_);\n        debtAuctionHouse = DebtAuctionHouseLike(debtAuctionHouse_);\n        safeEngine.approveSAFEModification(surplusAuctionHouse_);\n        contractEnabled = 1;\n    }\n\n    // --- Math ---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 what, uint data) external isAuthorized {\n        if (what == \"popDebtDelay\") popDebtDelay = data;\n        else if (what == \"surplusAuctionAmountToSell\") surplusAuctionAmountToSell = data;\n        else if (what == \"debtAuctionBidSize\") debtAuctionBidSize = data;\n        else if (what == \"initialDebtAuctionMintedTokens\") initialDebtAuctionMintedTokens = data;\n        else if (what == \"surplusBuffer\") surplusBuffer = data;\n        else revert(\"AccountingEngine/modifyParameters-unrecognized-param\");\n    }\n\n    function modifyParameters(bytes32 what, address data) external isAuthorized {\n        if (what == \"surplusAuctionHouse\") {\n            safeEngine.denySAFEModification(address(surplusAuctionHouse));\n            surplusAuctionHouse = SurplusAuctionHouseLike(data);\n            safeEngine.approveSAFEModification(data);\n        }\n        else if (what == \"debtAuctionHouse\") debtAuctionHouse = DebtAuctionHouseLike(data);\n        else revert(\"AccountingEngine/modifyParameters-unrecognized-param\");\n    }\n\n    /**\n    * @notice Push debt (that the system tries to cover with collateral auctions) to a queue\n     * @dev Debt is locked in a queue to give the system enough time to auction collateral\n     *      and gather surplus\n     * @param amountToRaise Amount of debt to push\n     */\n    function pushDebtToQueue(uint amountToRaise) external isAuthorized {\n        debtQueue[now] = add(debtQueue[now], amountToRaise);\n        totalQueuedDebt = add(totalQueuedDebt, amountToRaise);\n    }\n    /**\n     * @notice A block of debt can be popped from the queue after popDebtDelay seconds passed since it was\n     *         added there\n     * @param era Timestamp of the block of debt that should be popped out\n     */\n    function popDebtFromQueue(uint era) external {\n        require(add(era, popDebtDelay) <= now, \"AccountingEngine/popDebtDelay-not-finished\");\n        totalQueuedDebt = sub(totalQueuedDebt, debtQueue[era]);\n        debtQueue[era] = 0;\n    }\n\n    // Debt settlement\n    /**\n     * @notice Destroy an equal amount of coins and debt\n     * @dev We can only destroy debt that is not locked in the queue and also not in a debt auction\n     * @param rad Amount of coins/debt to destroy (number with 45 decimals)\n    **/\n    function settleDebt(uint rad) external {\n        require(rad <= safeEngine.coinBalance(address(this)), \"AccountingEngine/insufficient-surplus\");\n        require(rad <= sub(sub(safeEngine.debtBalance(address(this)), totalQueuedDebt), totalOnAuctionDebt), \"AccountingEngine/insufficient-debt\");\n        safeEngine.settleDebt(rad);\n    }\n    /**\n     * @notice Use surplus coins to destroy debt that is/was in a debt auction\n     * @param rad Amount of coins/debt to destroy (number with 45 decimals)\n    **/\n    function cancelAuctionedDebtWithSurplus(uint rad) external {\n        require(rad <= totalOnAuctionDebt, \"AccountingEngine/not-enough-ash\");\n        require(rad <= safeEngine.coinBalance(address(this)), \"AccountingEngine/insufficient-surplus\");\n        totalOnAuctionDebt = sub(totalOnAuctionDebt, rad);\n        safeEngine.settleDebt(rad);\n    }\n\n    // Debt auction\n    /**\n     * @notice Start a debt auction (print protocol tokens in exchange for coins so that the\n     *         system can accumulate surplus)\n     * @dev We can only auction debt that is not already being auctioned and is not locked in the debt queue\n    **/\n    function auctionDebt() external returns (uint id) {\n        require(debtAuctionBidSize <= sub(sub(safeEngine.debtBalance(address(this)), totalQueuedDebt), totalOnAuctionDebt), \"AccountingEngine/insufficient-debt\");\n        require(safeEngine.coinBalance(address(this)) == 0, \"AccountingEngine/surplus-not-zero\");\n        totalOnAuctionDebt = add(totalOnAuctionDebt, debtAuctionBidSize);\n        id = debtAuctionHouse.startAuction(address(this), initialDebtAuctionMintedTokens, debtAuctionBidSize);\n    }\n    // Surplus auction\n    /**\n     * @notice Start a surplus auction\n     * @dev We can only auction surplus if we wait at least 'surplusAuctionDelay' seconds since the last\n     *      auction trigger, if we keep enough surplus in the buffer and if there is no bad debt to settle\n    **/\n    function auctionSurplus() external returns (uint id) {\n        require(safeEngine.coinBalance(address(this)) >= add(add(safeEngine.debtBalance(address(this)), surplusAuctionAmountToSell), surplusBuffer), \"AccountingEngine/insufficient-surplus\");\n        require(sub(sub(safeEngine.debtBalance(address(this)), totalQueuedDebt), totalOnAuctionDebt) == 0, \"AccountingEngine/debt-not-zero\");\n        id = surplusAuctionHouse.startAuction(surplusAuctionAmountToSell, 0);\n    }\n    /**\n     * @notice Disable this contract (normally called by Global Settlement)\n     * @dev When we disable, the contract tries to settle as much debt as possible (if there's any) with\n            any surplus that's left in the system. After erasing debt, the contract will either transfer any\n            remaining surplus right away (if disableCooldown == 0) or will only record the timestamp when\n            it was disabled\n    **/\n    function disableContract() external isAuthorized {\n        require(contractEnabled == 1, \"AccountingEngine/not-contractEnabled\");\n        contractEnabled = 0;\n        totalQueuedDebt = 0;\n        totalOnAuctionDebt = 0;\n        surplusAuctionHouse.disableContract(safeEngine.coinBalance(address(surplusAuctionHouse)));\n        debtAuctionHouse.disableContract();\n        safeEngine.settleDebt(min(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this))));\n    }\n}\n"
    },
    "contracts/makerdao/externalContracts/DssProxyActions.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// DssProxyActions.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\ninterface CoinLike {\n    function approve(address, uint) external;\n    function transfer(address, uint) external;\n    function transferFrom(address, address, uint) external;\n    function deposit() external payable;\n    function withdraw(uint) external;\n}\n\ninterface ManagerLike {\n    function cdpCan(address, uint, address) external view returns (uint);\n    function collateralTypes(uint) external view returns (bytes32);\n    function owns(uint) external view returns (address);\n    function safes(uint) external view returns (address);\n    function safeEngine() external view returns (address);\n    function openSafe(bytes32, address) external returns (uint);\n    function transferSafeOwnership(uint, address) external;\n    function cdpAllow(uint, address, uint) external;\n    function allowHandler(address, uint) external;\n    function modifySAFECollateralization(uint, int, int) external;\n    function transferCollateral(uint, address, uint) external;\n    function transferInternalCoins(uint, address, uint) external;\n    function exit(address, uint, address, uint) external;\n    function quit(uint, address) external;\n    function enter(address, uint) external;\n    function moveSAFE(uint, uint) external;\n}\n\ninterface SafeEngineLike {\n    function cdpRights(address, address) external view returns (uint);\n    function collateralTypes(bytes32) external view returns (uint, uint, uint, uint, uint);\n    function coinBalance(address) external view returns (uint);\n    function safes(bytes32, address) external view returns (uint, uint);\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) external;\n    function approveSAFEModification(address) external;\n    function transferInternalCoins(address, address, uint) external;\n}\n\ninterface CollateralJoinLike {\n    function decimals() external returns (uint);\n    function collateral() external returns (CoinLike);\n    function join(address, uint) external payable;\n    function exit(address, uint) external;\n}\n\ninterface GNTJoinLike {\n    function bags(address) external view returns (address);\n    function make(address) external returns (address);\n}\n\ninterface CoinJoinLike {\n    function safeEngine() external returns (SafeEngineLike);\n    function systemCoin() external returns (CoinLike);\n    function join(address, uint) external payable;\n    function exit(address, uint) external;\n}\n\ninterface HopeLike {\n    function approveSAFEModification(address) external;\n    function denySAFEModification(address) external;\n}\n\ninterface GlobalSettlementLike {\n    function collateralCashPrice(bytes32) external view returns (uint);\n    function redeemCollateral(bytes32, uint) external;\n    function freeTokenCollateral(bytes32) external;\n    function prepareCoinsForRedeeming(uint) external;\n    function processSAFE(bytes32, address) external;\n}\n\ninterface taxCollectorLike {\n    function taxSingle(bytes32) external returns (uint);\n}\n\ninterface PotLike {\n    function savings(address) external view returns (uint);\n    function updateAccumulatedRate() external returns (uint);\n    function deposit(uint) external;\n    function exit(uint) external;\n}\n\ninterface ProxyRegistryLike {\n    function proxies(address) external view returns (address);\n    function build(address) external returns (address);\n}\n\ninterface ProxyLike {\n    function owner() external view returns (address);\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ncontract Common {\n    uint256 constant RAY = 10 ** 27;\n\n    // Internal functions\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n\n    // Public functions\n\n    function coinJoin_join(address apt, address safe, uint wad) public {\n        // Gets DAI from the user's wallet\n        CoinJoinLike(apt).systemCoin().transferFrom(msg.sender, address(this), wad);\n        // Approves adapter to take the DAI amount\n        CoinJoinLike(apt).systemCoin().approve(apt, wad);\n        // Joins DAI into the safeEngine\n        CoinJoinLike(apt).join(safe, wad);\n    }\n}\n\ncontract DssProxyActions is Common {\n    // Internal functions\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    function toInt(uint x) internal pure returns (int y) {\n        y = int(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    function toRad(uint wad) internal pure returns (uint rad) {\n        rad = mul(wad, 10 ** 27);\n    }\n\n    function convertTo18(address collateralJoin, uint256 amt) internal returns (uint256 wad) {\n        // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to modifySAFECollateralization function\n        // Adapters will automatically handle the difference of precision\n        wad = mul(\n            amt,\n            10 ** (18 - CollateralJoinLike(collateralJoin).decimals())\n        );\n    }\n\n    function _getGeneratedDeltaDebt(\n        address safeEngine,\n        address taxCollector,\n        address safe,\n        bytes32 collateralType,\n        uint wad\n    ) internal returns (int deltaDebt) {\n        // Updates stability fee rate\n        uint rate = taxCollectorLike(taxCollector).taxSingle(collateralType);\n\n        // Gets DAI balance of the safe in the safeEngine\n        uint dai = SafeEngineLike(safeEngine).coinBalance(safe);\n\n        // If there was already enough DAI in the safeEngine balance, just exits it without adding more debt\n        if (dai < mul(wad, RAY)) {\n            // Calculates the needed deltaDebt so together with the existing dai in the safeEngine is enough to exit wad amount of DAI tokens\n            deltaDebt = toInt(sub(mul(wad, RAY), dai) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given DAI wad amount)\n            deltaDebt = mul(uint(deltaDebt), rate) < mul(wad, RAY) ? deltaDebt + 1 : deltaDebt;\n        }\n    }\n\n    function _getRepaidDeltaDebt(\n        address safeEngine,\n        uint dai,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (int deltaDebt) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,) = SafeEngineLike(safeEngine).collateralTypes(collateralType);\n        // Gets actual safeDebt value of the safe\n        (, uint safeDebt) = SafeEngineLike(safeEngine).safes(collateralType, safe);\n\n        // Uses the whole dai balance in the safeEngine to reduce the debt\n        deltaDebt = toInt(dai / rate);\n        // Checks the calculated deltaDebt is not higher than safe.safeDebt (total debt), otherwise uses its value\n        deltaDebt = uint(deltaDebt) <= safeDebt ? - deltaDebt : - toInt(safeDebt);\n    }\n\n    function _getWipeAllWad(\n        address safeEngine,\n        address usr,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (uint wad) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,) = SafeEngineLike(safeEngine).collateralTypes(collateralType);\n        // Gets actual safeDebt value of the safe\n        (, uint safeDebt) = SafeEngineLike(safeEngine).safes(collateralType, safe);\n        // Gets actual dai amount in the safe\n        uint dai = SafeEngineLike(safeEngine).coinBalance(usr);\n\n        uint rad = sub(mul(safeDebt, rate), dai);\n        wad = rad / RAY;\n\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n    }\n\n    // Public functions\n\n    function transfer(address gem, address dst, uint amt) public {\n        CoinLike(gem).transfer(dst, amt);\n    }\n\n    function ethJoin_join(address apt, address safe) public payable {\n        // Wraps ETH in WETH\n        CollateralJoinLike(apt).collateral().deposit.value(msg.value)();\n        // Approves adapter to take the WETH amount\n        CollateralJoinLike(apt).collateral().approve(address(apt), msg.value);\n        // Joins WETH collateral into the safeEngine\n        CollateralJoinLike(apt).join(safe, msg.value);\n    }\n\n    function collateralJoin_join(address apt, address safe, uint amt, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            CollateralJoinLike(apt).collateral().transferFrom(msg.sender, address(this), amt);\n            // Approves adapter to take the token amount\n            CollateralJoinLike(apt).collateral().approve(apt, amt);\n        }\n        // Joins token collateral into the safeEngine\n        CollateralJoinLike(apt).join(safe, amt);\n    }\n\n    function approveSAFEModification(\n        address obj,\n        address usr\n    ) public {\n        HopeLike(obj).approveSAFEModification(usr);\n    }\n\n    function denySAFEModification(\n        address obj,\n        address usr\n    ) public {\n        HopeLike(obj).denySAFEModification(usr);\n    }\n\n    function openSafe(\n        address manager,\n        bytes32 collateralType,\n        address usr\n    ) public returns (uint cdp) {\n        cdp = ManagerLike(manager).openSafe(collateralType, usr);\n    }\n\n    function transferSafeOwnership(\n        address manager,\n        uint cdp,\n        address usr\n    ) public {\n        ManagerLike(manager).transferSafeOwnership(cdp, usr);\n    }\n\n    function transferSafeOwnershipToProxy(\n        address proxyRegistry,\n        address manager,\n        uint cdp,\n        address dst\n    ) public {\n        // Gets actual proxy address\n        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n        // Checks if the proxy address already existed and dst address is still the owner\n        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n            uint csize;\n            assembly {\n                csize := extcodesize(dst)\n            }\n            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the CDP\n            require(csize == 0, \"Dst-is-a-contract\");\n            // Creates the proxy for the dst address\n            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n        }\n        // Transfers CDP to the dst proxy\n        transferSafeOwnership(manager, cdp, proxy);\n    }\n\n    function cdpAllow(\n        address manager,\n        uint cdp,\n        address usr,\n        uint ok\n    ) public {\n        ManagerLike(manager).cdpAllow(cdp, usr, ok);\n    }\n\n    function allowHandler(\n        address manager,\n        address usr,\n        uint ok\n    ) public {\n        ManagerLike(manager).allowHandler(usr, ok);\n    }\n\n    function transferCollateral(\n        address manager,\n        uint cdp,\n        address dst,\n        uint wad\n    ) public {\n        ManagerLike(manager).transferCollateral(cdp, dst, wad);\n    }\n\n    function transferInternalCoins(\n        address manager,\n        uint cdp,\n        address dst,\n        uint rad\n    ) public {\n        ManagerLike(manager).transferInternalCoins(cdp, dst, rad);\n    }\n\n    function modifySAFECollateralization(\n        address manager,\n        uint cdp,\n        int deltaCollateral,\n        int deltaDebt\n    ) public {\n        ManagerLike(manager).modifySAFECollateralization(cdp, deltaCollateral, deltaDebt);\n    }\n\n    function quit(\n        address manager,\n        uint cdp,\n        address dst\n    ) public {\n        ManagerLike(manager).quit(cdp, dst);\n    }\n\n    function enter(\n        address manager,\n        address src,\n        uint cdp\n    ) public {\n        ManagerLike(manager).enter(src, cdp);\n    }\n\n    function moveSAFE(\n        address manager,\n        uint cdpSrc,\n        uint cdpOrg\n    ) public {\n        ManagerLike(manager).moveSAFE(cdpSrc, cdpOrg);\n    }\n\n    function makeCollateralBag(\n        address collateralJoin\n    ) public returns (address bag) {\n        bag = GNTJoinLike(collateralJoin).make(address(this));\n    }\n\n    function lockETH(\n        address manager,\n        address ethJoin,\n        uint cdp\n    ) public payable {\n        // Receives ETH amount, converts it to WETH and joins it into the safeEngine\n        ethJoin_join(ethJoin, address(this));\n        // Locks WETH amount into the CDP\n        SafeEngineLike(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n            ManagerLike(manager).collateralTypes(cdp),\n            ManagerLike(manager).safes(cdp),\n            address(this),\n            address(this),\n            toInt(msg.value),\n            0\n        );\n    }\n\n    function safeLockETH(\n        address manager,\n        address ethJoin,\n        uint cdp,\n        address owner\n    ) public payable {\n        require(ManagerLike(manager).owns(cdp) == owner, \"owner-missmatch\");\n        lockETH(manager, ethJoin, cdp);\n    }\n\n    function lockTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint cdp,\n        uint amt,\n        bool transferFrom\n    ) public {\n        // Takes token amount from user's wallet and joins into the safeEngine\n        collateralJoin_join(collateralJoin, address(this), amt, transferFrom);\n        // Locks token amount into the CDP\n        SafeEngineLike(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n            ManagerLike(manager).collateralTypes(cdp),\n            ManagerLike(manager).safes(cdp),\n            address(this),\n            address(this),\n            toInt(convertTo18(collateralJoin, amt)),\n            0\n        );\n    }\n\n    function safeLockTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint cdp,\n        uint amt,\n        bool transferFrom,\n        address owner\n    ) public {\n        require(ManagerLike(manager).owns(cdp) == owner, \"owner-missmatch\");\n        lockTokenCollateral(manager, collateralJoin, cdp, amt, transferFrom);\n    }\n\n    function freeETH(\n        address manager,\n        address ethJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Unlocks WETH amount from the CDP\n        modifySAFECollateralization(manager, cdp, -toInt(wad), 0);\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    function freeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint cdp,\n        uint amt\n    ) public {\n        uint wad = convertTo18(collateralJoin, amt);\n        // Unlocks token amount from the CDP\n        modifySAFECollateralization(manager, cdp, -toInt(wad), 0);\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wad);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function exitETH(\n        address manager,\n        address ethJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wad);\n\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    function exitTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint cdp,\n        uint amt\n    ) public {\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), convertTo18(collateralJoin, amt));\n\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function generateDebt(\n        address manager,\n        address taxCollector,\n        address coinJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        address safe = ManagerLike(manager).safes(cdp);\n        address safeEngine = ManagerLike(manager).safeEngine();\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(cdp);\n        // Generates debt in the CDP\n        modifySAFECollateralization(manager, cdp, 0, _getGeneratedDeltaDebt(safeEngine, taxCollector, safe, collateralType, wad));\n        // Moves the DAI amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, cdp, address(this), toRad(wad));\n        // Allows adapter to access to proxy's DAI balance in the safeEngine\n        if (SafeEngineLike(safeEngine).cdpRights(address(this), address(coinJoin)) == 0) {\n            SafeEngineLike(safeEngine).approveSAFEModification(coinJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        CoinJoinLike(coinJoin).exit(msg.sender, wad);\n    }\n\n    function repayDebt(\n        address manager,\n        address coinJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safe = ManagerLike(manager).safes(cdp);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(cdp);\n\n        address own = ManagerLike(manager).owns(cdp);\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins DAI amount into the safeEngine\n            coinJoin_join(coinJoin, safe, wad);\n            // Paybacks debt to the CDP\n            modifySAFECollateralization(manager, cdp, 0, _getRepaidDeltaDebt(safeEngine, SafeEngineLike(safeEngine).coinBalance(safe), safe, collateralType));\n        } else {\n            // Joins DAI amount into the safeEngine\n            coinJoin_join(coinJoin, address(this), wad);\n            // Paybacks debt to the CDP\n            SafeEngineLike(safeEngine).modifySAFECollateralization(\n                collateralType,\n                safe,\n                address(this),\n                address(this),\n                0,\n                _getRepaidDeltaDebt(safeEngine, wad * RAY, safe, collateralType)\n            );\n        }\n    }\n\n    function safeRepayDebt(\n        address manager,\n        address coinJoin,\n        uint cdp,\n        uint wad,\n        address owner\n    ) public {\n        require(ManagerLike(manager).owns(cdp) == owner, \"owner-missmatch\");\n        repayDebt(manager, coinJoin, cdp, wad);\n    }\n\n    function repayAllDebt(\n        address manager,\n        address coinJoin,\n        uint cdp\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safe = ManagerLike(manager).safes(cdp);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(cdp);\n        (, uint safeDebt) = SafeEngineLike(safeEngine).safes(collateralType, safe);\n\n        address own = ManagerLike(manager).owns(cdp);\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins DAI amount into the safeEngine\n            coinJoin_join(coinJoin, safe, _getWipeAllWad(safeEngine, safe, safe, collateralType));\n            // Paybacks debt to the CDP\n            modifySAFECollateralization(manager, cdp, 0, -int(safeDebt));\n        } else {\n            // Joins DAI amount into the safeEngine\n            coinJoin_join(coinJoin, address(this), _getWipeAllWad(safeEngine, address(this), safe, collateralType));\n            // Paybacks debt to the CDP\n            SafeEngineLike(safeEngine).modifySAFECollateralization(\n                collateralType,\n                safe,\n                address(this),\n                address(this),\n                0,\n                -int(safeDebt)\n            );\n        }\n    }\n\n    function safeRepayAllDebt(\n        address manager,\n        address coinJoin,\n        uint cdp,\n        address owner\n    ) public {\n        require(ManagerLike(manager).owns(cdp) == owner, \"owner-missmatch\");\n        repayAllDebt(manager, coinJoin, cdp);\n    }\n\n    function lockETHAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        uint cdp,\n        uint wadD\n    ) public payable {\n        address safe = ManagerLike(manager).safes(cdp);\n        address safeEngine = ManagerLike(manager).safeEngine();\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(cdp);\n        // Receives ETH amount, converts it to WETH and joins it into the safeEngine\n        ethJoin_join(ethJoin, safe);\n        // Locks WETH amount into the CDP and generates debt\n        modifySAFECollateralization(manager, cdp, toInt(msg.value), _getGeneratedDeltaDebt(safeEngine, taxCollector, safe, collateralType, wadD));\n        // Moves the DAI amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the safeEngine\n        if (SafeEngineLike(safeEngine).cdpRights(address(this), address(coinJoin)) == 0) {\n            SafeEngineLike(safeEngine).approveSAFEModification(coinJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        CoinJoinLike(coinJoin).exit(msg.sender, wadD);\n    }\n\n    function openLockETHAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint wadD\n    ) public payable returns (uint cdp) {\n        cdp = openSafe(manager, collateralType, address(this));\n        lockETHAndGenerateDebt(manager, taxCollector, ethJoin, coinJoin, cdp, wadD);\n    }\n\n    function lockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom\n    ) public {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        address safeEngine = ManagerLike(manager).safeEngine();\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        // Takes token amount from user's wallet and joins into the safeEngine\n        collateralJoin_join(collateralJoin, safeHandler, collateralAmount, transferFrom);\n        // Locks token amount into the SAFE and generates debt\n        modifySAFECollateralization(manager, safe, toInt(convertTo18(collateralJoin, collateralAmount)), _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, deltaWad));\n        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, safe, address(this), toRad(deltaWad));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (SafeEngineLike(safeEngine).cdpRights(address(this), address(coinJoin)) == 0) {\n            SafeEngineLike(safeEngine).approveSAFEModification(coinJoin);\n        }\n        // Exits COIN to the user's wallet as a token\n        CoinJoinLike(coinJoin).exit(msg.sender, deltaWad);\n    }\n\n    function openLockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint amtC,\n        uint wadD,\n        bool transferFrom\n    ) public returns (uint cdp) {\n        cdp = openSafe(manager, collateralType, address(this));\n        lockTokenCollateralAndGenerateDebt(manager, taxCollector, collateralJoin, coinJoin, cdp, amtC, wadD, transferFrom);\n    }\n\n    function openLockGNTAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address gntJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint amtC,\n        uint wadD\n    ) public returns (address bag, uint cdp) {\n        // Creates bag (if doesn't exist) to hold GNT\n        bag = GNTJoinLike(gntJoin).bags(address(this));\n        if (bag == address(0)) {\n            bag = makeCollateralBag(gntJoin);\n        }\n        // Transfer funds to the funds which previously were sent to the proxy\n        CoinLike(CollateralJoinLike(gntJoin).collateral()).transfer(bag, amtC);\n        cdp = openLockTokenCollateralAndGenerateDebt(manager, taxCollector, gntJoin, coinJoin, collateralType, amtC, wadD, false);\n    }\n\n    function repayDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint cdp,\n        uint wadC,\n        uint wadD\n    ) public {\n        address safe = ManagerLike(manager).safes(cdp);\n        // Joins DAI amount into the safeEngine\n        coinJoin_join(coinJoin, safe, wadD);\n        // Paybacks debt to the CDP and unlocks WETH amount from it\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            -toInt(wadC),\n            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SafeEngineLike(ManagerLike(manager).safeEngine()).coinBalance(safe), safe, ManagerLike(manager).collateralTypes(cdp))\n        );\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wadC);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n    }\n\n    function repayAllDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint cdp,\n        uint wadC\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safe = ManagerLike(manager).safes(cdp);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(cdp);\n        (, uint safeDebt) = SafeEngineLike(safeEngine).safes(collateralType, safe);\n\n        // Joins DAI amount into the safeEngine\n        coinJoin_join(coinJoin, safe, _getWipeAllWad(safeEngine, safe, safe, collateralType));\n        // Paybacks debt to the CDP and unlocks WETH amount from it\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            -toInt(wadC),\n            -int(safeDebt)\n        );\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wadC);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n    }\n\n    function repayDebtAndFreeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address coinJoin,\n        uint cdp,\n        uint amtC,\n        uint wadD\n    ) public {\n        address safe = ManagerLike(manager).safes(cdp);\n        // Joins DAI amount into the safeEngine\n        coinJoin_join(coinJoin, safe, wadD);\n        uint wadC = convertTo18(collateralJoin, amtC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            -toInt(wadC),\n            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SafeEngineLike(ManagerLike(manager).safeEngine()).coinBalance(safe), safe, ManagerLike(manager).collateralTypes(cdp))\n        );\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wadC);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amtC);\n    }\n\n    function repayAllDebtAndFreeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address coinJoin,\n        uint cdp,\n        uint amtC\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safe = ManagerLike(manager).safes(cdp);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(cdp);\n        (, uint safeDebt) = SafeEngineLike(safeEngine).safes(collateralType, safe);\n\n        // Joins DAI amount into the safeEngine\n        coinJoin_join(coinJoin, safe, _getWipeAllWad(safeEngine, safe, safe, collateralType));\n        uint wadC = convertTo18(collateralJoin, amtC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            -toInt(wadC),\n            -int(safeDebt)\n        );\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wadC);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amtC);\n    }\n}\n\ncontract DssProxyActionsGlobalSettlement is Common {\n    // Internal functions\n\n    function _freeTokenCollateral(\n        address manager,\n        address end,\n        uint cdp\n    ) internal returns (uint lockedCollateral) {\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(cdp);\n        address safe = ManagerLike(manager).safes(cdp);\n        SafeEngineLike safeEngine = SafeEngineLike(ManagerLike(manager).safeEngine());\n        uint safeDebt;\n        (lockedCollateral, safeDebt) = safeEngine.safes(collateralType, safe);\n\n        // If CDP still has debt, it needs to be paid\n        if (safeDebt > 0) {\n            GlobalSettlementLike(end).processSAFE(collateralType, safe);\n            (lockedCollateral,) = safeEngine.safes(collateralType, safe);\n        }\n        // Approves the manager to transfer the position to proxy's address in the safeEngine\n        if (safeEngine.cdpRights(address(this), address(manager)) == 0) {\n            safeEngine.approveSAFEModification(manager);\n        }\n        // Transfers position from CDP to the proxy address\n        ManagerLike(manager).quit(cdp, address(this));\n        // Frees the position and recovers the collateral in the safeEngine registry\n        GlobalSettlementLike(end).freeTokenCollateral(collateralType);\n    }\n\n    // Public functions\n    function freeETH(\n        address manager,\n        address ethJoin,\n        address end,\n        uint cdp\n    ) public {\n        uint wad = _freeTokenCollateral(manager, end, cdp);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    function freeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address end,\n        uint cdp\n    ) public {\n        uint amt = _freeTokenCollateral(manager, end, cdp) / 10 ** (18 - CollateralJoinLike(collateralJoin).decimals());\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function prepareCoinsForRedeeming(\n        address coinJoin,\n        address end,\n        uint wad\n    ) public {\n        coinJoin_join(coinJoin, address(this), wad);\n        SafeEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Approves the end to take out DAI from the proxy's balance in the safeEngine\n        if (safeEngine.cdpRights(address(this), address(end)) == 0) {\n            safeEngine.approveSAFEModification(end);\n        }\n        GlobalSettlementLike(end).prepareCoinsForRedeeming(wad);\n    }\n\n    function redeemETH(\n        address ethJoin,\n        address end,\n        bytes32 collateralType,\n        uint wad\n    ) public {\n        GlobalSettlementLike(end).redeemCollateral(collateralType, wad);\n        uint wadC = mul(wad, GlobalSettlementLike(end).collateralCashPrice(collateralType)) / RAY;\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n    }\n\n    function redeemTokenCollateral(\n        address collateralJoin,\n        address end,\n        bytes32 collateralType,\n        uint wad\n    ) public {\n        GlobalSettlementLike(end).redeemCollateral(collateralType, wad);\n        // Exits token amount to the user's wallet as a token\n        uint amt = mul(wad, GlobalSettlementLike(end).collateralCashPrice(collateralType)) / RAY / 10 ** (18 - CollateralJoinLike(collateralJoin).decimals());\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n}\n\ncontract DssProxyActionsDsr is Common {\n    function deposit(\n        address coinJoin,\n        address pot,\n        uint wad\n    ) public {\n        SafeEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to get the chi rate updated to rho == now, otherwise join will fail\n        uint chi = PotLike(pot).updateAccumulatedRate();\n        // Joins wad amount to the safeEngine balance\n        coinJoin_join(coinJoin, address(this), wad);\n        // Approves the pot to take out DAI from the proxy's balance in the safeEngine\n        if (safeEngine.cdpRights(address(this), address(pot)) == 0) {\n            safeEngine.approveSAFEModification(pot);\n        }\n        // Joins the savings value (equivalent to the DAI wad amount) in the pot\n        PotLike(pot).deposit(mul(wad, RAY) / chi);\n    }\n\n    function withdraw(\n        address coinJoin,\n        address pot,\n        uint wad\n    ) public {\n        SafeEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to count the savings accumulated until this moment\n        uint chi = PotLike(pot).updateAccumulatedRate();\n        // Calculates the savings value in the pot equivalent to the DAI wad amount\n        uint savings = mul(wad, RAY) / chi;\n        // Exits DAI from the pot\n        PotLike(pot).exit(savings);\n        // Checks the actual balance of DAI in the safeEngine after the pot exit\n        uint bal = CoinJoinLike(coinJoin).safeEngine().coinBalance(address(this));\n        // Allows adapter to access to proxy's DAI balance in the safeEngine\n        if (safeEngine.cdpRights(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // It is necessary to check if due rounding the exact wad amount can be exited by the adapter.\n        // Otherwise it will do the maximum DAI balance in the safeEngine\n        CoinJoinLike(coinJoin).exit(\n            msg.sender,\n            bal >= mul(wad, RAY) ? wad : bal / RAY\n        );\n    }\n\n    function withdrawAll(\n        address coinJoin,\n        address pot\n    ) public {\n        SafeEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to count the savings accumulated until this moment\n        uint chi = PotLike(pot).updateAccumulatedRate();\n        // Gets the total savings belonging to the proxy address\n        uint savings = PotLike(pot).savings(address(this));\n        // Exits DAI from the pot\n        PotLike(pot).exit(savings);\n        // Allows adapter to access to proxy's DAI balance in the safeEngine\n        if (safeEngine.cdpRights(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // Exits the DAI amount corresponding to the value of savings\n        CoinJoinLike(coinJoin).exit(msg.sender, mul(chi, savings) / RAY);\n    }\n}\n"
    },
    "contracts/makerdao/interfaces/IAuth.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\ninterface IAuth {\n    function addAuthorization(address usr) external;\n    function removeAuthorization(address usr) external;\n}\n"
    },
    "contracts/makerdao/interfaces/IAuthWithContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\nimport {IAuth} from \"./IAuth.sol\";\n\ninterface IAuthWithContractEnabled is IAuth {\n    event DisableContract();\n\n    function disableContract() external;\n}\n"
    },
    "contracts/makerdao/interfaces/IDssCdpManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\n/**\n * @title IDssMiddleware\n **/\ninterface IDssCdpManager {\n\n    /* ==================== STRUCTS ==================== */\n\n    struct List {\n        uint prev;\n        uint next;\n    }\n\n    /* ==================== EVENTS ===================== */\n\n    event NewCdp(address indexed usr, address indexed own, uint indexed cdp);\n\n\n    /* ==================== METHODS ==================== */\n\n    // @notice Allow/disallow a usr address to manage the cdp.\n    function cdpAllow(uint cdp, address usr, uint ok) external;\n\n    // @notice Allow/disallow a usr address to quit to the the sender urn.\n    function allowHandler(address usr, uint ok) external;\n\n    // @notice Open a new cdp for a given usr address.\n    function openSafe(bytes32 collateralType, address usr) external returns (uint);\n\n    // @notice Give the cdp ownership to a dst address.\n    function transferSafeOwnership(uint cdp, address dst) external;\n\n    // @notice Modify the cdp keeping the generated DAI or collateral freed in the cdp urn address.\n    function modifySAFECollateralization(uint cdp, int deltaCollateral, int deltaDebt) external;\n\n    // @notice Transfer wad amount of cdp collateral from the cdp address to a dst address.\n    function transferCollateral(uint cdp, address dst, uint wad) external;\n\n    // @notice Transfer wad amount of any type of collateral (ilk) from the cdp address to a dst address.\n    // This function has the purpose to take away collateral from the system that doesn't correspond to the cdp but was sent there wrongly.\n    function transferCollateral(bytes32 ilk, uint cdp, address dst, uint wad) external;\n\n    // @notice Transfer wad amount of DAI from the cdp address to a dst address.\n    function transferInternalCoins(uint cdp, address dst, uint rad) external;\n\n    // @notice Quit the system, migrating the cdp (lockedCollateral, generatedDebt) to a different dst urn\n    function quit(uint cdp, address dst) external;\n\n    // @notice Import a position from src urn to the urn owned by cdp\n    function enter(address src, uint cdp) external;\n\n    // @notice Move a position from cdpSrc urn to the cdpDst urn\n    function moveSAFE(uint cdpSrc, uint cdpDst) external;\n}\n"
    },
    "contracts/makerdao/interfaces/IOracleRelayer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\n/**\n * @title IPriceFeed\n **/\ninterface IOracleRelayer {\n    function peek() external returns (bytes32, bool);\n}\n"
    },
    "contracts/makerdao/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\n/**\n * @title IPriceFeed\n **/\ninterface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n}\n"
    },
    "contracts/makerdao/interfaces/ISafeEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\n/**\n * @title SafeEngine\n * @notice The single source of truth for the Maker Protocol. It contains the accounting system of the core Vault,\n * Internal Dai balances, and collateral state. It houses the public interface for Vault management,\n * allowing safe(= CDP or Vault) owners to adjust their Vault state balances. It also contains the public interface\n * for Vault fungibility, allowing safe (Vault) owners to transfer, split, and merge Vaults.\n * Excluding these interfaces, SAFEEngine is accessed through trusted smart contract modules.\n **/\ninterface ISafeEngine {\n    /* ==================== METHODS ==================== */\n\n    // --- Data ---\n    struct CollateralType {\n        uint256 debtAmount;       // Total debt issued for this specific collateral type                          [wad]\n        uint256 accumulatedRate;  // Accumulator for interest accrued on this collateral type                     [ray]\n        uint256 safetyPrice;      // Floor price at which a CDP is allowed to generate debt                       [ray]\n        uint256 debtCeiling;      // Maximum amount of debt that can be generated with this collateral type       [rad]\n        uint256 debtFloor;        // Minimum amount of debt that must be generated by a CDP using this collateral [rad]\n    }\n    struct SAFE {\n        uint256 lockedCollateral; // Total amount of collateral locked in a SAFE/CDP  [wad]\n        uint256 generatedDebt;    // Total amount of debt generated by a SAFE/CDP     [wad]\n    }\n\n    // --- VARS ---\n\n    function safes(bytes32, address) external view returns (uint, uint);\n\n    function collateralTypes(bytes32) external view returns (\n        uint256 debtAmount,   // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,\n        uint256 debtCeiling,\n        uint256 debtFloor\n    );\n\n    // --- Auth ---\n    /**\n     * @notice Allow an address to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function approveSAFEModification(address usr) external;\n\n    /**\n     * @notice Deny an address the rights to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function denySAFEModification(address usr) external;\n\n    // --- Administration ---\n\n    function initializeCollateralType(bytes32 collateralType) external;\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n\n    // --- Fungibility ---\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external;\n    function transferInternalCoins(address src, address dst, uint256 rad) external;\n\n    // --- CDP Manipulation ---\n    /**\n     * @notice Add/remove collateral or put back/generate more debt in a CDP\n     * @param collateralType Type of collateral to withdraw/deposit in and from the CDP\n     * @param cdp Target CDP\n     * @param collateralSource Account we take collateral from/put collateral into\n     * @param debtDestination Account from which we credit/debit coins and debt\n     * @param deltaCollateral Amount of collateral added/extract from the CDP\n     * @param deltaDebt Amount of debt to generate/repay\n     */\n    function modifySAFECollateralization(bytes32 collateralType, address cdp, address collateralSource, address debtDestination, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Fungibility ---\n    /**\n     * @notice Transfer collateral and/or debt between CDPs\n     * @param collateralType Collateral type transferred between CDPs\n     * @param src Source CDP\n     * @param dst Destination CDP\n     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst\n     * @param deltaDebt Amount of debt to take/add into src and give/take from dst\n     */\n    function transferSAFECollateralAndDebt(bytes32 collateralType, address src, address dst, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Confiscation ---\n    /**\n     * @notice Normally used by the LiquidationEngine in order to confiscate collateral and\n       debt from a CDP and give them to someone else\n     * @param collateralType Collateral type the CDP has locked inside\n     * @param cdp Target CDP\n     * @param collateralCounterparty Who we take/give collateral to\n     * @param debtCounterparty Who we take/give debt to\n     * @param deltaCollateral Amount of collateral taken/added into the CDP\n     * @param deltaDebt Amount of debt taken/added into the CDP\n     */\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address cdp, address collateralCounterparty, address debtCounterparty, int deltaCollateral, int deltaDebt) external;\n\n    // --- Settlement ---\n    /**\n     * @notice Nullify an amount of coins with an equal amount of debt\n     * @param rad Amount of debt & coins to destroy (expressed as a number with 45 decimals)\n     */\n    function settleDebt(uint rad) external;\n\n    /**\n     * @notice Usually called by CoinSavingsAccount in order to create unbacked debt\n     * @param debtDestination Usually AccountingEngine that can settle decreaseSoldAmount with surplus\n     * @param coinDestination Usually CoinSavingsAccount who passes the new coins to depositors\n     * @param rad Amount of debt to create (expressed as a number with 45 decimals)\n     */\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external;\n\n    // --- Rates ---\n    /**\n     * @notice Usually called by TaxCollector in order to accrue interest on a specific collateral type\n     * @param collateralType Collateral type we accrue interest for\n     * @param surplusDst Destination for amount of surplus created by applying the interest rate\n       to debt created by CDPs with 'collateralType'\n     * @param accumulatedRate Multiplier applied to the debtAmount in order to calculate the surplus\n     */\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ITaxCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\n/**\n * @title ITaxCollector\n **/\ninterface ITaxCollector {\n    /* ==================== STRUCTS ==================== */\n\n    struct CollateralType {\n        uint256 stabilityFee;      // Collateral-specific, per-second stability fee contribution [ray]\n        uint256 latestUpdateTime;  // Time of last taxSingle [unix epoch time]\n    }\n\n\n    /* ==================== METHODS ==================== */\n\n    // --- Administration ---\n    function initializeCollateralType(bytes32 collateralType) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, address data) external;\n\n\n    // --- Stability Fee Collection ---\n    /**\n     * @notice Collect tax from a single collateral type\n     * @param collateralType Collateral type to tax\n     */\n    function taxSingle(bytes32 collateralType) external returns (uint rate);\n}\n"
    },
    "contracts/makerdao/utils/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport {IAuth} from \"../interfaces/IAuth.sol\";\n\nabstract contract Auth is IAuth {\n    string private constant NotAuthorized = \"NotAuthorized\";\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 1;  }\n    function removeAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 0; }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert(NotAuthorized);\n        _;\n    }\n}\n"
    },
    "contracts/makerdao/utils/AuthWithContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"../interfaces/IAuthWithContractEnabled.sol\";\n\nabstract contract AuthWithContractEnabled is IAuthWithContractEnabled {\n    // error NotAuthorized(); is not working because error appears only in ^0.8.4\n    string private constant NotAuthorized = \"NotAuthorized\";\n    string private constant NotContractEnabled = \"NotContractEnabled\";\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external override isAuthorized {\n        if (contractEnabled != 1) revert(NotContractEnabled);\n        authorizedAccounts[usr] = 1;\n    }\n    function removeAuthorization(address usr) external override isAuthorized {\n        if (contractEnabled != 1) revert(NotContractEnabled);\n        authorizedAccounts[usr] = 0;\n    }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert(NotAuthorized);\n        _;\n    }\n\n    uint256 public contractEnabled; // Access flag, indicates whether this contract is still active\n    function disableContract() external override isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n}\n"
    },
    "contracts/makerdao/utils/AuthWithoutContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"../interfaces/IAuthWithContractEnabled.sol\";\n\nabstract contract AuthWithoutContractEnabled is IAuthWithContractEnabled {\n    // error NotAuthorized(); is not working because error appears only in ^0.8.4\n    string private constant NotAuthorized = \"NotAuthorized\";\n    string private constant NotContractEnabled = \"NotContractEnabled\";\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 1; }\n    function removeAuthorization(address usr) external override isAuthorized { authorizedAccounts[usr] = 0; }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert(NotAuthorized);\n        _;\n    }\n\n    uint256 public contractEnabled; // Access flag, indicates whether this contract is still active\n    function disableContract() external override isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n}\n"
    },
    "contracts/makerdao/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nabstract contract Math {\n    uint256 constant WAD = 10 ** 18;\n\n    function _add(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function _sub(uint x, int y) internal pure returns (uint z) {\n        z = x - uint(y);\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function _mul(uint x, int y) internal pure returns (int z) {\n        z = int(x) * y;\n        require(int(x) >= 0);\n        require(y == 0 || z / y == int(x));\n    }\n\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function _sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function _mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x <= y ? x : y;\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n}\n"
    },
    "contracts/makerdao/utils/proxy.sol": {
      "content": "// proxy.sol - execute actions atomically through the proxy's identity\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"../../lib/ds-auth/src/auth.sol\";\nimport \"../../lib/ds-note/src/note.sol\";\n\n// DSProxy\n// Allows code execution using a persistant identity This can be very\n// useful to execute a sequence of atomic actions. Since the owner of\n// the proxy can be changed, this allows for dynamic ownership models\n// i.e. a multisig\ncontract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache;  // global cache for contracts\n\n    constructor(address _cacheAddr) public {\n        setCache(_cacheAddr);\n    }\n\n    receive() external payable {\n    }\n\n    // use the proxy to execute calldata _data on contract _code\n    function execute(bytes memory _code, bytes memory _data)\n    public\n    payable\n    returns (address target, bytes memory response)\n    {\n        target = cache.read(_code);\n        if (target == address(0)) {\n            // deploy contract & store its address in cache\n            target = cache.write(_code);\n        }\n\n        response = execute(target, _data);\n    }\n\n    function execute(address _target, bytes memory _data)\n    public\n    auth\n    note\n    payable\n    returns (bytes memory response)\n    {\n        require(_target != address(0), \"ds-proxy-target-address-required\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n            // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    }\n\n    //set new cache\n    function setCache(address _cacheAddr)\n    public\n    auth\n    note\n    returns (bool)\n    {\n        require(_cacheAddr != address(0), \"ds-proxy-cache-address-required\");\n        cache = DSProxyCache(_cacheAddr);  // overwrite cache\n        return true;\n    }\n}\n\n// DSProxyFactory\n// This factory deploys new proxy instances through build()\n// Deployed proxy addresses are logged\ncontract DSProxyFactory {\n    event Created(address indexed sender, address indexed owner, address proxy, address cache);\n    mapping(address=>bool) public isProxy;\n    DSProxyCache public cache;\n\n    constructor() public {\n        cache = new DSProxyCache();\n    }\n\n    // deploys a new proxy instance\n    // sets owner of proxy to caller\n    function build() public returns (address payable proxy) {\n        proxy = build(msg.sender);\n    }\n\n    // deploys a new proxy instance\n    // sets custom owner of proxy\n    function build(address owner) public returns (address payable proxy) {\n        proxy = address(new DSProxy(address(cache)));\n        emit Created(msg.sender, owner, address(proxy), address(cache));\n        DSProxy(proxy).setOwner(owner);\n        isProxy[proxy] = true;\n    }\n}\n\n// DSProxyCache\n// This global cache stores addresses of contracts previously deployed\n// by a proxy. This saves gas from repeat deployment of the same\n// contracts and eliminates blockchain bloat.\n\n// By default, all proxies deployed from the same factory store\n// contracts in the same cache. The cache a proxy instance uses can be\n// changed.  The cache uses the sha3 hash of a contract's bytecode to\n// lookup the address\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n            case 1 {\n            // throw if contract failed to deploy\n                revert(0, 0)\n            }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}