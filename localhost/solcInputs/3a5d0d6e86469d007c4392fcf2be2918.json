{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ISuCdpRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuCdpRegistry {\n\n    struct CDP {\n        address asset;\n        address owner;\n    }\n\n    function batchCheckpoint ( address[] calldata assets, address[] calldata owners ) external;\n    function batchCheckpointForAsset ( address asset, address[] calldata owners ) external;\n    function checkpoint ( address asset, address owner ) external;\n    function cr (  ) external view returns ( address );\n    function getAllCdps (  ) external view returns ( CDP[] memory r );\n    function getCdpsByCollateral ( address asset ) external view returns ( CDP[] memory cdps );\n    function getCdpsByOwner ( address owner ) external view returns ( CDP[] memory r );\n    function getCdpsCount (  ) external view returns ( uint256 totalCdpCount );\n    function getCdpsCountForCollateral ( address asset ) external view returns ( uint256 );\n    function isAlive ( address asset, address owner ) external view returns ( bool );\n    function isListed ( address asset, address owner ) external view returns ( bool );\n    function vault (  ) external view returns ( address );\n}\n"
    },
    "contracts/SuCdpManager.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"./original-unit-contracts/interfaces/IOracleUsd.sol\";\nimport \"./original-unit-contracts/interfaces/IWETH.sol\";\nimport \"./original-unit-contracts/interfaces/ICDPRegistry.sol\";\nimport \"./original-unit-contracts/interfaces/IToken.sol\";\n\nimport \"./original-unit-contracts/helpers/ReentrancyGuard.sol\";\nimport \"./original-unit-contracts/helpers/SafeMath.sol\";\n\nimport \"./interfaces/ISuOracle.sol\";\nimport \"./interfaces/ISuVault.sol\";\nimport \"./interfaces/ISuCdpRegistry.sol\";\nimport \"./interfaces/ISuVaultManagerParameters.sol\";\nimport \"./interfaces/ISuVaultParameters.sol\";\n\n// finally found the managers mighty over the vault\n// user does only interact with manager as proxy to the wallet\n/// Yes\n// there is only one manager for vault each moment\n/// I'm sure, the code doesn't enforce this, could be multiple managers\n// suggest to maintain only address of active manager instead of managers list\n/// not sure why\ncontract SuCdpManager is ReentrancyGuard {\n    using SafeMath for uint;\n\n    ISuVault public immutable vault;\n    ISuVaultManagerParameters public immutable vaultManagerParameters;\n    ISuCdpRegistry public immutable cdpRegistry;\n    address payable public immutable WETH;\n\n    address public suOracle;\n\n    // 2^112 - what is meaning of 112?\n    ///  float standard https://en.wikipedia.org/wiki/Q_(number_format)\n    uint public constant Q112 = 2 ** 112;\n\n    // 10^5 = 10000\n    uint public constant DENOMINATOR_1E5 = 1e5;\n\n    // even triggered when user deposit collateral\n    event Join(address indexed asset, address indexed owner, uint main, uint usdp);\n\n    // event triggered when user withdraws collateral\n    event Exit(address indexed asset, address indexed owner, uint main, uint usdp);\n\n    // event triggered when user didnt withdraw collateral before price goes down\n    event LiquidationTriggered(address indexed asset, address indexed owner);\n\n    modifier checkpoint(address asset, address owner) {\n        _;\n        cdpRegistry.checkpoint(asset, owner);\n    }\n\n     // aggregation over composition\n    constructor(address _vaultManagerParameters, address _suOracle, address _cdpRegistry) {\n        require(\n            _vaultManagerParameters != address(0) &&\n            _cdpRegistry != address(0),\n                \"Unit Protocol: INVALID_ARGS\"\n        );\n\n        require(_suOracle != address(0), \"INVALID_ARGS: SU_ORACLE\");\n\n        require(ISuVaultManagerParameters(_vaultManagerParameters).vaultParameters() != address(0), \"INVALID_ARGS: VAULT_PARAMETERS\");\n\n        require(ISuVaultParameters(ISuVaultManagerParameters(_vaultManagerParameters).vaultParameters()).vault() != address(0), \"INVALID_ARGS: VAULT\");\n\n        require(ISuVault(ISuVaultParameters(ISuVaultManagerParameters(_vaultManagerParameters).vaultParameters()).vault()).weth() != address(0), \"INVALID_ARGS: VAULT_MANAGER\");\n\n        suOracle = _suOracle;\n\n        vaultManagerParameters = ISuVaultManagerParameters(_vaultManagerParameters);\n                \n        vault = ISuVault(ISuVaultParameters(ISuVaultManagerParameters(_vaultManagerParameters).vaultParameters()).vault());\n        \n        WETH = ISuVault(ISuVaultParameters(ISuVaultManagerParameters(_vaultManagerParameters).vaultParameters()).vault()).weth();\n        \n        cdpRegistry = ISuCdpRegistry(_cdpRegistry);\n    }\n\n    // wrapper ether only, no native\n    receive() external payable {\n        require(msg.sender == WETH, \"Unit Protocol: RESTRICTED\");\n    }\n\n      // why checkpoint is needed? to check if depositing collateral allowed for user?\n      // this function is called by user to deposit collateral and receive stablecoin\n      // before calling this function user has to approve the Vault to take his collateral\n      /// Yes,\n    function join(address asset, uint assetAmount, uint usdpAmount) public nonReentrant checkpoint(asset, msg.sender) {\n        require(usdpAmount != 0 || assetAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        require(IToken(asset).decimals() <= 18, \"Unit Protocol: NOT_SUPPORTED_DECIMALS\");\n\n        if (usdpAmount == 0) {\n\n            // why user deposit collateral but does not take stablecoin?\n            // should be called in separate function\n            /// Use doesn't want to get liquidate, so stakes more collateral\n            vault.depositMain(asset, msg.sender, assetAmount);\n\n        } else {\n            bool spawned = vault.debts(asset, msg.sender) != 0;\n\n            if (!spawned) {\n                // create a new debt position for user with current oracle\n                // why oracles are associated with user?\n                /// Historical reasons, now it's deprecated\n                // because oracle could have been changed since the position was created by user\n                // new positions will be spawned with new oracle but existing ones remain the same\n                // Doesn't matter, it's depreacted.\n                vault.spawn(asset, msg.sender);\n            }\n\n            if (assetAmount != 0) {\n                // deposit collateral to the wallet\n                vault.depositMain(asset, msg.sender, assetAmount);\n            }\n\n            // issue stablecoin to the user\n            // why usdpAmount is chosen by user?\n            // it should be calculated from amount of collateral given\n            vault.borrow(asset, msg.sender, usdpAmount);\n\n            // maybe here we check that usdpAmount are corresponding to assetAmount?\n            // how does user know correct values? probably by calling helper view function\n            _ensurePositionCollateralization(asset, msg.sender);\n\n        }\n\n        emit Join(asset, msg.sender, assetAmount, usdpAmount);\n    }\n\n    // convert normal ether to wrapped one and then deposit\n    function join_Eth(uint usdpAmount) external payable {\n\n        if (msg.value != 0) {\n            IWETH(WETH).deposit{value: msg.value}();\n            require(IWETH(WETH).transfer(msg.sender, msg.value), \"Unit Protocol: WETH_TRANSFER_FAILED\");\n        }\n\n        join(WETH, msg.value, usdpAmount);\n    }\n\n      // user can pay back the stablecoin and take his collateral\n      // instead of passing both assetAmount and usdpAmount\n      // better user just to pass one of them\n      // also pass preferred rate and maybe acceptable diff percent\n      // that's the purpose of passing both to protect user from rate fluctuations\n    function exit(address asset, uint assetAmount, uint usdpAmount) public nonReentrant checkpoint(asset, msg.sender) returns (uint) {\n\n        // what the case when usdpAmount allowed to be zero?\n        require(assetAmount != 0 || usdpAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        uint debt = vault.debts(asset, msg.sender);\n\n        // not to pay more stablecoin than debt\n        if (usdpAmount > debt) { usdpAmount = debt; }\n\n        if (assetAmount == 0) {\n            // why pay stablecoin but not withdrawing collateral?\n            /// To stop pay interest but have ability to loan in the future\n            _repay(asset, msg.sender, usdpAmount);\n        } else {\n            // pay full debt in stablecoin\n            if (debt == usdpAmount) {\n                // vault will transfer collateral to the user\n                vault.withdrawMain(asset, msg.sender, assetAmount);\n                if (usdpAmount != 0) {\n                    // how could it be zero? then debt is zero too\n                    /// Yes, if you returned debt in other tx but now want to take your collateral\n                    _repay(asset, msg.sender, usdpAmount);\n                }\n            } else {\n                // pay partly\n                vault.withdrawMain(asset, msg.sender, assetAmount);\n\n                if (usdpAmount != 0) {\n                    _repay(asset, msg.sender, usdpAmount);\n                }\n\n                vault.update(asset, msg.sender);\n\n                // make sure partial repayment is valid\n                // but dont need to check this after full repayment?\n                /// Yes, because divizion by 0\n                _ensurePositionCollateralization(asset, msg.sender);\n            }\n        }\n\n        emit Exit(asset, msg.sender, assetAmount, usdpAmount);\n\n        return usdpAmount;\n    }\n\n      // alternatively it allowed to pass collateral amount and calculate stablecoin amount\n      // how does user calculate repayment value?\n      /// UX convenience function\n    function exit_targetRepayment(address asset, uint assetAmount, uint repayment) external returns (uint) {\n\n        uint usdpAmount = _calcPrincipal(asset, msg.sender, repayment);\n\n        return exit(asset, assetAmount, usdpAmount);\n    }\n\n      // repay stablecoin and withdraw unwrapped ether\n    function exit_Eth(uint ethAmount, uint usdpAmount) public returns (uint) {\n        usdpAmount = exit(WETH, ethAmount, usdpAmount);\n        require(IWETH(WETH).transferFrom(msg.sender, address(this), ethAmount), \"Unit Protocol: WETH_TRANSFER_FROM_FAILED\");\n        IWETH(WETH).withdraw(ethAmount);\n        (bool success, ) = msg.sender.call{value:ethAmount}(\"\");\n        require(success, \"Unit Protocol: ETH_TRANSFER_FAILED\");\n        return usdpAmount;\n    }\n\n      // repay stablecoin and withdraw unwrapped ether without passing exact amount\n    function exit_Eth_targetRepayment(uint ethAmount, uint repayment) external returns (uint) {\n        uint usdpAmount = _calcPrincipal(WETH, msg.sender, repayment);\n        return exit_Eth(ethAmount, usdpAmount);\n    }\n\n    // decrease debt amount by burning repaid stablecoin\n    function _repay(address asset, address owner, uint usdpAmount) internal {\n        // calculate fee\n        uint fee = vault.calculateFee(asset, owner, usdpAmount);\n\n        // charge fee from the vault\n        vault.chargeFee(vault.usdp(), owner, fee);\n\n        // burn stablecoin from the vault\n        uint debtAfter = vault.repay(asset, owner, usdpAmount);\n        if (debtAfter == 0) {\n            vault.destroy(asset, owner);\n        }\n    }\n\n    // after partial repayment should be made sure its still collateralized enough\n    function _ensurePositionCollateralization(address asset, address owner) internal view {\n        // calculate value in usd from collateral position\n        uint usdValue_q112 = getCollateralUsdValue_q112(asset, owner);\n\n        // multiply value in usd to the collateral ratio, then divide by 2^112 and divide by 100\n        uint usdLimit = usdValue_q112 * vaultManagerParameters.initialCollateralRatio(asset) / Q112 / 100;\n\n        // make sure calculated allowed limit is higher than the actual debt\n        require(vault.getTotalDebt(asset, owner) <= usdLimit, \"Unit Protocol: UNDERCOLLATERALIZED\");\n    }\n\n    // anyone can trigger liquidation\n    // once position happen to be under collaterazied\n    function triggerLiquidation(address asset, address owner) external nonReentrant {\n\n\n        // calculate valut of collateral\n        uint usdValue_q112 = getCollateralUsdValue_q112(asset, owner);\n\n        // and check if it can be liquidated\n        require(_isLiquidatablePosition(asset, owner, usdValue_q112), \"Unit Protocol: SAFE_POSITION\");\n\n        // what are the factors discount percent depends upon?\n        uint liquidationDiscount_q112 = usdValue_q112.mul(\n            vaultManagerParameters.liquidationDiscount(asset)\n        ).div(DENOMINATOR_1E5);\n\n        // liquidation price is collateral value minus liquidation discount\n        uint initialLiquidationPrice = usdValue_q112.sub(liquidationDiscount_q112).div(Q112);\n\n        // then vault will trigger liquidation and auction begins\n        vault.triggerLiquidation(asset, owner, initialLiquidationPrice);\n\n        emit LiquidationTriggered(asset, owner);\n    }\n\n    // * Now we return rate and calculate amount here\n    function getCollateralUsdValue_q112(address asset, address owner) public view returns (uint) {\n        uint256 assetAmount = vault.collaterals(asset, owner);\n\n        uint256 collateralValueUsd_1e18 = ISuOracle(suOracle).getUsdPrice1e18(asset) * assetAmount / 1e18;\n\n        uint256 collateralValueUsd_q112 = collateralValueUsd_1e18 * Q112;\n\n        return collateralValueUsd_q112;\n    }\n\n     // is position allowed to be liquidated\n    function _isLiquidatablePosition(\n        address asset,\n        address owner,\n        uint usdValue_q112\n    ) internal view returns (bool) {\n        // calculate current debt to be returned\n        uint debt = vault.getTotalDebt(asset, owner);\n\n        if (debt == 0) return false;\n\n        // make sure its not under collaterazied\n        // should liquidation ration always be higher than 1 or allowed lower?\n        return debt.mul(100).mul(Q112).div(usdValue_q112) >= vaultManagerParameters.liquidationRatio(asset);\n    }\n\n     // view function to check if position is liquidatable\n    function isLiquidatablePosition(\n        address asset,\n        address owner\n    ) public view returns (bool) {\n        uint usdValue_q112 = getCollateralUsdValue_q112(asset, owner);\n\n        return _isLiquidatablePosition(asset, owner, usdValue_q112);\n    }\n\n     // view function to show utilization ratio\n     // the same function can be used inside of _isLiquidatablePosition\n    function utilizationRatio(\n        address asset,\n        address owner\n    ) public view returns (uint) {\n        uint debt = vault.getTotalDebt(asset, owner);\n        if (debt == 0) return 0;\n\n        uint usdValue_q112 = getCollateralUsdValue_q112(asset, owner);\n\n        return debt.mul(100).mul(Q112).div(usdValue_q112);\n    }\n\n     // calculate liquidation price\n     // can be used inside of _isLiquidatablePosition\n    function liquidationPrice_q112(\n        address asset,\n        address owner\n    ) external view returns (uint) {\n\n        uint debt = vault.getTotalDebt(asset, owner);\n        if (debt == 0) return type(uint256).max;\n\n        uint collateralLiqPrice = debt.mul(100).mul(Q112).div(vaultManagerParameters.liquidationRatio(asset));\n\n        require(IToken(asset).decimals() <= 18, \"Unit Protocol: NOT_SUPPORTED_DECIMALS\");\n\n        return collateralLiqPrice / vault.collaterals(asset, owner) / 10 ** (18 - IToken(asset).decimals());\n    }\n\n    /// util function for UX convenience\n    function _calcPrincipal(address asset, address owner, uint repayment) internal view returns (uint) {\n        uint fee = vault.stabilityFee(asset, owner) * (block.timestamp - vault.lastUpdate(asset, owner)) / 365 days;\n        return repayment * DENOMINATOR_1E5 / (DENOMINATOR_1E5 + fee);\n    }\n}\n"
    },
    "contracts/original-unit-contracts/interfaces/IOracleUsd.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOracleUsd {\r\n\r\n    // returns Q112-encoded value\r\n    // returned value 10**18 * 2**112 is $1\r\n    function assetToUsd(address asset, uint amount) external view returns (uint);\r\n}"
    },
    "contracts/original-unit-contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}"
    },
    "contracts/original-unit-contracts/interfaces/ICDPRegistry.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ICDPRegistry {\r\n\r\n    struct CDP {\r\n        address asset;\r\n        address owner;\r\n    }\r\n\r\n    function batchCheckpoint ( address[] calldata assets, address[] calldata owners ) external;\r\n    function batchCheckpointForAsset ( address asset, address[] calldata owners ) external;\r\n    function checkpoint ( address asset, address owner ) external;\r\n    function cr (  ) external view returns ( address );\r\n    function getAllCdps (  ) external view returns ( CDP[] memory r );\r\n    function getCdpsByCollateral ( address asset ) external view returns ( CDP[] memory cdps );\r\n    function getCdpsByOwner ( address owner ) external view returns ( CDP[] memory r );\r\n    function getCdpsCount (  ) external view returns ( uint256 totalCdpCount );\r\n    function getCdpsCountForCollateral ( address asset ) external view returns ( uint256 );\r\n    function isAlive ( address asset, address owner ) external view returns ( bool );\r\n    function isListed ( address asset, address owner ) external view returns ( bool );\r\n    function vault (  ) external view returns ( address );\r\n}\r\n"
    },
    "contracts/original-unit-contracts/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\n\r\ninterface IToken {\r\n    function decimals() external view returns (uint8);\r\n}"
    },
    "contracts/original-unit-contracts/helpers/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n // reentrancy attack happens through recursive calls\r\ncontract ReentrancyGuard {\r\n    // why double uint256 instead of enum or single boolean?\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n     // why functions having this modifier should be external but executing another private one?\r\n    modifier nonReentrant() {\r\n        // first call its false\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // second time its true\r\n        _status = _ENTERED;\r\n\r\n        // this means the function is allowed to be executed\r\n        _;\r\n\r\n        // why its being set again and how much is refund?\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n"
    },
    "contracts/original-unit-contracts/helpers/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ISuOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuOracle {\n    function getUsdPrice1e18(address collateral) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/ISuVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuVault {\n    function DENOMINATOR_1E2 (  ) external view returns ( uint256 );\n    function DENOMINATOR_1E5 (  ) external view returns ( uint256 );\n    function borrow ( address asset, address user, uint256 amount ) external returns ( uint256 );\n    function calculateFee ( address asset, address user, uint256 amount ) external view returns ( uint256 );\n    function changeOracleType ( address asset, address user, uint256 newOracleType ) external;\n    function chargeFee ( address asset, address user, uint256 amount ) external;\n    function col (  ) external view returns ( address );\n    function colToken ( address, address ) external view returns ( uint256 );\n    function collaterals ( address, address ) external view returns ( uint256 );\n    function debts ( address, address ) external view returns ( uint256 );\n    function depositCol ( address asset, address user, uint256 amount ) external;\n    function depositEth ( address user ) external payable;\n    function depositMain ( address asset, address user, uint256 amount ) external;\n    function destroy ( address asset, address user ) external;\n    function getTotalDebt ( address asset, address user ) external view returns ( uint256 );\n    function lastUpdate ( address, address ) external view returns ( uint256 );\n    function liquidate ( address asset, address positionOwner, uint256 mainAssetToLiquidator, uint256 colToLiquidator, uint256 mainAssetToPositionOwner, uint256 colToPositionOwner, uint256 repayment, uint256 penalty, address liquidator ) external;\n    function liquidationBlock ( address, address ) external view returns ( uint256 );\n    function liquidationFee ( address, address ) external view returns ( uint256 );\n    function liquidationPrice ( address, address ) external view returns ( uint256 );\n    function oracleType ( address, address ) external view returns ( uint256 );\n    function repay ( address asset, address user, uint256 amount ) external returns ( uint256 );\n    function spawn ( address asset, address user ) external;\n    function stabilityFee ( address, address ) external view returns ( uint256 );\n    function tokenDebts ( address ) external view returns ( uint256 );\n    function triggerLiquidation ( address asset, address positionOwner, uint256 initialPrice ) external;\n    function update ( address asset, address user ) external;\n    function usdp (  ) external view returns ( address );\n    function vaultParameters (  ) external view returns ( address );\n    function weth (  ) external view returns ( address payable );\n    function withdrawCol ( address asset, address user, uint256 amount ) external;\n    function withdrawEth ( address user, uint256 amount ) external;\n    function withdrawMain ( address asset, address user, uint256 amount ) external;\n}\n"
    },
    "contracts/interfaces/ISuVaultManagerParameters.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuVaultManagerParameters {\n    function devaluationPeriod ( address ) external view returns ( uint256 );\n    function initialCollateralRatio ( address ) external view returns ( uint256 );\n    function liquidationDiscount ( address ) external view returns ( uint256 );\n    function liquidationRatio ( address ) external view returns ( uint256 );\n    function maxColPercent ( address ) external view returns ( uint256 );\n    function minColPercent ( address ) external view returns ( uint256 );\n    function setColPartRange ( address asset, uint256 min, uint256 max ) external;\n    function setCollateral (\n        address asset,\n        uint256 stabilityFeeValue,\n        uint256 liquidationFeeValue,\n        uint256 initialCollateralRatioValue,\n        uint256 liquidationRatioValue,\n        uint256 liquidationDiscountValue,\n        uint256 devaluationPeriodValue,\n        uint256 usdpLimit\n    ) external;\n    function setDevaluationPeriod ( address asset, uint256 newValue ) external;\n    function setInitialCollateralRatio ( address asset, uint256 newValue ) external;\n    function setLiquidationDiscount ( address asset, uint256 newValue ) external;\n    function setLiquidationRatio ( address asset, uint256 newValue ) external;\n    function vaultParameters (  ) external view returns ( address );\n}\n"
    },
    "contracts/interfaces/ISuVaultParameters.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuVaultParameters {\n    function canModifyVault ( address ) external view returns ( bool );\n    function foundation (  ) external view returns ( address );\n    function isManager ( address ) external view returns ( bool );\n    function isOracleTypeEnabled ( uint256, address ) external view returns ( bool );\n    function liquidationFee ( address ) external view returns ( uint256 );\n    function setCollateral ( address asset, uint256 stabilityFeeValue, uint256 liquidationFeeValue, uint256 usdpLimit, uint256[] calldata oracles ) external;\n    function setFoundation ( address newFoundation ) external;\n    function setLiquidationFee ( address asset, uint256 newValue ) external;\n    function setManager ( address who, bool permit ) external;\n    function setOracleType ( uint256 _type, address asset, bool enabled ) external;\n    function setStabilityFee ( address asset, uint256 newValue ) external;\n    function setTokenDebtLimit ( address asset, uint256 limit ) external;\n    function setVaultAccess ( address who, bool permit ) external;\n    function stabilityFee ( address ) external view returns ( uint256 );\n    function tokenDebtLimit ( address ) external view returns ( uint256 );\n    function vault (  ) external view returns ( address );\n    function vaultParameters (  ) external view returns ( address );\n}\n"
    },
    "contracts/SuCdpRegistry.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./interfaces/ISuVault.sol\";\r\nimport \"./interfaces/ISuCollateralRegistry.sol\";\r\n\r\ncontract SuCdpRegistry {\r\n    // Collateral Debt Position\r\n    struct CDP {\r\n        address asset; // collateral token\r\n        address owner; // borrower account\r\n    }\r\n\r\n    // mapping from collateral token to list of borrowers?\r\n    mapping (address => address[]) cdpList;\r\n\r\n    // mapping from collateral token to borrower to the INDEX, index in the previous list?\r\n    mapping (address => mapping (address => uint)) cdpIndex;\r\n\r\n    // address of the vault contract\r\n    ISuVault public immutable vault;\r\n\r\n    // address of the collateral registry contract\r\n    ISuCollateralRegistry public immutable cr;\r\n\r\n    // event emitted when a new CDP is created\r\n    event Added(address indexed asset, address indexed owner);\r\n\r\n    // event emitted when a CDP is closed\r\n    event Removed(address indexed asset, address indexed owner);\r\n\r\n    // this contract is deployed after the vault and collateral registry\r\n    constructor (address _vault, address _collateralRegistry) {\r\n        require(_vault != address(0) && _collateralRegistry != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        vault = ISuVault(_vault);\r\n        cr = ISuCollateralRegistry(_collateralRegistry);\r\n    }\r\n\r\n    // anyone can create checkpoint?\r\n    function checkpoint(address asset, address owner) public {\r\n        require(asset != address(0) && owner != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        // only for listed assets\r\n        bool listed = isListed(asset, owner);\r\n\r\n        // only for alive assets\r\n        bool alive = isAlive(asset, owner);\r\n\r\n        if (alive && !listed) {\r\n            _addCdp(asset, owner);\r\n        } else if (listed && !alive) {\r\n            _removeCdp(asset, owner);\r\n        }\r\n    }\r\n\r\n    // checkpoint in loop\r\n    function batchCheckpointForAsset(address asset, address[] calldata owners) external {\r\n        for (uint i = 0; i < owners.length; i++) {\r\n            checkpoint(asset, owners[i]);\r\n        }\r\n    }\r\n\r\n    // multiple checkpoints for different collaterals\r\n    function batchCheckpoint(address[] calldata assets, address[] calldata owners) external {\r\n        require(assets.length == owners.length, \"Unit Protocol: ARGUMENTS_LENGTH_MISMATCH\");\r\n        for (uint i = 0; i < owners.length; i++) {\r\n            checkpoint(assets[i], owners[i]);\r\n        }\r\n    }\r\n\r\n    // alive means there are debts in the vault for this collateral of this borrower\r\n    function isAlive(address asset, address owner) public view returns (bool) {\r\n        return vault.debts(asset, owner) != 0;\r\n    }\r\n\r\n    // listed means there are created cdps in this contract for this collateral of this borrower\r\n    function isListed(address asset, address owner) public view returns (bool) {\r\n        if (cdpList[asset].length == 0) { return false; }\r\n        return cdpIndex[asset][owner] != 0 || cdpList[asset][0] == owner;\r\n    }\r\n\r\n    // internal function to perform removal of cdp from the list\r\n    function _removeCdp(address asset, address owner) internal {\r\n        // take the index by collateral and borrower\r\n        uint id = cdpIndex[asset][owner];\r\n\r\n        // then delete this index\r\n        delete cdpIndex[asset][owner];\r\n\r\n        // if the index is not the last one\r\n        uint lastId = cdpList[asset].length - 1;\r\n\r\n        // swap the last element with the element to be deleted\r\n        if (id != lastId) {\r\n            address lastOwner = cdpList[asset][lastId];\r\n            cdpList[asset][id] = lastOwner;\r\n            cdpIndex[asset][lastOwner] = id;\r\n        }\r\n\r\n        // delete the last element\r\n        cdpList[asset].pop();\r\n\r\n        // can we optimize this remove function by changing the structure?\r\n\r\n        emit Removed(asset, owner);\r\n    }\r\n\r\n    function _addCdp(address asset, address owner) internal {\r\n        // remember the index of the new element\r\n        cdpIndex[asset][owner] = cdpList[asset].length;\r\n\r\n        // add the new element to the end of the list\r\n        cdpList[asset].push(owner);\r\n\r\n        emit Added(asset, owner);\r\n    }\r\n\r\n    // read-only function to get the list of cdps for a given collateral\r\n    function getCdpsByCollateral(address asset) external view returns (CDP[] memory cdps) {\r\n        address[] memory owners = cdpList[asset];\r\n        cdps = new CDP[](owners.length);\r\n        for (uint i = 0; i < owners.length; i++) {\r\n            cdps[i] = CDP(asset, owners[i]);\r\n        }\r\n    }\r\n\r\n    // read-only function to get the list of all cdps by borrower\r\n    function getCdpsByOwner(address owner) external view returns (CDP[] memory r) {\r\n        address[] memory assets = cr.collaterals();\r\n        CDP[] memory cdps = new CDP[](assets.length);\r\n        uint actualCdpsCount;\r\n\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            if (isListed(assets[i], owner)) {\r\n                cdps[actualCdpsCount++] = CDP(assets[i], owner);\r\n            }\r\n        }\r\n\r\n        r = new CDP[](actualCdpsCount);\r\n\r\n        for (uint i = 0; i < actualCdpsCount; i++) {\r\n            r[i] = cdps[i];\r\n        }\r\n\r\n    }\r\n\r\n    // read-only function to get the list of all cdps\r\n    function getAllCdps() external view returns (CDP[] memory r) {\r\n        uint totalCdpCount = getCdpsCount();\r\n        \r\n        uint cdpCount;\r\n\r\n        r = new CDP[](totalCdpCount);\r\n\r\n        address[] memory assets = cr.collaterals();\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            address[] memory owners = cdpList[assets[i]];\r\n            for (uint j = 0; j < owners.length; j++) {\r\n                r[cdpCount++] = CDP(assets[i], owners[j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // total number of cdps\r\n    function getCdpsCount() public view returns (uint totalCdpCount) {\r\n        address[] memory assets = cr.collaterals();\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            totalCdpCount += cdpList[assets[i]].length;\r\n        }\r\n    }\r\n\r\n    // number of cdps for a given collateral\r\n    function getCdpsCountForCollateral(address asset) public view returns (uint) {\r\n        return cdpList[asset].length;\r\n    }\r\n}"
    },
    "contracts/interfaces/ISuCollateralRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface ISuCollateralRegistry {\n    function addCollateral ( address asset ) external;\n    function collateralId ( address ) external view returns ( uint256 );\n    function collaterals (  ) external view returns ( address[] memory );\n    function removeCollateral ( address asset ) external;\n    function vaultParameters (  ) external view returns ( address );\n    function isCollateral ( address asset ) external view returns ( bool );\n    function collateralList ( uint id ) external view returns ( address );\n    function collateralsCount (  ) external view returns ( uint );\n}\n"
    },
    "contracts/SuOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0 <0.9.0;\n\n/*\n    OracleAggregator\n        getUsdPrice asset -> id -> call to implementation\n    we have several oracle implementations of ISuOracle,\n    1) SuChainlinkOracle\n    2) SuKeydonixOracle\n    TODO: how would you make it work with keydonix (TWAT univ2)?\n*/\n\nimport \"./interfaces/ISuOracle.sol\";\n\ncontract SuOracleAggregator is ISuOracle {\n    mapping (address => uint256) public assetToOracle;\n    mapping (uint256 => ISuOracle) public oracleImplementations;\n\n    /**\n    * @notice returns price1e18(assert) such that:\n    *   [assetAmount * price1e18(assert) / 1e18 === $$ 1e18] == suUSD\n    *   examples:\n    *       market price of btc = $30k,\n    *       for 0.1 wBTC the unit256 amount is 0.1 * 1e18\n    *       0.1 * 1e18 * (price1e18 / 1e18) == $3000 == uint256(3000*1e18)\n    *       => price1e18 = 30000 * 1e18;\n\n    *       market price of usdt = $0.97,\n    *       for 1 usdt uint256 = 1 * 1e6\n    *       so 1*1e6 * price1e18 / 1e18 == $0.97 == uint256(0.97*1e18)\n    *       => 1*1e6 * (price1e18 / 1e18) / (0.97*1e18)   = 1\n    *       =>  price1e18 = 0.97 * (1e18/1e6) * 1e18\n    * @param asset of erc20 token\n    * @return price1e18 such as asset.balanceOf() * price1e18 / 1e18 == $$ 1e18\n    **/\n    function getUsdPrice1e18(address asset) override view external returns (uint256) {\n        uint256 oracleId = assetToOracle[asset];\n        require(oracleId != 0, \"No oracle for the asset\");\n    }\n\n    /**\n    * @notice assign address of oracle implementation to the oracleId\n    * @param oracleId - number 0,1, etc to assign the oracle\n    * @param oracleImplementation - an address with ISuOracle implementation contract\n    **/\n    function setOracleImplementation(uint256 oracleId, ISuOracle oracleImplementation) external {\n        require(oracleId != 0, \"OracleId == 0\");\n        require(address(oracleImplementation) != address(0), \"OracleImplementation == 0\");\n        oracleImplementations[oracleId] = oracleImplementation;\n    }\n\n    /**\n    * @notice specify what oracleId should be used for each assets. Checks that oracleId has an implementation\n    **/\n    function setOracleIdForAssets(address[] memory assets, uint256 oracleId) external {\n        require(address(oracleImplementations[oracleId]) != address(0), \"OracleImplementation == 0\");\n        for (uint256 i = 0; i < assets.length; i++) {\n            assetToOracle[assets[i]] = oracleId;\n        }\n    }\n}"
    },
    "contracts/SuChainlinkOracle.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/ISuOracle.sol\";\n\ncontract SuChainlinkOracle is ISuOracle, Ownable {\n    mapping (address => address) public assetToFeed;\n    mapping (address => uint8) public assetToDecimals;\n\n    function setAssetFeed(address _collateral, address _feed, uint8 _decimals) external onlyOwner {\n        assetToFeed[_collateral] = _feed;\n        assetToDecimals[_collateral] = _decimals;\n    }\n\n    function getUsdPrice1e18(address asset) public override view returns (uint) {\n        address feed = assetToFeed[asset];\n        uint8 decimals = assetToDecimals[asset];\n        \n        (\n            /*uint80 roundID*/,\n            int256 answer,\n            /*uint256 startedAt*/,\n            /*uint256 updatedAt*/,\n            /*uint80 answeredInRound*/\n        ) = AggregatorV3Interface(feed).latestRoundData();\n\n        int256 price = scalePrice(answer, decimals, 18);\n\n        return uint(price);\n    }\n\n    function scalePrice(int256 _price, uint8 _priceDecimals, uint8 _decimals)\n        internal\n        pure\n        returns (int256)\n    {\n        if (_priceDecimals < _decimals) {\n            return _price * int256(10 ** uint256(_decimals - _priceDecimals));\n        } else if (_priceDecimals > _decimals) {\n            return _price / int256(10 ** uint256(_priceDecimals - _decimals));\n        }\n        return _price;\n    }    \n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/mocks/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ISuOracle.sol\";\n\ncontract MockOracle is ISuOracle, Ownable {\n    constructor() {\n    }\n\n    mapping (address => uint256) assets;\n\n    function getUsdPrice1e18(address asset) override external view returns (uint) {\n        return assets[asset] * 10**18;\n    }\n\n    function setPrice(address asset, uint256 price) public onlyOwner {\n        assets[asset] = price;\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/mocks/MockWBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract MockWBTC is ERC20 {\n    constructor() ERC20(\"WBTC\", \"WBTC\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), currentAllowance - amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract MockUSDT is ERC20 {\n    constructor() ERC20(\"USDT\", \"USDT\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}"
    },
    "contracts/MockCollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockCollateral is ERC20, Ownable {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n    }\n}"
    },
    "contracts/MockExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockExchange is Ownable {\n    mapping (address => mapping (address => uint256)) public rates;\n    \n    constructor() {}\n\n    function setRate(address _tokenFrom, address _tokenTo, uint256 _rate) public onlyOwner {\n        rates[_tokenFrom][_tokenTo] = _rate;\n    }\n\n    function execute(\n        address tokenFrom,\n        address tokenTo,\n        uint256 amountFrom\n    ) public returns (bool) {\n        IERC20(tokenFrom).transferFrom(msg.sender, address(this), amountFrom);\n\n        uint256 amountTo = amountFrom * rates[tokenFrom][tokenTo];\n\n        if (amountTo == 0) {\n            amountTo = amountFrom * rates[tokenTo][tokenFrom] / 10**18;\n        \n            if (amountTo == 0) {\n                revert(\"No rate set\");\n            }\n        }\n\n        IERC20(tokenTo).transfer(msg.sender, amountTo);\n    \n        return true;\n    }\n}"
    },
    "contracts/mocks/MockV3Aggregator.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// FluxAggregator\n// AggregatorV2V3Interface\ncontract MockV3Aggregator is AggregatorV3Interface {\n  uint256 override constant public version = 0;\n\n  uint8 override public decimals;\n  int256 public latestAnswer;\n  uint256 public latestTimestamp;\n  uint256 public latestRound;\n\n  mapping(uint256 => int256) public getAnswer;\n  mapping(uint256 => uint256) public getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(\n    uint8 _decimals,\n    int256 _initialAnswer\n  ) {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(\n    int256 _answer\n  ) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(\n    uint80 _roundId,\n    int256 _answer,\n    uint256 _timestamp,\n    uint256 _startedAt\n  ) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (\n      _roundId,\n      getAnswer[_roundId],\n      getStartedAt[_roundId],\n      getTimestamp[_roundId],\n      _roundId\n    );\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description()\n    external\n    view\n    override\n    returns (string memory)\n  {\n    return \"\";\n  }  \n}"
    },
    "contracts/SuVault.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"./original-unit-contracts/helpers/SafeMath.sol\";\nimport \"./SuVaultParameters.sol\";\nimport \"./original-unit-contracts/helpers/TransferHelper.sol\";\nimport \"./SuUSD.sol\";\nimport \"./original-unit-contracts/interfaces/IWETH.sol\";\n\ncontract SuVault is Auth {\n    // don't need anymore in modern solidity?\n    /// correct\n    using SafeMath for uint;\n\n    // dont need theirs token \n    /// yes\n    address public immutable col;\n\n    // only wrapped ether will be supported\n    /// yes\n    address payable public immutable weth;\n\n    // 10^5 = 100000\n    uint public constant DENOMINATOR_1E5 = 1e5;\n\n    // 10^2 = 100\n    uint public constant DENOMINATOR_1E2 = 1e2;\n\n    // token itself - will be unit stable coin\n    address public immutable usdp;\n\n    // which tokens are allowed as collateral; what's the int value - min threshold or rate?\n    /// No, it's how much user had stacked collaterael asset == collaterals[asset][user], i.e deposits\n    mapping(address => mapping(address => uint)) public collaterals;\n\n    // the same but for theirs token - can be ignored\n    mapping(address => mapping(address => uint)) public colToken;\n\n    // mapping of user address to integer value; which is the amount of debt represented by what?\n    /// Yes, in stablecoin amount, == debts[asset][user]\n    // or might be it mapping fro token address into total debt amount?\n    mapping(address => mapping(address => uint)) public debts;\n\n    // liquidation can be triggered by permissionless-action?\n    /// Yes\n    // then the process begins and we remember which block it started at\n    // is it indexed by collateral token address?\n    /// Yes ,  liquidationBlock[asset][user]\n    mapping(address => mapping(address => uint)) public liquidationBlock;\n\n    // mapping of collateral address to liquidation price;\n    // when and who decides on the collateral price, is that dynamic?\n    /// see line 287 triggerLiquidation: liquidationPrice[asset][positionOwner] = initialPrice;\n    mapping(address => mapping(address => uint)) public liquidationPrice;\n\n    // mapping of address to integer for token debts;\n    // what'is the units of measurement?\n    /// How much stablecoin was borrowed against particular asset == tokenDebts[asset]  \n    mapping(address => uint) public tokenDebts;\n\n    // double mapping probably from collateral to each user to debt\n    // how is stability fee calculated and where is it paid and when?\n    /// current interest that user pay for stabilityFee[asset][user]\n    mapping(address => mapping(address => uint)) public stabilityFee;\n\n    // another similar mapping for another fee, how is liquidation fee different from stability fee?\n    // can we combine both mapping into single mapping to structure?\n    /// Penalty during liquidation\n    mapping(address => mapping(address => uint)) public liquidationFee;\n\n    // mapping for oracles; are there different oracle types? who is allowed to choose oracle?\n    // oracles are passive\n    /// ID of oracle contact for oracleType[asset][user]\n    mapping(address => mapping(address => uint)) public oracleType;\n\n    // mapping for timestamps;\n    // why do we need timestamps? how do we calculate medium price when merging positions?\n    /// everything before lastUpdates is already calced in the debt. all data such as fees are from lastUpdate only\n    mapping(address => mapping(address => uint)) public lastUpdate;\n\n    // check if liquidation process not started for asset of user\n    /// YES\n    modifier notLiquidating(address asset, address user) {\n        require(liquidationBlock[asset][user] == 0, \"Unit Protocol: LIQUIDATING_POSITION\");\n        _;\n    }\n\n    // vault is initialize with parameters for auth (we are using OZ instead)\n    // and it accept address for wrapped eth, main stable coin, and probably governance token\n    /// YES\n    constructor(address _parameters, address _col, address _usdp, address payable _weth) Auth(_parameters) {\n        col = _col;\n        usdp = _usdp;\n        weth = _weth;\n    }\n\n    // do not accept direct payments from users because they will be stuck on contract address\n    /// YES, does work for erc20\n    receive() external payable {\n        require(msg.sender == weth, \"Unit Protocol: RESTRICTED\");\n    }\n\n     // who does have vault access?\n     /// anyone from canModifyVault\n     // why position is not allowed to be modified during liquidation?\n     /// because when it's launched - liquidators want to be sure they can participate\n     // how often update can be triggered?\n     /// when user borrows more \n    function update(address asset, address user) public hasVaultAccess notLiquidating(asset, user) {\n        \n        // probably should be checked if zero then skip\n        /// \n        uint debtWithFee = getTotalDebt(asset, user);\n\n        // we decrease token debt by current debt and increase by new debt\n        // can we just set new value instead?\n        tokenDebts[asset] = tokenDebts[asset].sub(debts[asset][user]).add(debtWithFee);\n        \n        // we set new debt for asset of user\n        debts[asset][user] = debtWithFee;\n\n        // we also set new fee\n        stabilityFee[asset][user] = vaultParameters.stabilityFee(asset);\n        \n        // we also set new fee\n        liquidationFee[asset][user] = vaultParameters.liquidationFee(asset);\n        \n        // and update timestamp\n        lastUpdate[asset][user] = block.timestamp;\n    }\n\n     // spawn means to create new debt position for user\n     // it accepts collateral token address and user and chosen oracle type\n     // this function is not called by user but by special priviliged account?\n     /// yes, by CDP manager 01\n     // what are the options for oracle type?\n     /// all implementation are numbered\n    function spawn(address asset, address user) external hasVaultAccess notLiquidating(asset, user) {\n        \n        // why its being removed and which cases its not empty?\n        /// could be liquidationBlock[asset][user] = 0;\n        delete liquidationBlock[asset][user];\n    }\n\n    // does it help to restore gas fees? what's the purpose of cleanup?\n    /// Not clear for after London hardfork\n    // how do ensure its not being called unexpectedly? very dangerous function \n    /// only destroy debt info, exit -> _repay -> destroy if debt == 0\n    function destroy(address asset, address user) public hasVaultAccess notLiquidating(asset, user) {\n        delete stabilityFee[asset][user];\n        delete oracleType[asset][user];\n        delete lastUpdate[asset][user];\n        delete liquidationFee[asset][user];\n    }\n\n     // collateral deposit\n    function depositMain(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\n        collaterals[asset][user] = collaterals[asset][user].add(amount);\n        TransferHelper.safeTransferFrom(asset, user, address(this), amount);\n    }\n\n    // wrapped ether deposit\n    // can be called by anyone? how do we reject weth transfers by mistake?\n    function depositEth(address user) external payable notLiquidating(weth, user) {\n        IWETH(weth).deposit{value: msg.value}();\n        collaterals[weth][user] = collaterals[weth][user].add(msg.value);\n    }\n\n     // collateral withdraw\n     // why being called by privileged account and not by user?\n    function withdrawMain(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\n        collaterals[asset][user] = collaterals[asset][user].sub(amount);\n        TransferHelper.safeTransfer(asset, user, amount);\n    }\n\n    // withdraw wrapper ether\n    function withdrawEth(address payable user, uint amount) external hasVaultAccess notLiquidating(weth, user) {\n        collaterals[weth][user] = collaterals[weth][user].sub(amount);\n        IWETH(weth).withdraw(amount);\n        TransferHelper.safeTransferETH(user, amount);\n    }\n\n    // this can be ignored\n    function depositCol(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\n        colToken[asset][user] = colToken[asset][user].add(amount);\n        TransferHelper.safeTransferFrom(col, user, address(this), amount);\n    }\n\n    // this can be ignored\n    function withdrawCol(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\n        colToken[asset][user] = colToken[asset][user].sub(amount);\n        TransferHelper.safeTransfer(col, user, amount);\n    }\n\n     // BORROW == takeUnit\n     /// yes, fro cdpManager01\n     // user expected previously to deposit collateral and then being able to take stablecoin\n     // but where do we check current user collateral and amount??\n     /// in CDPManager01\n     // can user create single position with multiple collaterals?\n     /// no, one debt for [asset][user]\n    function borrow(\n        address asset,\n        address user,\n        uint amount\n    )\n    external\n    hasVaultAccess\n    notLiquidating(asset, user)\n    returns(uint)\n    {\n        // update debts and fees of user for collateral\n        /// I think better name is needed\n        update(asset, user);\n\n        // why we update it again after update already called?\n        /// becaause update doesn't use amount, only calc curr fees\n        debts[asset][user] = debts[asset][user].add(amount);\n        tokenDebts[asset] = tokenDebts[asset].add(amount);\n\n        // there is a limit of total debt for each collateral\n        // why that limit is needed?\n        /// because of risk profile\n        require(tokenDebts[asset] <= vaultParameters.tokenDebtLimit(asset), \"Unit Protocol: ASSET_DEBT_LIMIT\");\n\n        // here stablecoin is created for user\n        SuUSD(usdp).mint(user, amount);\n\n        // we return value of previous debt plus new debt\n        // how this can be accessed and used by client?\n        // should consider to emit events instead\n        return debts[asset][user];\n    }\n\n    // REPAY == giveUnit\n    /// return for the debt\n    function repay(\n        address asset,\n        address user,\n        uint amount\n    )\n    external\n    hasVaultAccess\n    notLiquidating(asset, user)\n    returns(uint)\n    {\n        // current debt of user by given collateral\n        uint debt = debts[asset][user];\n        \n        // is being decreased by chosen amount\n        debts[asset][user] = debt.sub(amount);\n\n        // total debt by asset is being decreased too\n        // this value is used to limit total collateral allowed debt\n        tokenDebts[asset] = tokenDebts[asset].sub(amount);\n\n        // we burn stablecoin from user\n        // vault should have corresponding permission\n        SuUSD(usdp).burn(user, amount);\n\n        // after we burn stablecoin we need to take back collateral\n        // does that happen in another contract which calls this function?\n\n        return debts[asset][user];\n    }\n\n    // transfering chosen amount chosen asset from user to foundation address\n    // can foundation address be changed?\n    /// Yes, setFoundation.\n    // why its being transferred from user? instead should be from this vault\n    /// TODO: he doesn't have his vault with usdp\n    // why amount is chosen manually? should be always the same value as in fees mapping\n    /// this is just tranfer function, manager calc fees\n    function chargeFee(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\n        if (amount != 0) {\n            TransferHelper.safeTransferFrom(asset, user, vaultParameters.foundation(), amount);\n        }\n    }\n\n    // position liquidation being triggerred by another contract\n    // initial price is passed here but better it would be accessed from mapping directly\n    /// it's Vault so Manager does tells it what to do.\n    function triggerLiquidation(\n        address asset,\n        address positionOwner,\n        uint initialPrice\n    )\n    external\n    hasVaultAccess\n    notLiquidating(asset, positionOwner)\n    {\n        // why debt recalculation is needed and which cases it can be outdated?\n        /// because function called from CDPManger01.triggerLiquidation which doesn't call update\n        debts[asset][positionOwner] = getTotalDebt(asset, positionOwner);\n\n        // remember when liquidation start and which price\n        liquidationBlock[asset][positionOwner] = block.number;\n        liquidationPrice[asset][positionOwner] = initialPrice;\n    }\n\n\n\n\n     // liquidation can happen after liquidator is chosen through auction\n     // and auction starts after liquidation starting process has triggered\n     /// YES\n     // liquidator accepts a deal to give minimum amount of stablecoin and receive all position collateral\n     /// NO, \n     // mainAsset is collateral\n     /// YES\n     // why col is needed? can be ignored\n     /// CORRECT\n     // what is repayment and what is penalty?\n     /// \n     // what happens if liquidator does not execute agreed transaction?\n     /// \n     // borrower should receive some part of stablecoin given by liquidator\n     /// POSSIBLY\n     // how is that portion calculated and where the rest goes?\n     /// YES, please see _liquidate at LiquidationAunction02\n     // will stablecoin paid by liquidator be burned immediately?\n     /// Yes\n     // how can cascading liquidation happen step by step?\n     /// please see https://ratiofinance.medium.com/ratio-risk-lesson-2-cascading-liquidations-e91e04050f47\n    function liquidate(\n        address asset,\n        address positionOwner,\n        uint mainAssetToLiquidator,\n        uint colToLiquidator,\n        uint mainAssetToPositionOwner,\n        uint colToPositionOwner,\n        uint repayment,\n        uint penalty,\n        address liquidator\n    )\n        external\n        hasVaultAccess\n    {\n        require(liquidationBlock[asset][positionOwner] != 0, \"Unit Protocol: NOT_TRIGGERED_LIQUIDATION\");\n\n        uint mainAssetInPosition = collaterals[asset][positionOwner];\n\n        uint mainAssetToFoundation = mainAssetInPosition.sub(mainAssetToLiquidator).sub(mainAssetToPositionOwner);\n\n        uint colInPosition = colToken[asset][positionOwner];\n        uint colToFoundation = colInPosition.sub(colToLiquidator).sub(colToPositionOwner);\n\n        delete liquidationPrice[asset][positionOwner];\n        delete liquidationBlock[asset][positionOwner];\n        delete debts[asset][positionOwner];\n        delete collaterals[asset][positionOwner];\n        delete colToken[asset][positionOwner];\n\n        destroy(asset, positionOwner);\n\n        if (repayment > penalty) {\n            if (penalty != 0) {\n                TransferHelper.safeTransferFrom(usdp, liquidator, vaultParameters.foundation(), penalty);\n            }\n            SuUSD(usdp).burn(liquidator, repayment.sub(penalty));\n        } else {\n            if (repayment != 0) {\n                TransferHelper.safeTransferFrom(usdp, liquidator, vaultParameters.foundation(), repayment);\n            }\n        }\n\n        if (mainAssetToLiquidator != 0) {\n            TransferHelper.safeTransfer(asset, liquidator, mainAssetToLiquidator);\n        }\n\n        if (colToLiquidator != 0) {\n            TransferHelper.safeTransfer(col, liquidator, colToLiquidator);\n        }\n\n        if (mainAssetToPositionOwner != 0) {\n            TransferHelper.safeTransfer(asset, positionOwner, mainAssetToPositionOwner);\n        }\n\n        if (colToPositionOwner != 0) {\n            TransferHelper.safeTransfer(col, positionOwner, colToPositionOwner);\n        }\n\n        if (mainAssetToFoundation != 0) {\n            TransferHelper.safeTransfer(asset, vaultParameters.foundation(), mainAssetToFoundation);\n        }\n\n        if (colToFoundation != 0) {\n            TransferHelper.safeTransfer(col, vaultParameters.foundation(), colToFoundation);\n        }\n    }\n\n    // oracle type can be changed manager, under which conditions?\n    /// any time\n    function changeOracleType(address asset, address user, uint newOracleType) external onlyManager {\n        oracleType[asset][user] = newOracleType;\n    }\n\n    // total dept is calculated as current debt with added calculated fee\n    /// they don't use it in practice\n    function getTotalDebt(address asset, address user) public view returns (uint) {\n        uint debt = debts[asset][user];\n        if (liquidationBlock[asset][user] != 0) return debt;\n        uint fee = calculateFee(asset, user, debt);\n        return debt.add(fee);\n    }\n\n     // fee is increased with time and \n     /// YES\n     // decreased when partial repayment is made \n     /// No, any call of valult.update would calc fee in debt and restart fee timer\n    function calculateFee(address asset, address user, uint amount) public view returns (uint) {\n        uint sFeePercent = stabilityFee[asset][user];\n        uint timePast = block.timestamp.sub(lastUpdate[asset][user]);\n\n        return amount.mul(sFeePercent).mul(timePast).div(365 days).div(DENOMINATOR_1E5);\n    }\n}\n"
    },
    "contracts/SuVaultParameters.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\n\r\n\r\n// proxy for VaultParameters - other contracts should be inherited from here\r\n// this contract contains modifiers used in VaultParameters contract\r\n// it should be an abstract class because it cannot by instantiated/deployed directly,\r\n// its supposed to be inherited by VaultParameters contract which is deployed \r\n/// yes\r\ncontract Auth {\r\n    // but actually it does store address to vaultParameters contract?\r\n    SuVaultParameters public vaultParameters;\r\n\r\n    // its the same time parent of VaultParameters (inheritance)\r\n    // and same time its linking to VaultParameters (composition)\r\n    // one approach should be chosen: either inheritance or composition\r\n    // otherwise its very confusing\r\n    /// No, it's singleton\r\n    constructor(address _parameters) {\r\n        vaultParameters = SuVaultParameters(_parameters);\r\n    }\r\n\r\n    // check manager permission\r\n    modifier onlyManager() {\r\n        require(vaultParameters.isManager(msg.sender), \"Unit Protocol: onlyManager AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // check permission to modify vault\r\n    modifier hasVaultAccess() {\r\n        require(vaultParameters.canModifyVault(msg.sender), \"Unit Protocol: hasVaultAccess AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // check vault permission\r\n    modifier onlyVault() {\r\n        require(msg.sender == vaultParameters.vault(), \"Unit Protocol: onlyVault AUTH_FAILED\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// VaultParameters is Singleton for Access Control\r\n// this looks like configuration contract\r\n// what are the rules to determine these configs for each new allowed collateral?\r\n/// yes, and for all collaterals\r\n// is DAO allowed to choose parameters for existing collaterals?\r\n/// \r\n// are there any limits to be enforced? i.e. fee cannot be over 100% percent\r\n/// No, but it's a good idea to have it\r\ncontract SuVaultParameters is Auth {\r\n    // stability fee can be different for each collateral\r\n    /// yes\r\n    mapping(address => uint) public stabilityFee;\r\n\r\n    // liquidation fee too can be different\r\n    /// yes\r\n    mapping(address => uint) public liquidationFee;\r\n\r\n    // map token to USDP mint limit\r\n    /// yes, limit for each collateral-assert\r\n    mapping(address => uint) public tokenDebtLimit;\r\n\r\n    // permissions to modify the Vault\r\n    mapping(address => bool) public canModifyVault;\r\n\r\n    // whether an account is manager\r\n    mapping(address => bool) public isManager;\r\n\r\n    // whether an oracle is enabled\r\n    /// TODO:\r\n    mapping(uint => mapping (address => bool)) public isOracleTypeEnabled;\r\n\r\n    // linked to the vault contract\r\n    // I think its better to inherit Vault from VaultParameters\r\n    /// NO, needed for onlyVault modifier\r\n    address payable public vault;\r\n\r\n    // what is foundation, DAO?\r\n    /// Beneficiaty as VotingEscrow.vy\r\n    address public foundation;\r\n\r\n    // creator of contract is manager, can it be the same as DAO or can it be removed later?\r\n    /// YES\r\n    // how can vault address be known at this moment?\r\n    /// Precult based on CREATE spec\r\n    // can be created another function to set vault address once deployed?\r\n    /// Yes, possibly with some logic change\r\n    constructor(address payable _vault, address _foundation) Auth(address(this)) {\r\n        require(_vault != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(_foundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        isManager[msg.sender] = true;\r\n        vault = _vault;\r\n        foundation = _foundation;\r\n    }\r\n\r\n     // existing managers can enable other managers\r\n     // one manager can disable all other managers - dangerous?\r\n     /// YES, could be dangerous\r\n    function setManager(address who, bool permit) external onlyManager {\r\n        isManager[who] = permit;\r\n    }\r\n\r\n    // similar function can be added to setVault\r\n    function setFoundation(address newFoundation) external onlyManager {\r\n        require(newFoundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        foundation = newFoundation;\r\n    }\r\n\r\n     // manager is allowed to add new collaterals and modify existing ones\r\n     // I think creating new collaterals and modifying existing ones should be separate functions\r\n     /// Yes, for sercurity reason, it's possible to add events for creating and edititing \r\n     // also different event should be emitted NewCollateral UpdatedCollateral accordingly\r\n     // those events can be handled on frontend to notify user about any changes in rules\r\n     /// Not sure it makes sense to split into create/edit functions\r\n    function setCollateral(\r\n        address asset,\r\n        uint stabilityFeeValue,\r\n        uint liquidationFeeValue,\r\n        uint usdpLimit\r\n    ) external onlyManager {\r\n        // stability fee should be validated in range, what is stability fee should be described here?\r\n        setStabilityFee(asset, stabilityFeeValue);\r\n        // liquidation fee should be validated in range, what is liquidation fee should be explained?\r\n        setLiquidationFee(asset, liquidationFeeValue);\r\n        // why debt limit for collateral is necessary? to manage risks in case of collateral failure?\r\n        setTokenDebtLimit(asset, usdpLimit);\r\n    }\r\n\r\n     // manager can choose who is allowed to modify vault, \r\n     // what does it mean to modify vault and why permission separate from manager himself?\r\n     /// https://en.wikipedia.org/wiki/Principle_of_least_privilege \r\n    function setVaultAccess(address who, bool permit) external onlyManager {\r\n        canModifyVault[who] = permit;\r\n    }\r\n\r\n    // stability fee is measured as the number of coins per year or percentage? \r\n    // this should be clarified in argument name i.e. stabilityFeePercentageYearly\r\n    /// No, it's APR ( per year, see calculateFee) percentrage, fee percentage; 3 decimals.\r\n    /// YES, self-documented code-style is the best practice.\r\n    function setStabilityFee(address asset, uint newValue) public onlyManager {\r\n        stabilityFee[asset] = newValue;\r\n    }\r\n\r\n    // the same with liquidation fee is not clear\r\n    /// % 0 decimals, needede to get better variable names\r\n    function setLiquidationFee(address asset, uint newValue) public onlyManager {\r\n        require(newValue <= 100, \"Unit Protocol: VALUE_OUT_OF_RANGE\");\r\n        liquidationFee[asset] = newValue;\r\n    }\r\n\r\n     // what are allowed types? enum should be defined\r\n     // types out of range should fail transaction\r\n    /// All oracles implementation are numbered, so some of them support this particular asset\r\n    function setOracleType(uint _type, address asset, bool enabled) public onlyManager {\r\n        isOracleTypeEnabled[_type][asset] = enabled;\r\n    }\r\n\r\n     // debt limit can be changed for any collateral along with liquidation and stability fees\r\n     // seems like managers have too much power - that can be dangerous given multiple managers?\r\n     /// Yes, application of  principle of least priviledge needed\r\n    function setTokenDebtLimit(address asset, uint limit) public onlyManager {\r\n        tokenDebtLimit[asset] = limit;\r\n    }\r\n}\r\n"
    },
    "contracts/original-unit-contracts/helpers/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\n\r\n// library to extend contracts with helper methods\r\n// which are the contracts where its being used?\r\nlibrary TransferHelper {\r\n    // internal function to approve\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // function signature should be inline variable instead \r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        \r\n        // what is difference between success=false OR data.length = 0 OR data encoded ?\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    // internal function to transfer\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    // internal function to transfer from\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    // internal function to transfer eth\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/SuUSD.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"./SuVaultParameters.sol\";\nimport \"./original-unit-contracts/helpers/SafeMath.sol\";\n\ncontract SuUSD is Auth {\n    using SafeMath for uint;\n\n    // our name will be UNIT\n    string public constant name = \"USDP Stablecoin\";\n\n    // symbol UNIT\n    string public constant symbol = \"USDP\";\n\n    // can it be redeployed? can it be any other value?\n    /// i think it useless\n    string public constant version = \"1\";\n\n    // always 18 decimals the same like ETH\n    uint8 public constant decimals = 18;\n\n    // how many dollars in circulation\n    uint public totalSupply;\n\n    // balance of each account\n    mapping(address => uint) public balanceOf;\n\n    // how many dollars one address is allowed to transfer from another\n    mapping(address => mapping(address => uint)) public allowance;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor(address _parameters) Auth(_parameters) {}\n\n    /**\n      * @notice Only Vault can mint USDP\n      * @dev Mints 'amount' of tokens to address 'to', and MUST fire the\n      * Transfer event\n      * @param to The address of the recipient\n      * @param amount The amount of token to be minted\n     **/\n\n     // dollars can be minted by vault (once user deposited collateral)\n    function mint(address to, uint amount) external onlyVault {\n        require(to != address(0), \"Unit Protocol: ZERO_ADDRESS\");\n\n        balanceOf[to] = balanceOf[to].add(amount);\n        totalSupply = totalSupply.add(amount);\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    // dollars can be burned by manager but only his own dollars\n    // which managers will be using this feature? burning protocol fees?\n    function burn(uint amount) external onlyManager {\n        _burn(msg.sender, amount);\n    }\n\n     // also vault is allowed to burn dollars of any account\n     // when user repays his loan and takes back his collateral\n    function burn(address from, uint amount) external onlyVault {\n        _burn(from, amount);\n    }\n\n    // I think transfer and transferFrom should execute the same internal function\n    // instead of transfer executing transferFrom\n    function transfer(address to, uint amount) external returns (bool) {\n        return transferFrom(msg.sender, to, amount);\n    }\n\n    // implementation by standard - allows one user to transfer from another account\n    // in which cases our contracts will utilize this ability?\n    function transferFrom(address from, address to, uint amount) public returns (bool) {\n        require(to != address(0), \"Unit Protocol: ZERO_ADDRESS\");\n        require(balanceOf[from] >= amount, \"Unit Protocol: INSUFFICIENT_BALANCE\");\n\n        if (from != msg.sender) {\n            require(allowance[from][msg.sender] >= amount, \"Unit Protocol: INSUFFICIENT_ALLOWANCE\");\n            _approve(from, msg.sender, allowance[from][msg.sender].sub(amount));\n        }\n        balanceOf[from] = balanceOf[from].sub(amount);\n        balanceOf[to] = balanceOf[to].add(amount);\n\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    // at which point in user experience will he send approve transaction?\n    function approve(address spender, uint amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    // alternative to approve\n    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    // to manage amount granuarly\n    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    // in our case we inherit from OZ and these function are there\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"Unit Protocol: approve from the zero address\");\n        require(spender != address(0), \"Unit Protocol: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // as well this one inherited from OZ\n    function _burn(address from, uint amount) internal virtual {\n        balanceOf[from] = balanceOf[from].sub(amount);\n        totalSupply = totalSupply.sub(amount);\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/SuVaultManagerParameters.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\n/*\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\n*/\npragma solidity ^0.8.0;\n\nimport \"./SuVaultParameters.sol\";\n\n/**\n * @title VaultManagerParameters\n **/\ncontract SuVaultManagerParameters is Auth {\n\n    // determines the minimum percentage of COL token part in collateral, 0 decimals\n    mapping(address => uint) public minColPercent;\n\n    // determines the maximum percentage of COL token part in collateral, 0 decimals\n    mapping(address => uint) public maxColPercent;\n\n    // map token to initial collateralization ratio; 0 decimals\n    mapping(address => uint) public initialCollateralRatio;\n\n    // map token to liquidation ratio; 0 decimals\n    mapping(address => uint) public liquidationRatio;\n\n    // map token to liquidation discount; 3 decimals\n    mapping(address => uint) public liquidationDiscount;\n\n    // map token to devaluation period in blocks\n    mapping(address => uint) public devaluationPeriod;\n\n    constructor(address _vaultParameters) Auth(_vaultParameters) {}\n\n    function setCollateral(\n        address asset,\n        uint stabilityFeeValue,\n        uint liquidationFeeValue,\n        uint initialCollateralRatioValue,\n        uint liquidationRatioValue,\n        uint liquidationDiscountValue,\n        uint devaluationPeriodValue,\n        uint usdpLimit\n    ) external onlyManager {\n        vaultParameters.setCollateral(asset, stabilityFeeValue, liquidationFeeValue, usdpLimit);\n        setInitialCollateralRatio(asset, initialCollateralRatioValue);\n        setLiquidationRatio(asset, liquidationRatioValue);\n        setDevaluationPeriod(asset, devaluationPeriodValue);\n        setLiquidationDiscount(asset, liquidationDiscountValue);\n    }\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets the initial collateral ratio\n     * @param asset The address of the main collateral token\n     * @param newValue The collateralization ratio (0 decimals)\n     **/\n    function setInitialCollateralRatio(address asset, uint newValue) public onlyManager {\n        require(newValue != 0 && newValue <= 100, \"Unit Protocol: INCORRECT_COLLATERALIZATION_VALUE\");\n        initialCollateralRatio[asset] = newValue;\n    }\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets the liquidation ratio\n     * @param asset The address of the main collateral token\n     * @param newValue The liquidation ratio (0 decimals)\n     **/\n    function setLiquidationRatio(address asset, uint newValue) public onlyManager {\n        require(newValue != 0 && newValue >= initialCollateralRatio[asset], \"Unit Protocol: INCORRECT_COLLATERALIZATION_VALUE\");\n        liquidationRatio[asset] = newValue;\n    }\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets the liquidation discount\n     * @param asset The address of the main collateral token\n     * @param newValue The liquidation discount (3 decimals)\n     **/\n    function setLiquidationDiscount(address asset, uint newValue) public onlyManager {\n        require(newValue < 1e5, \"Unit Protocol: INCORRECT_DISCOUNT_VALUE\");\n        liquidationDiscount[asset] = newValue;\n    }\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets the devaluation period of collateral after liquidation\n     * @param asset The address of the main collateral token\n     * @param newValue The devaluation period in blocks\n     **/\n    function setDevaluationPeriod(address asset, uint newValue) public onlyManager {\n        require(newValue != 0, \"Unit Protocol: INCORRECT_DEVALUATION_VALUE\");\n        devaluationPeriod[asset] = newValue;\n    }\n\n    /**\n     * @notice Only manager is able to call this function\n     * @dev Sets the percentage range of the COL token part for specific collateral token\n     * @param asset The address of the main collateral token\n     * @param min The min percentage (0 decimals)\n     * @param max The max percentage (0 decimals)\n     **/\n    function setColPartRange(address asset, uint min, uint max) public onlyManager {\n        require(max <= 100 && min <= max, \"Unit Protocol: WRONG_RANGE\");\n        minColPercent[asset] = min;\n        maxColPercent[asset] = max;\n    }\n}"
    },
    "contracts/SuCollateralRegistry.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nimport \"./SuVaultParameters.sol\";\r\n\r\n// contract for mapping of collaterals\r\ncontract SuCollateralRegistry is Auth {\r\n\r\n    event CollateralAdded(address indexed asset);\r\n    event CollateralRemoved(address indexed asset);\r\n\r\n    // mapping of collateral to its index in collateralList\r\n    // it allowed to find collateral by address in the list without loop\r\n    mapping(address => uint) public collateralId;\r\n\r\n    address[] public collateralList;\r\n    \r\n    // collateral registry is deployed after vaultParameters contract and it initializes list of collaterals\r\n    constructor(address _vaultParameters, address[] memory assets) Auth(_vaultParameters) {\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            require(!isCollateral(assets[i]), \"Unit Protocol: ALREADY_EXIST\");\r\n            collateralList.push(assets[i]);\r\n            collateralId[assets[i]] = i;\r\n            emit CollateralAdded(assets[i]);\r\n        }\r\n    }\r\n\r\n    // after deployment more collaterals can be added by managers\r\n    function addCollateral(address asset) public onlyManager {\r\n        require(asset != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        require(!isCollateral(asset), \"Unit Protocol: ALREADY_EXIST\");\r\n\r\n        collateralId[asset] = collateralList.length;\r\n        collateralList.push(asset);\r\n\r\n        emit CollateralAdded(asset);\r\n    }\r\n\r\n    // as well collaterals can be removed\r\n    function removeCollateral(address asset) public onlyManager {\r\n        require(asset != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        require(isCollateral(asset), \"Unit Protocol: DOES_NOT_EXIST\");\r\n\r\n        uint id = collateralId[asset];\r\n\r\n        delete collateralId[asset];\r\n\r\n        uint lastId = collateralList.length - 1;\r\n\r\n        if (id != lastId) {\r\n            address lastCollateral = collateralList[lastId];\r\n            collateralList[id] = lastCollateral;\r\n            collateralId[lastCollateral] = id;\r\n        }\r\n\r\n        collateralList.pop();\r\n\r\n        emit CollateralRemoved(asset);\r\n    }\r\n\r\n    // check whether asset is collateral\r\n    function isCollateral(address asset) public view returns(bool) {\r\n        if (collateralList.length == 0) { return false; }\r\n        return collateralId[asset] != 0 || collateralList[0] == asset;\r\n    }\r\n\r\n    // return all collateral assets\r\n    function collaterals() external view returns (address[] memory) {\r\n        return collateralList;\r\n    }\r\n\r\n    // return total number of collateral assets\r\n    function collateralsCount() external view returns (uint) {\r\n        return collateralList.length;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}