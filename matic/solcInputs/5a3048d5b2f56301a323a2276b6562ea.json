{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/exchange/interfaces/IExchange.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\npragma solidity ^0.8.0;\n\nenum DiscountType {\n    aggressive,\n    middle,\n    conservative\n}\n\nstruct Order {\n    address token2sell;\n    uint256 amountLeft;\n    address token2buy;\n    uint256 token2buyAmount;\n    address beneficiary;\n    uint256 creationTimestamp;\n    DiscountType discountType;\n    address caller;\n}\n\nstruct OrderWithId {\n    Order order;\n    uint256 orderId;\n}\n\ninterface IExchange {\n    /* ===================== ERRORS ===================== */\n    error OrderExist(uint256 orderId);\n    error OrderNotExist(uint256 orderId);\n    error IncorrectToken(address orderToken2buy, address inToken);\n    error SmallAmountLeft();\n    error UserIsNotBeneficiary();\n    error IsNotTopStaker(address staker);\n    error OrderNotForThisStaker(uint256 orderId, address staker);\n    error NotEnoughReturnValue();\n    error CallbackError();\n\n    /* ======================== EVENTS ========================= */\n    event OrderAdded(uint256 orderId);\n    event OrderCanceled(uint256 orderId);\n    event OrderFilled(uint256 orderId);\n    event OrderFilledPartially(uint256 orderId);\n    event LpOrdersAdded(address LPToken, uint256[] orderIds);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    /**\n      * @notice Add order to swap {token2sell} to {token2buy}.\n      * @dev This swap is async, because depends on how arbitrage bots will fill this order. Emits OrderAdded() event.\n      * Before addOrder user needs to approve token2sell for exchange contract\n      * @param token2sell - Address of token to sell\n      * @param amount2sell - Amount of {token2sell} to sell\n      * @param token2buy - Address of token to buy\n      * @param beneficiary - Address that will receive {token2buy} after filling order.\n      * @param discountType - Speed of decreasing swap price. { 0 - aggressive, 1 - middle, 2 - conservative }\n      * @param collateralJoin - address of collateral adapter\n     **/\n    function addOrder (\n        address token2sell,\n        uint256 amount2sell,\n        address token2buy,\n        address beneficiary,\n        DiscountType discountType,\n        address collateralJoin\n    ) external returns (uint256);\n\n    /**\n      * @notice Only user who place order or who is beneficiary can cancelOrder();\n      * @param orderId - Id of order to cancel.\n     **/\n    function cancelOrder (uint256 orderId) external;\n\n    /**\n      * @notice Fill order with flash-loan like logic\n      * @dev Caller contract receive orders {token2sell} and after that his stableunitFillOrderCallback() is called.\n      * At the end of thi callback contract should send some amount of another token back to Exchange contract.\n      * @param orderId - Id of order to fill.\n      * @param inAmount - Amount of {token2sell} to receive\n      * @param data - encoded data to pass to callback function\n     **/\n    function fillOrderAsFlashLoan (\n        uint256 orderId,\n        uint256 inAmount,\n        bytes memory data\n    ) external returns (uint256 outAmount);\n\n    /**\n      * @notice Function to update price curve - how fast {token2sell} price will decrease/increase\n      * @param discountType - discount type to change\n      * @param newPriceCurve - parameters of formula\n     **/\n    function setPriceCurve(DiscountType discountType, uint256[2] calldata newPriceCurve) external;\n\n    /* ==================== VIEW METHODS ==================== */\n    /**\n      * @return The amount of outcome that caller will receive if he will fill {orderId} with {inAmount} of {token2sell}\n     **/\n    function getExpectedOrderOutcome (uint256 orderId, uint256 inAmount) external view returns (uint256);\n\n    /**\n      * @return Order with id = {orderId}\n     **/\n    function getOrder (uint256 orderId) external view returns (Order memory);\n\n    /**\n      * @return The amount of not full-filled orders\n     **/\n    function getOrdersCount () external view returns (uint256);\n\n    /**\n      * @return The array of all not-filled orders. May be deleted after adding GraphQL for orderIds\n     **/\n    function getAllOrders () external view returns (OrderWithId[] memory);\n}\n"
    },
    "contracts/makerdao/core/adapters/CoinJoin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/ICollateralJoin.sol\";\nimport \"../../interfaces/ISafeEngine.sol\";\nimport \"../../interfaces/ICoin.sol\";\nimport \"../../interfaces/ICoinJoin.sol\";\n\ncontract CoinJoin is ICoinJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 1;\n        emit AddAuthorization(usr);\n    }\n    function removeAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 0;\n        emit RemoveAuthorization(usr);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CoinJoin/not-authorized\");\n        _;\n    }\n\n    ISafeEngine public safeEngine;\n    // Coin created by the system; this is the external, ERC-20 representation, not the internal 'coinBalance'\n    ICoin public systemCoin;\n    // Whether this contract is enabled or not\n    uint public contractEnabled;\n\n    constructor(address safeEngine_, address systemCoin_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n        systemCoin = ICoin(systemCoin_);\n    }\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n    uint constant ONE = 10 ** 27;\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function join(address usr, uint wad) external {\n        safeEngine.transferInternalCoins(address(this), usr, mul(ONE, wad));\n        systemCoin.burn(msg.sender, wad);\n        emit Join(usr, wad);\n    }\n\n    function exit(address usr, uint wad) external {\n        require(contractEnabled == 1, \"CoinJoin/not-contractEnabled\");\n        safeEngine.transferInternalCoins(msg.sender, address(this), mul(ONE, wad));\n        systemCoin.mint(usr, wad);\n        emit Exit(usr, wad);\n    }\n}\n\n"
    },
    "contracts/makerdao/core/adapters/CollateralJoin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/ICollateralJoin.sol\";\nimport \"../../interfaces/ISafeEngine.sol\";\n\n/// @dev This adapter assumes that the collateral has 18 decimals\ncontract CollateralJoin is ICollateralJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 1;\n        emit AddAuthorization(usr);\n    }\n    function removeAuthorization(address usr) external isAuthorized {\n        authorizedAccounts[usr] = 0;\n        emit RemoveAuthorization(usr);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin/not-authorized\");\n        _;\n    }\n\n    ISafeEngine public safeEngine;\n    bytes32 public collateralType;\n    IERC20Metadata public collateral;      // Actual collateral token contract\n    uint    public decimals;        // How many decimals the collateral token has\n    uint    public contractEnabled; // Whether this adapter contract is enabled or not\n\n    // Events\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n        collateralType = collateralType_;\n        collateral = IERC20Metadata(collateral_);\n        decimals = collateral.decimals();\n        emit AddAuthorization(msg.sender);\n    }\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    function join(address usr, uint wad) external {\n        require(contractEnabled == 1, \"CollateralJoin/not-contractEnabled\");\n        require(int(wad) >= 0, \"CollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"CollateralJoin/failed-transfer\");\n        emit Join(usr, wad);\n    }\n\n    function exit(address usr, uint wad) external {\n        require(wad <= 2 ** 255, \"CollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        require(collateral.transfer(usr, wad), \"CollateralJoin/failed-transfer\");\n        emit Exit(usr, wad);\n    }\n}\n"
    },
    "contracts/makerdao/core/DssCdpManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// DssCdpManager.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/IDssCdpManager.sol\";\n\ncontract CdpHandler {\n    constructor(ISafeEngine safeEngine) public {\n        safeEngine.approveSAFEModification(msg.sender);\n    }\n}\n\ncontract DssCdpManager is IDssCdpManager {\n    ISafeEngine               public safeEngine;\n    uint                      public cdpi;      // Auto incremental\n    mapping (uint => address) public safes;      // CDPId => CdpHandler\n    mapping (uint => List)    public list;      // CDPId => Prev & Next CDPIds (double linked list)\n    mapping (uint => address) public owns;      // CDPId => Owner\n    mapping (uint => bytes32) public collateralTypes;      // CDPId => CollateralType\n\n    mapping (address => uint) public firstCdpId;     // Owner => First CDPId\n    mapping (address => uint) public lastCdpId;      // Owner => Last CDPId\n    mapping (address => uint) public cdpCount;     // Owner => Amount of CDPs\n\n    mapping (\n        address => mapping (\n            uint => mapping (\n                address => uint\n            )\n        )\n    ) public cdpCan;                            // Owner => CDPId => Allowed Addr => True/False\n\n    mapping (\n        address => mapping (\n            address => uint\n        )\n    ) public handlerCan;                            // Cdp => Allowed Addr => True/False\n    \n    modifier cdpAllowed(uint cdp) {\n        require(msg.sender == owns[cdp] || cdpCan[owns[cdp]][cdp][msg.sender] == 1, \"cdp-not-allowed\");\n        _;\n    }\n\n    modifier handlerAlloweded(address urn) {\n        require(msg.sender == urn || handlerCan[urn][msg.sender] == 1, \"urn-not-allowed\");\n        _;\n    }\n\n    constructor(address safeEngine_) public {\n        safeEngine = ISafeEngine(safeEngine_);\n    }\n\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function _sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function toInt(uint x) internal pure returns (int y) {\n        y = int(x);\n        require(y >= 0);\n    }\n\n    function cdpAllow(uint cdp, address usr, uint ok) public cdpAllowed(cdp) {\n        cdpCan[owns[cdp]][cdp][usr] = ok;\n    }\n\n    function allowHandler(address usr, uint ok) public {\n        handlerCan[msg.sender][usr] = ok;\n    }\n\n    function openSafe(bytes32 collateralType, address usr) public returns (uint) {\n        require(usr != address(0), \"usr-address-0\");\n\n        cdpi = _add(cdpi, 1);\n        safes[cdpi] = address(new CdpHandler(safeEngine));\n        owns[cdpi] = usr;\n        collateralTypes[cdpi] = collateralType;\n\n        // Add new CDP to double linked list and pointers\n        if (firstCdpId[usr] == 0) {\n            firstCdpId[usr] = cdpi;\n        }\n        if (lastCdpId[usr] != 0) {\n            list[cdpi].prev = lastCdpId[usr];\n            list[lastCdpId[usr]].next = cdpi;\n        }\n        lastCdpId[usr] = cdpi;\n        cdpCount[usr] = _add(cdpCount[usr], 1);\n\n        emit NewCdp(msg.sender, usr, cdpi);\n        return cdpi;\n    }\n\n    function transferSafeOwnership(uint cdp, address dst) public cdpAllowed(cdp) {\n        require(dst != address(0), \"dst-address-0\");\n        require(dst != owns[cdp], \"dst-already-owner\");\n\n        // Remove transferred CDP from double linked list of origin user and pointers\n        if (list[cdp].prev != 0) {\n            list[list[cdp].prev].next = list[cdp].next;         // Set the next pointer of the prev cdp (if exists) to the next of the transferred one\n        }\n        if (list[cdp].next != 0) {                              // If wasn't the last one\n            list[list[cdp].next].prev = list[cdp].prev;         // Set the prev pointer of the next cdp to the prev of the transferred one\n        } else {                                                // If was the last one\n            lastCdpId[owns[cdp]] = list[cdp].prev;                   // Update last pointer of the owner\n        }\n        if (firstCdpId[owns[cdp]] == cdp) {                          // If was the first one\n            firstCdpId[owns[cdp]] = list[cdp].next;                  // Update first pointer of the owner\n        }\n        cdpCount[owns[cdp]] = _sub(cdpCount[owns[cdp]], 1);\n\n        // Transfer ownership\n        owns[cdp] = dst;\n\n        // Add transferred CDP to double linked list of destiny user and pointers\n        list[cdp].prev = lastCdpId[dst];\n        list[cdp].next = 0;\n        if (lastCdpId[dst] != 0) {\n            list[lastCdpId[dst]].next = cdp;\n        }\n        if (firstCdpId[dst] == 0) {\n            firstCdpId[dst] = cdp;\n        }\n        lastCdpId[dst] = cdp;\n        cdpCount[dst] = _add(cdpCount[dst], 1);\n    }\n\n    function modifySAFECollateralization(\n        uint cdp,\n        int deltaCollateral,\n        int deltaDebt\n    ) public cdpAllowed(cdp) {\n        address urn = safes[cdp];\n        safeEngine.modifySAFECollateralization(\n            collateralTypes[cdp],\n            urn,\n            urn,\n            urn,\n            deltaCollateral,\n            deltaDebt\n        );\n    }\n\n    function transferCollateral(\n        uint cdp,\n        address dst,\n        uint wad\n    ) public cdpAllowed(cdp) {\n        safeEngine.transferCollateral(collateralTypes[cdp], safes[cdp], dst, wad);\n    }\n\n    function transferCollateral(\n        bytes32 ilk,\n        uint cdp,\n        address dst,\n        uint wad\n    ) public cdpAllowed(cdp) {\n        safeEngine.transferCollateral(ilk, safes[cdp], dst, wad);\n    }\n\n    function transferInternalCoins(uint cdp, address dst, uint rad) public cdpAllowed(cdp) {\n        safeEngine.transferInternalCoins(safes[cdp], dst, rad);\n    }\n\n    function quit(uint cdp, address dst) public cdpAllowed(cdp) handlerAlloweded(dst) {\n        (uint lockedCollateral, uint generatedDebt) = safeEngine.safes(collateralTypes[cdp], safes[cdp]);\n        safeEngine.transferSAFECollateralAndDebt(\n            collateralTypes[cdp],\n            safes[cdp],\n            dst,\n            toInt(lockedCollateral),\n            toInt(generatedDebt)\n        );\n    }\n\n    function enter(address src, uint cdp) public handlerAlloweded(src) cdpAllowed(cdp) {\n        (uint lockedCollateral, uint generatedDebt) = safeEngine.safes(collateralTypes[cdp], src);\n        safeEngine.transferSAFECollateralAndDebt(\n            collateralTypes[cdp],\n            src,\n            safes[cdp],\n            toInt(lockedCollateral),\n            toInt(generatedDebt)\n        );\n    }\n\n    function moveSAFE(uint cdpSrc, uint cdpDst) public cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\n        require(collateralTypes[cdpSrc] == collateralTypes[cdpDst], \"non-matching-cdps\");\n        (uint lockedCollateral, uint generatedDebt) = safeEngine.safes(collateralTypes[cdpSrc], safes[cdpSrc]);\n        safeEngine.transferSAFECollateralAndDebt(\n            collateralTypes[cdpSrc],\n            safes[cdpSrc],\n            safes[cdpDst],\n            toInt(lockedCollateral),\n            toInt(generatedDebt)\n        );\n    }\n}\n"
    },
    "contracts/makerdao/core/OracleRelayer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// OracleRelayer.sol -- OracleRelayer\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../utils/AuthWithoutContractEnabled.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract OracleRelayer is AuthWithoutContractEnabled {\n    // --- Data ---\n    struct CollateralType {\n        IPriceFeed priceFeed;\n        uint256 liquidationRatio; // [ray]\n    }\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    ISafeEngine public safeEngine;\n    uint256 public redemptionPrice;  // ref per dai [ray]\n\n    // --- Events ---\n    event Poke(\n      bytes32 collateralType,\n      bytes32 val,  // [wad]\n      uint256 safetyPrice  // [ray]\n    );\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n        redemptionPrice = ONE;\n        contractEnabled = 1;\n    }\n\n    // --- Math ---\n    uint constant ONE = 10 ** 27;\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = mul(x, ONE) / y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 collateralType, bytes32 what, address priceFeed_) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/not-contractEnabled\");\n        if (what == \"priceFeed\") collateralTypes[collateralType].priceFeed = IPriceFeed(priceFeed_);\n        else revert(\"OracleRelayer/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 what, uint data) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/not-contractEnabled\");\n        if (what == \"redemptionPrice\") redemptionPrice = data;\n        else revert(\"OracleRelayer/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/not-contractEnabled\");\n        if (what == \"liquidationRatio\") collateralTypes[collateralType].liquidationRatio = data;\n        else revert(\"OracleRelayer/modifyParameters-unrecognized-param\");\n    }\n\n    // --- Update value ---\n    function updateSafetyPrice(bytes32 collateralType) external {\n        (bytes32 val, bool has) = collateralTypes[collateralType].priceFeed.peek();\n        uint256 safetyPrice = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), redemptionPrice), collateralTypes[collateralType].liquidationRatio) : 0;\n        safeEngine.modifyParameters(collateralType, \"safetyPrice\", safetyPrice);\n        emit Poke(collateralType, val, safetyPrice);\n    }\n}\n"
    },
    "contracts/makerdao/core/SafeEngine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// SAFEEngine.sol -- Dai CDP database\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport {AuthWithContractEnabled} from \"../utils/AuthWithContractEnabled.sol\";\nimport {Math} from \"../utils/Math.sol\";\nimport {ISafeEngine} from \"../interfaces/ISafeEngine.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract SafeEngine is AuthWithContractEnabled, Math, ISafeEngine {\n    // --- Auth ---\n    // Who can transfer collateral & debt in/out of a CDP\n    mapping(address => mapping (address => uint)) public cdpRights;\n\n    function approveSAFEModification(address usr) external { cdpRights[msg.sender][usr] = 1; }\n\n    function denySAFEModification(address usr) external { cdpRights[msg.sender][usr] = 0; }\n\n    function canModifySAFE(address cdp, address account) internal view returns (bool) {\n        return either(cdp == account, cdpRights[cdp][account] == 1);\n    }\n\n    /// Total User Debt (drawn dai + stability fee accrued) = SAFE.generatedDebt * CollateralType.accumulatedRate;\n\n    // Data about each collateral type\n    mapping (bytes32 => CollateralType)            public collateralTypes;\n    // Data about each SAFE\n    mapping (bytes32 => mapping (address => SAFE)) public safes;\n    // Balance of each collateral type\n    mapping (bytes32 => mapping (address => uint)) public tokenCollateral; // [wad]\n    // Internal balance of pegged-coins\n    mapping (address => uint256)                   public coinBalance;     // [rad]\n    // Amount of debt held by an account. Coin & debt are like matter and antimatter. They nullify each other\n    mapping (address => uint256)                   public debtBalance;     // [rad]\n\n    uint256 public globalDebt;          // Total amount of debt (coins) currently issued [rad]\n    uint256 public globalUnbackedDebt;  // 'Bad' debt that's not covered by collateral   [rad]\n    uint256 public globalDebtCeiling;   // Maximum amount of debt that can be issued     [rad]\n\n    // --- Init ---\n    constructor() public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n    }\n\n    // --- Administration ---\n    function initializeCollateralType(bytes32 collateralType) external isAuthorized {\n        require(collateralTypes[collateralType].accumulatedRate == 0, \"SafeEngine/collateral-type-already-init\");\n        collateralTypes[collateralType].accumulatedRate = 10 ** 27;\n    }\n    function modifyParameters(bytes32 what, uint data) external isAuthorized {\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n        if (what == \"globalDebtCeiling\") globalDebtCeiling = data;\n        else revert(\"SafeEngine/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external isAuthorized {\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n        if (what == \"safetyPrice\") collateralTypes[collateralType].safetyPrice = data;\n        else if (what == \"debtCeiling\") collateralTypes[collateralType].debtCeiling = data;\n        else if (what == \"debtFloor\") collateralTypes[collateralType].debtFloor = data;\n        else revert(\"SafeEngine/modifyParameters-unrecognized-param\");\n    }\n\n    // --- Fungibility ---\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external isAuthorized {\n        tokenCollateral[collateralType][usr] = _add(tokenCollateral[collateralType][usr], wad);\n    }\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external {\n        require(canModifySAFE(src, msg.sender), \"SafeEngine/not-allowed\");\n        tokenCollateral[collateralType][src] = _sub(tokenCollateral[collateralType][src], wad);\n        tokenCollateral[collateralType][dst] = _add(tokenCollateral[collateralType][dst], wad);\n    }\n    function transferInternalCoins(address src, address dst, uint256 rad) external {\n        require(canModifySAFE(src, msg.sender), \"SafeEngine/not-allowed\");\n        coinBalance[src] = _sub(coinBalance[src], rad);\n        coinBalance[dst] = _add(coinBalance[dst], rad);\n    }\n\n    // --- CDP Manipulation ---\n    function modifySAFECollateralization(bytes32 collateralType, address cdp, address collateralSource, address debtDestination, int deltaCollateral, int deltaDebt) external {\n        // system is contractEnabled\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n\n        SAFE memory safe_ = safes[collateralType][cdp];\n        CollateralType memory collateralType_ = collateralTypes[collateralType];\n        // collateralType has been initialised\n        require(collateralType_.accumulatedRate != 0, \"SafeEngine/collateral-type-not-init\");\n\n        safe_.lockedCollateral = _add(safe_.lockedCollateral, deltaCollateral);\n        safe_.generatedDebt = _add(safe_.generatedDebt, deltaDebt);\n        collateralType_.debtAmount = _add(collateralType_.debtAmount, deltaDebt);\n\n        int dAmountToRaise = _mul(collateralType_.accumulatedRate, deltaDebt);\n        uint amountToRaise = _mul(collateralType_.accumulatedRate, safe_.generatedDebt);\n        globalDebt = _add(globalDebt, dAmountToRaise);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        require(either(deltaDebt <= 0, both(_mul(collateralType_.debtAmount, collateralType_.accumulatedRate) <= collateralType_.debtCeiling, globalDebt <= globalDebtCeiling)), \"SafeEngine/ceiling-exceeded\");\n        // safe is either less risky than before, or it is safe\n        require(either(both(deltaDebt <= 0, deltaCollateral >= 0), amountToRaise <= _mul(safe_.lockedCollateral, collateralType_.safetyPrice)), \"SafeEngine/not-safe\");\n\n        // safe is either more safe, or the owner consents\n        require(either(both(deltaDebt <= 0, deltaCollateral >= 0), canModifySAFE(cdp, msg.sender)), \"SafeEngine/not-allowed-u\");\n        // collateral src consents\n        require(either(deltaCollateral <= 0, canModifySAFE(collateralSource, msg.sender)), \"SafeEngine/not-allowed-v\");\n        // debt dst consents\n        require(either(deltaDebt >= 0, canModifySAFE(debtDestination, msg.sender)), \"SafeEngine/not-allowed-w\");\n\n        // safe has no debt, or a non-dusty amount\n        require(either(safe_.generatedDebt == 0, amountToRaise >= collateralType_.debtFloor), \"SafeEngine/debtFloor\");\n\n        tokenCollateral[collateralType][collateralSource] = _sub(tokenCollateral[collateralType][collateralSource], deltaCollateral);\n        coinBalance[debtDestination]    = _add(coinBalance[debtDestination],    dAmountToRaise);\n\n        safes[collateralType][cdp]      = safe_;\n        collateralTypes[collateralType] = collateralType_;\n    }\n    // --- CDP Fungibility ---\n    function transferSAFECollateralAndDebt(bytes32 collateralType, address src, address dst, int deltaCollateral, int deltaDebt) external {\n        SAFE storage srcCDP = safes[collateralType][src];\n        SAFE storage dstCDP = safes[collateralType][dst];\n        CollateralType storage col = collateralTypes[collateralType];\n\n        srcCDP.lockedCollateral = _sub(srcCDP.lockedCollateral, deltaCollateral);\n        srcCDP.generatedDebt = _sub(srcCDP.generatedDebt, deltaDebt);\n        dstCDP.lockedCollateral = _add(dstCDP.lockedCollateral, deltaCollateral);\n        dstCDP.generatedDebt = _add(dstCDP.generatedDebt, deltaDebt);\n\n        uint srcAmountToRaise = _mul(srcCDP.generatedDebt, col.accumulatedRate);\n        uint dstAmountToRaise = _mul(dstCDP.generatedDebt, col.accumulatedRate);\n\n        // both sides consent\n        require(both(canModifySAFE(src, msg.sender), canModifySAFE(dst, msg.sender)), \"SafeEngine/not-allowed\");\n\n        // both sides safe\n        require(srcAmountToRaise <= _mul(srcCDP.lockedCollateral, col.safetyPrice), \"SafeEngine/not-safe-src\");\n        require(dstAmountToRaise <= _mul(dstCDP.lockedCollateral, col.safetyPrice), \"SafeEngine/not-safe-dst\");\n\n        // both sides non-dusty\n        require(either(srcAmountToRaise >= col.debtFloor, srcCDP.generatedDebt == 0), \"SafeEngine/debtFloor-src\");\n        require(either(dstAmountToRaise >= col.debtFloor, dstCDP.generatedDebt == 0), \"SafeEngine/debtFloor-dst\");\n    }\n    // --- CDP Confiscation ---\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address cdp, address collateralCounterparty, address debtCounterparty, int deltaCollateral, int deltaDebt) external isAuthorized {\n        SAFE storage safe_ = safes[collateralType][cdp];\n        CollateralType storage collateralType_ = collateralTypes[collateralType];\n\n        safe_.lockedCollateral = _add(safe_.lockedCollateral, deltaCollateral);\n        safe_.generatedDebt = _add(safe_.generatedDebt, deltaDebt);\n        collateralType_.debtAmount = _add(collateralType_.debtAmount, deltaDebt);\n\n        int deltaTotalIssuedDebt = _mul(collateralType_.accumulatedRate, deltaDebt);\n\n        tokenCollateral[collateralType][collateralCounterparty] = _sub(tokenCollateral[collateralType][collateralCounterparty], deltaCollateral);\n        debtBalance[debtCounterparty]    = _sub(debtBalance[debtCounterparty], deltaTotalIssuedDebt);\n        globalUnbackedDebt      = _sub(globalUnbackedDebt, deltaTotalIssuedDebt);\n    }\n\n    // --- Settlement ---\n\n    function settleDebt(uint rad) external {\n        address account      = msg.sender;\n        debtBalance[account] = _sub(debtBalance[account], rad);\n        coinBalance[account] = _sub(coinBalance[account], rad);\n        globalUnbackedDebt   = _sub(globalUnbackedDebt,   rad);\n        globalDebt           = _sub(globalDebt,   rad);\n    }\n\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external isAuthorized {\n        debtBalance[debtDestination] = _add(debtBalance[debtDestination], rad);\n        coinBalance[coinDestination] = _add(coinBalance[coinDestination], rad);\n        globalUnbackedDebt           = _add(globalUnbackedDebt,   rad);\n        globalDebt                   = _add(globalDebt,   rad);\n    }\n\n    // --- Rates ---\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external isAuthorized {\n        require(contractEnabled == 1, \"SafeEngine/not-contractEnabled\");\n        CollateralType storage collateralType_ = collateralTypes[collateralType];\n        collateralType_.accumulatedRate        = _add(collateralType_.accumulatedRate, accumulatedRate);\n        int deltaSurplus                       = _mul(collateralType_.debtAmount, accumulatedRate);\n        coinBalance[surplusDst]                = _add(coinBalance[surplusDst], deltaSurplus);\n        globalDebt                             = _add(globalDebt, deltaSurplus);\n    }\n}\n"
    },
    "contracts/makerdao/core/TaxCollector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// TaxCollector.sol -- Dai Lending Rate\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/ITaxCollector.sol\";\nimport {AuthWithoutContractEnabled} from \"../utils/AuthWithoutContractEnabled.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract TaxCollector is ITaxCollector, AuthWithoutContractEnabled {\n    mapping (bytes32 => CollateralType) public collateralTypes;\n    ISafeEngine public safeEngine;   // CDP Engine\n    address public primaryTaxReceiver;   // Debt Engine\n    uint256 public base;  // Global, per-second stability fee contribution [ray]\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n    }\n\n    // --- Math ---\n    function _rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n      assembly {\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n        default {\n          switch mod(n, 2) case 0 { z := b } default { z := x }\n          let half := div(b, 2)  // for rounding.\n          for { n := div(n, 2) } n { n := div(n,2) } {\n            let xx := mul(x, x)\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n            let xxRound := add(xx, half)\n            if lt(xxRound, xx) { revert(0,0) }\n            x := div(xxRound, b)\n            if mod(n,2) {\n              let zx := mul(z, x)\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n              let zxRound := add(zx, half)\n              if lt(zxRound, zx) { revert(0,0) }\n              z := div(zxRound, b)\n            }\n          }\n        }\n      }\n    }\n    uint256 constant ONE = 10 ** 27;\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function _diff(uint x, uint y) internal pure returns (int z) {\n        z = int(x) - int(y);\n        require(int(x) >= 0 && int(y) >= 0);\n    }\n    function _rmul(uint x, uint y) internal pure returns (uint z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / ONE;\n    }\n\n    // --- Administration ---\n    function initializeCollateralType(bytes32 collateralType) external isAuthorized {\n        CollateralType storage i = collateralTypes[collateralType];\n        require(i.stabilityFee == 0, \"TaxCollector/collateralType-already-init\");\n        i.stabilityFee = ONE;\n        i.latestUpdateTime  = block.timestamp;\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external isAuthorized {\n        require(block.timestamp == collateralTypes[collateralType].latestUpdateTime, \"TaxCollector/latestUpdateTime-not-updated\");\n        if (what == \"stabilityFee\") collateralTypes[collateralType].stabilityFee = data;\n        else revert(\"TaxCollector/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 what, uint data) external isAuthorized {\n        if (what == \"base\") base = data;\n        else revert(\"TaxCollector/modifyParameters-unrecognized-param\");\n    }\n    function modifyParameters(bytes32 what, address data) external isAuthorized {\n        if (what == \"primaryTaxReceiver\") primaryTaxReceiver = data;\n        else revert(\"TaxCollector/modifyParameters-unrecognized-param\");\n    }\n\n    function taxSingle(bytes32 collateralType) external returns (uint rate) {\n        require(block.timestamp >= collateralTypes[collateralType].latestUpdateTime, \"TaxCollector/invalid-block-timestamp\");\n        (, uint prevRate,,,) = safeEngine.collateralTypes(collateralType);\n        /// rate = oldRate * (1 + StabilityRate)^(time since last taxSingle)\n        rate = _rmul(\n            _rpow(\n                _add(base, collateralTypes[collateralType].stabilityFee),\n                block.timestamp - collateralTypes[collateralType].latestUpdateTime,\n                ONE\n            ),\n            prevRate\n        );\n        safeEngine.updateAccumulatedRate(collateralType, primaryTaxReceiver, _diff(rate, prevRate));\n        collateralTypes[collateralType].latestUpdateTime = block.timestamp;\n    }\n}\n"
    },
    "contracts/makerdao/externalContracts/AccountingEngine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// AccountingEngine.sol -- Dai settlement module\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {Math} from \"../utils/Math.sol\";\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/ILiquidationEngine.sol\";\nimport {AuthWithContractEnabled} from \"../utils/AuthWithContractEnabled.sol\";\nimport \"../interfaces/IAccountingEngine.sol\";\nimport \"../../periphery/contracts/interfaces/oracle/ISuOracle.sol\";\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract AccountingEngine is Math, IAccountingEngine {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized { require(contractEnabled == 1, \"AccountingEngine/not-contractEnabled\"); authorizedAccounts[usr] = 1; }\n    function removeAuthorization(address usr) external isAuthorized { authorizedAccounts[usr] = 0; }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"AccountingEngine/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    ISafeEngine public safeEngine;\n    ILiquidationEngine public liquidationEngine;\n    ISuOracle public oracle;\n    address public stablePro;\n\n    mapping (uint256 => uint256) public debtQueue;  // debt queue\n    uint256 public totalQueuedDebt;   // Queued debt [rad]\n    uint256 public contractEnabled;\n\n    // --- Init ---\n    constructor(address safeEngine_, address liquidationEngine_, address oracle_, address stablePro_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n        liquidationEngine = ILiquidationEngine(liquidationEngine_);\n        oracle = ISuOracle(oracle_);\n        stablePro = stablePro_;\n        contractEnabled = 1;\n    }\n\n    /**\n    * @notice Push debt (that the system tries to cover with collateral auctions) to a queue\n     * @dev Debt is locked in a queue to give the system enough time to auction collateral\n     *      and gather surplus\n     * @param amountToRaise Amount of debt to push\n     */\n    function pushDebtToQueue(uint amountToRaise) external isAuthorized {\n        debtQueue[block.timestamp] = _add(debtQueue[block.timestamp], amountToRaise);\n        totalQueuedDebt = _add(totalQueuedDebt, amountToRaise);\n    }\n    /**\n     * @notice A block of debt can be popped from the queue after popDebtDelay seconds passed since it was\n     *         added there\n     * @param era Timestamp of the block of debt that should be popped out\n     */\n    function popDebtFromQueue(uint era) external {\n        // require(_add(era, popDebtDelay) <= block.timestamp, \"AccountingEngine/popDebtDelay-not-finished\");\n        totalQueuedDebt = _sub(totalQueuedDebt, debtQueue[era]);\n        debtQueue[era] = 0;\n    }\n\n    // Debt settlement\n//    /**\n//     * @notice Destroy an equal amount of coins and debt\n//     * @dev We can only destroy debt that is not locked in the queue and also not in a debt auction\n//     * @param rad Amount of coins/debt to destroy (number with 45 decimals)\n//    **/\n//    function settleDebt(uint rad) external {\n//        require(rad <= safeEngine.coinBalance(address(this)), \"AccountingEngine/insufficient-surplus\");\n//        require(rad <= _sub(_sub(safeEngine.debtBalance(address(this)), totalQueuedDebt), totalOnAuctionDebt), \"AccountingEngine/insufficient-debt\");\n//        safeEngine.settleDebt(rad);\n//    }\n\n    /**\n     * @notice Disable this contract (normally called by Global Settlement)\n     * @dev When we disable, the contract tries to settle as much debt as possible (if there's any) with\n            any surplus that's left in the system. After erasing debt, the contract will either transfer any\n            remaining surplus right away (if disableCooldown == 0) or will only record the timestamp when\n            it was disabled\n    **/\n    function disableContract() external isAuthorized {\n        require(contractEnabled == 1, \"AccountingEngine/not-contractEnabled\");\n        contractEnabled = 0;\n        totalQueuedDebt = 0;\n        safeEngine.settleDebt(min(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this))));\n        emit DisableContract();\n    }\n\n    // user need to approve StablePro\n    function swapStableProToStablecoin(\n        address stablecoinToken,\n        uint256 stableProAmountE18\n    ) external {\n        if (!liquidationEngine.hasWhitelistStablecoin(stablecoinToken)) revert BadStablecoin(stablecoinToken);\n\n        uint256 stablecoinAmountEDecimal = stableProAmountE18 * 1e18 / oracle.getFiatPrice1e18(stablecoinToken);\n\n        TransferHelper.safeTransferFrom(stablePro, msg.sender, address(this), stableProAmountE18);\n        TransferHelper.safeTransfer(stablecoinToken, msg.sender, stablecoinAmountEDecimal);\n\n        // middlewareDebt -= int256(stableProAmountE18);\n        // TODO: should we settleDebt and do some manipulations in safeEngine?\n\n        emit StableProSwapped(stableProAmountE18);\n    }\n}\n"
    },
    "contracts/makerdao/externalContracts/LiquidationEngine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// dog.sol -- Dai liquidation module 2.0\n\n// Copyright (C) 2020-2022 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport {AuthWithoutContractEnabled} from \"../utils/AuthWithoutContractEnabled.sol\";\nimport \"../interfaces/ILiquidationEngine.sol\";\nimport \"../interfaces/ISafeEngine.sol\";\nimport \"../interfaces/ICollateralJoin.sol\";\nimport \"../../exchange/interfaces/IExchange.sol\";\n\nimport {Math} from \"../utils/Math.sol\";\n\ninterface AccountingEngineLike {\n    function pushDebtToQueue(uint256) external;\n}\n\ncontract LiquidationEngine is AuthWithoutContractEnabled, ILiquidationEngine, Math {\n    ISafeEngine immutable public safeEngine;  // CDP Engine\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    AccountingEngineLike public accountingEngine;   // Debt Engine\n    uint256 public GlobalLiquidationLimit;  // Max DAI needed to cover debt+fees of active auctions [rad]\n    uint256 public ActiveLiquidationAmount;  // Amt DAI needed to cover debt+fees of active auctions [rad]\n    uint256 public LiquidatorReward;  // Reward in percent (1e18 == 1) for liquidation [wad]\n    address public liquidator;  // Liquidator, Exchange module\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        safeEngine = ISafeEngine(safeEngine_);\n        contractEnabled = 1;\n        authorizedAccounts[msg.sender] = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 what, address data) external isAuthorized {\n        if (what == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else if (what == \"liquidator\") liquidator = data;\n        else revert(\"LiquidationEngine/file-unrecognized-param\");\n        emit ModifyParameters(what, data);\n    }\n    function modifyParameters(bytes32 what, uint256 data) external isAuthorized {\n        if (what == \"GlobalLiquidationLimit\") GlobalLiquidationLimit = data;\n        else if (what == \"LiquidatorReward\") LiquidatorReward = data;\n        else revert(\"LiquidationEngine/file-unrecognized-param\");\n        emit ModifyParameters(what, data);\n    }\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint256 data) external isAuthorized {\n        if (what == \"liquidationPenalty\") {\n            require(data >= WAD, \"LiquidationEngine/file-liquidationPenalty-lt-WAD\");\n            collateralTypes[collateralType].liquidationPenalty = data;\n        } else if (what == \"liquidationLimit\") collateralTypes[collateralType].liquidationLimit = data;\n        else revert(\"LiquidationEngine/file-unrecognized-param\");\n        emit ModifyParameters(collateralType, what, data);\n    }\n\n    function liquidationPenalty(bytes32 collateralType) external view returns (uint256) {\n        return collateralTypes[collateralType].liquidationPenalty;\n    }\n\n    // --- CDP Liquidation: all bark and no bite ---\n    function liquidateCDP(bytes32 collateralType, address cdp, address incentivesReceiver, address collateralJoin) external returns (uint256 id) {\n        require(contractEnabled == 1, \"LiquidationEngine/not-contractEnabled\");\n\n        (uint256 collateralAmount, uint256 generatedDebt) = safeEngine.safes(collateralType, cdp);\n        CollateralType memory _cType = collateralTypes[collateralType];\n        uint256 deltaGeneratedDebt;\n        uint256 accumulatedRate;\n        uint256 debtFloor;\n        {\n            uint256 safetyPrice;\n            (, accumulatedRate, safetyPrice,, debtFloor) = safeEngine.collateralTypes(collateralType);\n            require(safetyPrice > 0 && _mul(collateralAmount, safetyPrice) < _mul(generatedDebt, accumulatedRate), \"LiquidationEngine/not-unsafe\");\n\n            // Get the minimum value between:\n            // 1) Remaining space in the general GlobalLiquidationLimit\n            // 2) Remaining space in the collateral liquidationLimit\n            require(GlobalLiquidationLimit > ActiveLiquidationAmount && _cType.liquidationLimit > _cType.activeLiquidationAmount, \"LiquidationEngine/liquidation-limit-hit\");\n            uint256 room = min(GlobalLiquidationLimit - ActiveLiquidationAmount, _cType.liquidationLimit - _cType.activeLiquidationAmount);\n\n            // uint256.max()/(RAD*WAD) = 115,792,089,237,316\n            deltaGeneratedDebt = min(generatedDebt, _mul(room, WAD) / accumulatedRate / _cType.liquidationPenalty);\n\n            // Partial liquidation edge case logic\n            if (generatedDebt > deltaGeneratedDebt) {\n                if (_mul(generatedDebt - deltaGeneratedDebt, accumulatedRate) < debtFloor) {\n\n                    // If the leftover Vault would be dusty, just liquidate it entirely.\n                    // This will result in at least one of activeLiquidationAmount_i > liquidationLimit_i or ActiveLiquidationAmount > GlobalLiquidationLimit becoming true.\n                    // The amount of excess will be bounded above by ceiling(debtFloor_i * liquidationPenalty_i / WAD).\n                    // This deviation is assumed to be small compared to both liquidationLimit_i and GlobalLiquidationLimit, so that\n                    // the extra amount of target DAI over the limits intended is not of economic concern.\n                    deltaGeneratedDebt = generatedDebt;\n                } else {\n\n                    // In a partial liquidation, the resulting auction should also be non-dusty.\n                    require(_mul(deltaGeneratedDebt, accumulatedRate) >= debtFloor, \"LiquidationEngine/dusty-auction-from-partial-liquidation\");\n                }\n            }\n        }\n\n        uint256 deltaCollateral = _mul(collateralAmount, deltaGeneratedDebt) / generatedDebt;\n\n        require(deltaCollateral > 0, \"LiquidationEngine/null-auction\");\n        require(deltaGeneratedDebt <= 2**255 && deltaCollateral <= 2**255, \"LiquidationEngine/overflow\");\n\n        uint256 rewardCollateral = _mul(deltaCollateral, LiquidatorReward) / WAD;\n        uint256 collateral2sell = _sub(deltaCollateral, rewardCollateral);\n        safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType, cdp, incentivesReceiver, address(accountingEngine), -int256(rewardCollateral), 0\n        );\n        safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType, cdp, liquidator, address(accountingEngine), -int256(collateral2sell), -int256(deltaGeneratedDebt)\n        );\n\n        uint256 due = _mul(deltaGeneratedDebt, accumulatedRate);\n        accountingEngine.pushDebtToQueue(due);\n\n        {   // Avoid stack too deep\n            // This calcuation will overflow if deltaGeneratedDebt*rate exceeds ~10^14\n            uint256 amountToRaise = _mul(due, _cType.liquidationPenalty) / WAD;\n            ActiveLiquidationAmount = _add(ActiveLiquidationAmount, amountToRaise);\n            collateralTypes[collateralType].activeLiquidationAmount = _add(_cType.activeLiquidationAmount, amountToRaise);\n\n//            id = AuctionLike(_cType.liquidator).startAuction({\n//                debt: amountToRaise,\n//                collateralToSell: deltaCollateral,\n//                colReceiver: cdp,\n//                incentivesReceiver: incentivesReceiver\n//            });\n\n            // TODO: create algorithm, how to choose stablecoin\n            address stablecoin = EnumerableSetUpgradeable.at(_stablecoinWhitelist, 0);\n            id = IExchange(liquidator).addOrder(\n                address(ICollateralJoin(collateralJoin).collateral()),\n                collateral2sell,\n                // amountToRaise, TODO: add minAmount?\n                stablecoin,\n                address(accountingEngine),\n                DiscountType.middle, // TODO: should depend on HF\n                collateralJoin\n            );\n        }\n\n        emit LiquidateCDP(collateralType, cdp, deltaCollateral, deltaGeneratedDebt, due, liquidator, id);\n    }\n\n    function reduceActiveLiquidationAmount(bytes32 collateralType, uint256 rad) external isAuthorized {\n        ActiveLiquidationAmount = _sub(ActiveLiquidationAmount, rad);\n        collateralTypes[collateralType].activeLiquidationAmount = _sub(collateralTypes[collateralType].activeLiquidationAmount, rad);\n        emit ReduceActiveLiquidationAmount(collateralType, rad);\n    }\n\n    // --- Stablecoin Whitelist ---\n    EnumerableSetUpgradeable.AddressSet internal _stablecoinWhitelist;\n\n    function addWhitelistStablecoin(address _stablecoin) public isAuthorized {\n        EnumerableSetUpgradeable.add(_stablecoinWhitelist, _stablecoin);\n    }\n\n    function removeWhitelistStablecoin(address _stablecoin) public isAuthorized {\n        EnumerableSetUpgradeable.remove(_stablecoinWhitelist, _stablecoin);\n    }\n\n    function hasWhitelistStablecoin(address _stablecoin) public view returns(bool) {\n        return EnumerableSetUpgradeable.contains(_stablecoinWhitelist, _stablecoin);\n    }\n}\n"
    },
    "contracts/makerdao/interfaces/IAccountingEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport {IAuthWithContractEnabled} from \"./IAuthWithContractEnabled.sol\";\n\n/**\n * @title ITaxCollector\n **/\ninterface IAccountingEngine is IAuthWithContractEnabled {\n    /* ==================== EVENTS ===============-===== */\n    event StableProSwapped(uint256 amount);\n\n    /* ==================== ERRORS ===============-===== */\n    error BadStablecoin(address asset);\n\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    function pushDebtToQueue(uint amountToRaise) external;\n\n    function swapStableProToStablecoin(address stablecoinToken, uint256 stableProAmountE18) external;\n}\n"
    },
    "contracts/makerdao/interfaces/IAuth.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface IAuth {\n    function addAuthorization(address usr) external;\n    function removeAuthorization(address usr) external;\n}\n"
    },
    "contracts/makerdao/interfaces/IAuthWithContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport {IAuth} from \"./IAuth.sol\";\n\ninterface IAuthWithContractEnabled is IAuth {\n    event DisableContract();\n\n    function disableContract() external;\n}\n"
    },
    "contracts/makerdao/interfaces/ICoin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICoin is IERC20 {\n    function mint(address account, uint256 amount) external;\n    function burn(address account, uint256 amount) external returns (uint256);\n}\n"
    },
    "contracts/makerdao/interfaces/ICoinJoin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport {IAuthWithContractEnabled} from \"./IAuthWithContractEnabled.sol\";\n\n/**\n * @title ITaxCollector\n **/\ninterface ICoinJoin is IAuthWithContractEnabled {\n    /* ==================== EVENTS ==================== */\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n\n    /* ==================== METHODS ==================== */\n\n    /**\n    * @notice Join pegged-coins in the system\n    * @dev Exited coins have 18 decimals but inside the system they have 45 (rad) decimals.\n           When we join, the amount (wad) is multiplied by 10**27 (ray)\n    * @param usr Account that will receive the joined coins\n    * @param wad Amount of external coins to join (18 decimal number)\n    **/\n    function join(address usr, uint wad) external;\n\n    /**\n    * @notice Exit pegged-coins from the system and inside 'Coin.sol'\n    * @dev Inside the system, coins have 45 (rad) decimals but outside they have 18 decimals (wad).\n           When we exit, we specify a wad amount of coins and then the contract automatically multiplies\n           wad by 10**27 to move the correct 45 decimal coin amount to this adapter\n    * @param usr Account that will receive the exited coins\n    * @param wad Amount of internal coins to join (18 decimal number that will be multiplied by ray)\n    **/\n    function exit(address usr, uint wad) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ICollateralJoin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAuthWithContractEnabled} from \"./IAuthWithContractEnabled.sol\";\n\n/**\n * @title ITaxCollector\n **/\ninterface ICollateralJoin is IAuthWithContractEnabled {\n    /* ==================== METHODS ==================== */\n\n    function collateral() external view returns(IERC20Metadata);\n\n    /**\n    * @notice Join collateral in the system\n    * @param usr Account from which we transferFrom collateral and add it in the system\n    * @param wad Amount of collateral to transfer in the system (represented as a number with 18 decimals)\n    **/\n    function join(address usr, uint wad) external;\n\n    /**\n    * @notice Exit collateral from the system\n    * @param usr Account to which we transfer the collateral\n    * @param wad Amount of collateral to transfer to 'account' (represented as a number with 18 decimals)\n    **/\n    function exit(address usr, uint wad) external;\n}\n"
    },
    "contracts/makerdao/interfaces/IDssCdpManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title IDssMiddleware\n **/\ninterface IDssCdpManager {\n\n    /* ==================== STRUCTS ==================== */\n\n    struct List {\n        uint prev;\n        uint next;\n    }\n\n    /* ==================== EVENTS ===================== */\n\n    event NewCdp(address indexed usr, address indexed own, uint indexed cdp);\n\n\n    /* ==================== METHODS ==================== */\n\n    // @notice Allow/disallow a usr address to manage the cdp.\n    function cdpAllow(uint cdp, address usr, uint ok) external;\n\n    // @notice Allow/disallow a usr address to quit to the the sender urn.\n    function allowHandler(address usr, uint ok) external;\n\n    // @notice Open a new cdp for a given usr address.\n    function openSafe(bytes32 collateralType, address usr) external returns (uint);\n\n    // @notice Give the cdp ownership to a dst address.\n    function transferSafeOwnership(uint cdp, address dst) external;\n\n    // @notice Modify the cdp keeping the generated DAI or collateral freed in the cdp urn address.\n    function modifySAFECollateralization(uint cdp, int deltaCollateral, int deltaDebt) external;\n\n    // @notice Transfer wad amount of cdp collateral from the cdp address to a dst address.\n    function transferCollateral(uint cdp, address dst, uint wad) external;\n\n    // @notice Transfer wad amount of any type of collateral (ilk) from the cdp address to a dst address.\n    // This function has the purpose to take away collateral from the system that doesn't correspond to the cdp but was sent there wrongly.\n    function transferCollateral(bytes32 ilk, uint cdp, address dst, uint wad) external;\n\n    // @notice Transfer wad amount of DAI from the cdp address to a dst address.\n    function transferInternalCoins(uint cdp, address dst, uint rad) external;\n\n    // @notice Quit the system, migrating the cdp (lockedCollateral, generatedDebt) to a different dst urn\n    function quit(uint cdp, address dst) external;\n\n    // @notice Import a position from src urn to the urn owned by cdp\n    function enter(address src, uint cdp) external;\n\n    // @notice Move a position from cdpSrc urn to the cdpDst urn\n    function moveSAFE(uint cdpSrc, uint cdpDst) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ILiquidationEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title ITaxCollector\n **/\ninterface ILiquidationEngine {\n    /* ==================== STRUCTS ==================== */\n\n    struct CollateralType {\n        uint256 liquidationPenalty;  // Liquidation Penalty                                          [wad]\n        uint256 liquidationLimit;  // Max DAI needed to cover debt+fees of active auctions per collateralType [rad]\n        uint256 activeLiquidationAmount;  // Amt DAI needed to cover debt+fees of active auctions per collateralType [rad]\n    }\n\n    /* ==================== EVENTS ===============-===== */\n\n    event AddAuthorization(address indexed usr);\n    event RemoveAuthorization(address indexed usr);\n\n    event ModifyParameters(bytes32 indexed what, uint256 data);\n    event ModifyParameters(bytes32 indexed what, address data);\n    event ModifyParameters(bytes32 indexed collateralType, bytes32 indexed what, uint256 data);\n    event ModifyParameters(bytes32 indexed collateralType, bytes32 indexed what, address liquidator);\n\n    event LiquidateCDP(\n        bytes32 indexed collateralType,\n        address indexed cdp,\n        uint256 lockedCollateral,\n        uint256 generatedDebt,\n        uint256 due,\n        address liquidator,\n        uint256 indexed id\n    );\n    event ReduceActiveLiquidationAmount(bytes32 indexed collateralType, uint256 rad);\n\n    /* ==================== MUTABLE METHODS ==================== */\n\n    // --- Administration ---\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, address data) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n\n    /**\n      * @notice Liquidate a Vault and start a Dutch auction to sell its collateral for DAI.\n      * @dev The entire Vault will be liquidated except when the target amount of DAI to be raised in\n      * the resulting auction (debt of Vault + liquidation penalty) causes either ActiveLiquidationAmount to exceed\n      * GlobalLiquidationLimit or collateralType.activeLiquidationAmount to exceed collateralType.liquidationLimit by an economically significant amount. In that\n      * case, a partial liquidation is performed to respect the global and per-collateralType limits on\n      * outstanding DAI target. The one exception is if the resulting auction would likely\n      * have too little collateral to be interesting to Keepers (debt taken from Vault < collateralType.debtFloor),\n      * in which case the function reverts. Please refer to the code and comments within if\n      * more detail is desired.\n      * @param collateralType - collateral type\n      * @param cdp - address of cdp position\n      * @param incentivesReceiver - address that will receive the liquidation reward, if any.\n      * @param collateralJoin - address of collateral adapter\n    **/\n    function liquidateCDP(bytes32 collateralType, address cdp, address incentivesReceiver, address collateralJoin) external returns (uint256 id);\n\n    function reduceActiveLiquidationAmount(bytes32 collateralType, uint256 rad) external;\n\n    // --- Whitelist ---\n    function addWhitelistStablecoin(address _stablecoin) external;\n    function removeWhitelistStablecoin(address _stablecoin) external;\n\n    /* ==================== VIEW METHODS ==================== */\n\n    function liquidationPenalty(bytes32 collateralType) external view returns (uint256);\n\n    function hasWhitelistStablecoin(address _stablecoin) external view returns(bool);\n}\n"
    },
    "contracts/makerdao/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceFeed\n **/\ninterface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n}\n"
    },
    "contracts/makerdao/interfaces/ISafeEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title SafeEngine\n * @notice The single source of truth for the Maker Protocol. It contains the accounting system of the core Vault,\n * Internal Dai balances, and collateral state. It houses the public interface for Vault management,\n * allowing safe(= CDP or Vault) owners to adjust their Vault state balances. It also contains the public interface\n * for Vault fungibility, allowing safe (Vault) owners to transfer, split, and merge Vaults.\n * Excluding these interfaces, SAFEEngine is accessed through trusted smart contract modules.\n **/\ninterface ISafeEngine {\n    /* ==================== METHODS ==================== */\n\n    // --- Data ---\n    struct CollateralType {\n        uint256 debtAmount;       // Total debt issued for this specific collateral type                          [wad]\n        uint256 accumulatedRate;  // Accumulator for interest accrued on this collateral type                     [ray]\n        uint256 safetyPrice;      // Floor price at which a CDP is allowed to generate debt                       [ray]\n        uint256 debtCeiling;      // Maximum amount of debt that can be generated with this collateral type       [rad]\n        uint256 debtFloor;        // Minimum amount of debt that must be generated by a CDP using this collateral [rad]\n    }\n    struct SAFE {\n        uint256 lockedCollateral; // Total amount of collateral locked in a SAFE/CDP  [wad]\n        uint256 generatedDebt;    // Total amount of debt generated by a SAFE/CDP     [wad]\n    }\n\n    // --- VARS ---\n\n    function safes(bytes32, address) external view returns (uint, uint);\n\n    function collateralTypes(bytes32) external view returns (\n        uint256 debtAmount,   // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,\n        uint256 debtCeiling,\n        uint256 debtFloor\n    );\n\n    function tokenCollateral(bytes32, address) external view returns (uint256);\n\n    function coinBalance(address) external view returns (uint256);\n\n    function debtBalance(address) external view returns (uint256);\n\n    // --- Auth ---\n    /**\n     * @notice Allow an address to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function approveSAFEModification(address usr) external;\n\n    /**\n     * @notice Deny an address the rights to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function denySAFEModification(address usr) external;\n\n    // --- Administration ---\n\n    function initializeCollateralType(bytes32 collateralType) external;\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n\n    // --- Fungibility ---\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external;\n    function transferInternalCoins(address src, address dst, uint256 rad) external;\n\n    // --- CDP Manipulation ---\n    /**\n     * @notice Add/remove collateral or put back/generate more debt in a CDP\n     * @param collateralType Type of collateral to withdraw/deposit in and from the CDP\n     * @param cdp Target CDP\n     * @param collateralSource Account we take collateral from/put collateral into\n     * @param debtDestination Account from which we credit/debit coins and debt\n     * @param deltaCollateral Amount of collateral added/extract from the CDP\n     * @param deltaDebt Amount of debt to generate/repay\n     */\n    function modifySAFECollateralization(bytes32 collateralType, address cdp, address collateralSource, address debtDestination, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Fungibility ---\n    /**\n     * @notice Transfer collateral and/or debt between CDPs\n     * @param collateralType Collateral type transferred between CDPs\n     * @param src Source CDP\n     * @param dst Destination CDP\n     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst\n     * @param deltaDebt Amount of debt to take/add into src and give/take from dst\n     */\n    function transferSAFECollateralAndDebt(bytes32 collateralType, address src, address dst, int deltaCollateral, int deltaDebt) external;\n\n    // --- CDP Confiscation ---\n    /**\n     * @notice Normally used by the LiquidationEngine in order to confiscate collateral and\n       debt from a CDP and give them to someone else\n     * @param collateralType Collateral type the CDP has locked inside\n     * @param cdp Target CDP\n     * @param collateralCounterparty Who we take/give collateral to\n     * @param debtCounterparty Who we take/give debt to\n     * @param deltaCollateral Amount of collateral taken/added into the CDP\n     * @param deltaDebt Amount of debt taken/added into the CDP\n     */\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address cdp, address collateralCounterparty, address debtCounterparty, int deltaCollateral, int deltaDebt) external;\n\n    // --- Settlement ---\n    /**\n     * @notice Nullify an amount of coins with an equal amount of debt\n     * @param rad Amount of debt & coins to destroy (expressed as a number with 45 decimals)\n     */\n    function settleDebt(uint rad) external;\n\n    /**\n     * @notice Usually called by CoinSavingsAccount in order to create unbacked debt\n     * @param debtDestination Usually AccountingEngine that can settle decreaseSoldAmount with surplus\n     * @param coinDestination Usually CoinSavingsAccount who passes the new coins to depositors\n     * @param rad Amount of debt to create (expressed as a number with 45 decimals)\n     */\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external;\n\n    // --- Rates ---\n    /**\n     * @notice Usually called by TaxCollector in order to accrue interest on a specific collateral type\n     * @param collateralType Collateral type we accrue interest for\n     * @param surplusDst Destination for amount of surplus created by applying the interest rate\n       to debt created by CDPs with 'collateralType'\n     * @param accumulatedRate Multiplier applied to the debtAmount in order to calculate the surplus\n     */\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ITaxCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title ITaxCollector\n **/\ninterface ITaxCollector {\n    /* ==================== STRUCTS ==================== */\n\n    struct CollateralType {\n        uint256 stabilityFee;      // Collateral-specific, per-second stability fee contribution [ray]\n        uint256 latestUpdateTime;  // Time of last taxSingle [unix epoch time]\n    }\n\n\n    /* ==================== METHODS ==================== */\n\n    // --- Administration ---\n    function initializeCollateralType(bytes32 collateralType) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, address data) external;\n\n\n    // --- Stability Fee Collection ---\n    /**\n     * @notice Collect tax from a single collateral type\n     * @param collateralType Collateral type to tax\n     */\n    function taxSingle(bytes32 collateralType) external returns (uint rate);\n}\n"
    },
    "contracts/makerdao/utils/AuthWithContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IAuthWithContractEnabled} from \"../interfaces/IAuthWithContractEnabled.sol\";\n\nabstract contract AuthWithContractEnabled is IAuthWithContractEnabled {\n    error NotAuthorized();\n    error NotContractEnabled();\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized {\n        if (contractEnabled != 1) revert NotContractEnabled();\n        authorizedAccounts[usr] = 1;\n    }\n    function removeAuthorization(address usr) external isAuthorized {\n        if (contractEnabled != 1) revert NotContractEnabled();\n        authorizedAccounts[usr] = 0;\n    }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert NotAuthorized();\n        _;\n    }\n\n    uint256 public contractEnabled; // Access flag, indicates whether this contract is still active\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n}\n"
    },
    "contracts/makerdao/utils/AuthWithoutContractEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IAuthWithContractEnabled} from \"../interfaces/IAuthWithContractEnabled.sol\";\n\nabstract contract AuthWithoutContractEnabled is IAuthWithContractEnabled {\n    error NotAuthorized();\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address usr) external isAuthorized { authorizedAccounts[usr] = 1; }\n    function removeAuthorization(address usr) external isAuthorized { authorizedAccounts[usr] = 0; }\n    modifier isAuthorized {\n        if (authorizedAccounts[msg.sender] != 1) revert NotAuthorized();\n        _;\n    }\n\n    uint256 public contractEnabled; // Access flag, indicates whether this contract is still active\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n}\n"
    },
    "contracts/makerdao/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nabstract contract Math {\n    uint256 constant WAD = 10 ** 18;\n\n    /**\n    * @notice Calculates the sum of an unsigned integer and a signed integer\n    * @param  x Unsigned integer\n    * @param  y Signed integer\n    * @return z Unsigned sum of `x` and `y`\n    */\n    function _add(uint x, int y) internal pure returns (uint z) {\n        if (y >= 0) {\n            z = x + uint256(y);\n        } else {\n            z = x - uint256(-y);\n        }\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    /**\n    * @notice Calculates the substraction of an unsigned integer and a signed integer\n    * @param  x Unsigned integer\n    * @param  y Signed integer\n    * @return z Unsigned substraction of `x` and `y`\n    */\n    function _sub(uint x, int y) internal pure returns (uint z) {\n        if (y >= 0) {\n            z = x - uint256(y);\n        } else {\n            z = x + uint256(-y);\n        }\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function _mul(uint x, int y) internal pure returns (int z) {\n        z = int(x) * y;\n        require(int(x) >= 0);\n        require(y == 0 || z / y == int(x));\n    }\n\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function _sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function _mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x <= y ? x : y;\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n}\n"
    },
    "contracts/periphery/contracts/interfaces/oracle/ISuOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// solhint-disable compiler-version\npragma solidity >=0.7.6;\n\ninterface ISuOracle {\n    /**\n     * @notice WARNING! Read this description very carefully!\n     *     function getFiatPrice1e18(address asset) returns (uint256) that:\n     *         basicAmountOfAsset * getFiatPrice1e18(asset) / 1e18 === $$ * 1e18\n     *     in other words, it doesn't matter what's the erc20.decimals is,\n     *     you just multiply token balance in basic units on value from oracle and get dollar amount multiplied on 1e18.\n     *\n     * different assets have different deviation threshold (errors)\n     *     for wBTC it's <= 0.5%, read more https://data.chain.link/ethereum/mainnet/crypto-usd/btc-usd\n     *     for other asset is can be larger based on particular oracle implementation.\n     *\n     * examples:\n     *     market price of btc = $30k,\n     *     for 0.1 wBTC the unit256 amount is 0.1 * 1e18\n     *     0.1 * 1e18 * (price1e18 / 1e18) == $3000 == uint256(3000*1e18)\n     *     => price1e18 = 30000 * 1e18;\n     *\n     *     market price of usdt = $0.97,\n     *     for 1 usdt uint256 = 1 * 1e6\n     *     so 1*1e6 * price1e18 / 1e18 == $0.97 == uint256(0.97*1e18)\n     *     => 1*1e6 * (price1e18 / 1e18) / (0.97*1e18)   = 1\n     *     =>  price1e18 = 0.97 * (1e18/1e6) * 1e18\n     *\n     *    assume market price of wBTC = $31,503.77, oracle error = $158\n     *\n     *     case #1: small amount of wBTC\n     *         we have 0.0,000,001 wBTC that is worth v = $0.00315 ± $0.00001 = 0.00315*1e18 = 315*1e13 ± 1*1e13\n     *         actual balance on the asset b = wBTC.balanceOf() =  0.0000001*1e18 = 1e11\n     *         oracle should return or = oracle.getFiatPrice1e18(wBTC) <=>\n     *         <=> b*or = v => v/b = 315*1e13 / 1e11 = 315*1e2 ± 1e2\n     *         error = or.error * b = 1e2 * 1e11 = 1e13 => 1e13/1e18 usd = 1e-5 = 0.00001 usd\n     *\n     *     case #2: large amount of wBTC\n     *         v = 2,000,000 wBTC = $31,503.77 * 2m ± 158*2m = $63,007,540,000 ± $316,000,000 = 63,007*1e24 ± 316*1e24\n     *         for calc convenience we increase error on 0.05 and have v = 63,000*24 ± 300*1e24 = (630 ± 3)*1e26\n     *         b = 2*1e6 * 1e18 = 2*1e24\n     *         or = v/b = (630 ± 3)*1e26 / 2*1e24 = 315*1e2 ± 1.5*1e2\n     *         error = or.error * b = 1.5*100 * 2*1e24 = 3*1e26 = 3*1e8*1e18 = $300,000,000 ~ $316,000,000\n     *\n     *     assume the market price of USDT = $0.97 ± $0.00485,\n     *\n     *     case #3: little amount of USDT\n     *         v = USDT amount 0.005 = 0.005*(0.97 ± 0.00485) = 0.00485*1e18 ± 0.00002425*1e18 = 485*1e13 ± 3*1e13\n     *         we rounded error up on (3000-2425)/2425 ~= +24% for calculation convenience.\n     *         b = USDT.balanceOf() = 0.005*1e6 = 5*1e3\n     *         b*or = v => or = v/b = (485*1e13 ± 3*1e13) / 5*1e3 = 970*1e9 ± 6*1e9\n     *         error = 6*1e9 * 5*1e3 / 1e18 = 30*1e12/1e18 = 3*1e-5 = $0,00005\n     *\n     *     case #4: lot of USDT\n     *         v = we have 100,000,000,000 USDT = $97B = 97*1e9*1e18 ± 0.5*1e9*1e18\n     *         b = USDT.balanceOf() = 1e11*1e6 = 1e17\n     *         or = v/b = (97*1e9*1e18 ± 0.5*1e9*1e18) / 1e17 = 970*1e9 ± 5*1e9\n     *         error = 5*1e9 * 1e17 = 5*1e26 = 0.5 * 1e8*1e18\n     *\n     * @param asset - address of erc20 token contract\n     * @return usdPrice1e18 such that asset.balanceOf() * getFiatPrice1e18(asset) / 1e18 == $$ * 1e18\n     **/\n    function getFiatPrice1e18(address asset) external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}