{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IRewardChefV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../periphery/contracts/interfaces/oracle/ISuOracle.sol\";\n\n/**\n * @title RewardChefV2\n * @notice fork of MasterChefV2(13/05/2023) https://etherscan.io/address/0xef0881ec094552b2e128cf945ef17a6752b4ec5d#code\n * @dev This contract is based on MVC2, but uses \"virtual\" balances instead of storing real ERC20 tokens\n * and uses address of this assets instead of pid.\n * Rewards that are distributed have to be deposited using refillReward(uint256 amount, uint64 endBlock)\n **/\ninterface IRewardChefV2 {\n    /**\n      * @notice Info of each reward pool.\n      * @param accSushiPerShare -\n      * @param lastRewardBlock -\n      * @param allocPoint - The amount of allocation points assigned to the pool.\n      * Also known as the amount of REWARD_TOKEN to distribute per block.\n      * @param lpSupply -\n     **/\n    struct PoolInfo {\n        uint128 accSushiPerShare;\n        uint64 lastRewardBlock;\n        uint64 allocPoint;\n        uint256 lpSupply;\n    }\n\n    /**\n      * @notice Info of each user.\n      * @param amount - token amount the user has provided.\n      * @param rewardDebt - The amount of rewards entitled to the user.\n      * @param multiplicator1e18 - deposit amount multiplicator for current user, that depends on his lockupPeriod\n      * @param lockupPeriodSeconds - users lockupPeriod in seconds\n      * @param lockupStartTimestamp - timestamp when user start lockup\n     **/\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n\n        uint256 multiplicator1e18;\n        uint256 lockupPeriodSeconds;\n        uint256 lockupStartTimestamp;\n    }\n\n    /**\n      * @notice Lockup info struct for a view method getPossibleLockupPeriodsSeconds()\n      * @param lockupPeriodSeconds - available lockupPeriod in seconds\n      * @param multiplicator1e18 - deposit amount multiplicator for this lockup period\n     **/\n    struct ILockupPeriod {\n        uint256 lockupPeriodSeconds;\n        uint256 multiplicator1e18;\n    }\n\n    // =======================================EVENTS=============================================\n    event VirtualDeposit(address indexed user, address indexed asset, uint256 amount);\n    event VirtualWithdraw(address indexed user, address indexed asset, uint256 amount);\n    event ResetAmount(\n        address indexed user, address indexed asset, address indexed to, uint256 amount, uint256 lockupPeriodSeconds\n    );\n    event Harvest(address indexed user, address indexed asset, uint256 amount);\n    event LogPoolAddition(address indexed asset, uint256 allocPoint);\n    event LogSetPool(address indexed asset, uint256 allocPoint);\n    event LogUpdatePool(address indexed asset, uint64 lastRewardBlock, uint256 lpSupply, uint256 accSushiPerShare);\n\n    // =======================================ERRORS=============================================\n    error BadEndBlockForRefill();\n    error ZeroLockupPeriod();\n    error ZeroMultiplicator();\n    error PoolExist();\n    error PoolNotExist();\n    error DifferentLockup();\n    error HarvestBeforeLockup();\n\n    // =========================================VARS=============================================\n    /**\n     *  @dev Total allocation points. Must be the sum of all allocation points in all pools.\n     * The good practice, to always keep this variable is equal 1000.\n     */\n    function totalAllocPoint() external view returns ( uint256 );\n\n    // =======================================REWARDER=============================================\n    // solhint-disable-next-line func-name-mixedcase\n    function REWARD_TOKEN() external view returns ( IERC20Upgradeable );\n    // solhint-disable-next-line func-name-mixedcase\n    function ORACLE() external view returns ( ISuOracle );\n    function rewardPerBlock() external view returns ( uint256 );\n    function rewardEndBlock() external view returns ( uint256 );\n\n    /**\n     * @dev admin transfer REWARD_TOKEN to contract to increase rewards per block\n     */\n    function refillReward(uint256 amount, uint64 endBlock) external;\n    /**\n     * @dev returns total amount of rewards allocated to the all pools on the rage (startBlock, endBlock]\n     * i.e. excluding startBlock but including endBlock\n     */\n    function rewardsBetweenBlocks(uint256 startBlock, uint256 endBlock) external returns ( uint256 );\n\n    //=======================================LOCKUP LOGIC===========================================\n    /**\n     * @notice view method that return all lockupPeriods in ILockupPeriod struct\n     */\n    function getPossibleLockupPeriodsSeconds() external view returns (ILockupPeriod[] memory);\n\n    function getUserLockupPeriodsSeconds(address asset, address user) external view returns (uint256 lockupPeriodSeconds);\n\n    /**\n     * @notice method to add new LockupPeriods with it multiplicator\n     * @dev If multiplicator1e18 == 0 => we remove lockupPeriodSeconds else we add it\n     * @param lockupPeriodSeconds Amount of seconds of lockupPeriod we want to add/remove\n     * @param multiplicator1e18 Multiplicator for that lockupPeriod\n     */\n    function setPossibleLockupPeriodsSeconds(uint256 lockupPeriodSeconds, uint256 multiplicator1e18) external;\n\n    //================================CORE REWARD CHEF METHODS======================================\n    /**\n     * @notice Add a new reward pool. Can only be called by the admin. Can't add the same LP token more than once.\n     * @param allocPoint AP of the new pool.\n     * @param _asset Address of the ERC-20 token.\n     */\n    function add(uint256 allocPoint, address _asset) external;\n\n    /**\n     * @notice Update the given pool's REWARD_TOKEN allocation point. Can only be called by the admin.\n     * Can't be called for asset that was not added by add() function.\n     * @param _asset Address of the ERC-20 token.\n     * @param _allocPoint New AP of the pool.\n     */\n    function set(address _asset, uint256 _allocPoint) external;\n\n    /**\n     * @notice View function to see pending REWARD_TOKEN on frontend.\n     * @param _asset Address of the ERC-20 token.\n     * @param _user Address of user.\n     * @return pending REWARD_TOKEN reward for a given user.\n     */\n    function pendingSushi(address _asset, address _user) external view returns ( uint256 );\n\n    /**\n     * @notice Update reward variables of the given pool.\n     * @param asset Asset address\n     * @return updated pool info\n     */\n    function updatePool(address asset) external returns ( PoolInfo memory );\n\n    /**\n     * @notice Update reward variables for all pools. Be careful of gas spending!\n     */\n    function updateAllPools() external;\n\n    /**\n     * @notice analogues to MCV2 Deposit method, but can be called only by trusted address (onlyRewardAccess)\n     * that is trusted to honestly calc how many \"virtual\" tokens have to be allocated for each user.\n     * @param asset Asset address\n     * @param to User for whom we will increase the virtual balance\n     * @param amountEDecimal Quantity without taking into account the multiplier that we will add\n     * @param lockupPeriodSeconds Current deposit lockup period. Can't increase amount with 2 different lockupPeriods\n     */\n    function increaseAmount(address asset, address to, uint256 amountEDecimal, uint256 lockupPeriodSeconds) external;\n\n    /**\n     * @notice Analogues to MVC2 Withdraw method, that can be called only by trusted address (onlyRewardAccess)\n     * that is trusted to honestly calc how many \"virtual\" tokens have to be allocated for each user.\n     * @param asset Asset address\n     * @param to User for whom we will subtract the virtual balance\n     * @param amountEDecimal Quantity without taking into account the multiplier that we will subtract\n     */\n    function decreaseAmount(address asset, address to, uint256 amountEDecimal) external;\n\n    /**\n     * @notice View method that return penalty for user that will decrease amount by {amountEDecimal}\n     * @param asset Asset address\n     * @param to User who will decrease his deposit amount\n     * @param amountEDecimal Quantity without taking into account the multiplier that we will subtract\n     */\n    function getDecreaseAmountRewardPenalty(\n        address asset,\n        address to,\n        uint256 amountEDecimal\n    ) external view returns (uint256);\n\n    /**\n     * @notice Harvest proceeds for transaction sender to {to}.\n     * @dev Here we send msg.sender pendingSushi to {to} and update lockup period.\n     * @param asset Asset address\n     * @param to Receiver of REWARD_TOKEN rewards.\n     */\n    function harvest(address asset, address to, uint256 newLockupPeriodSeconds) external;\n\n    /**\n     * @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n     * @param asset Asset address\n     * @param to The address of the user whose information will be cleared\n     */\n    function resetAmount(address asset, address to) external;\n\n    //================================VIEW METHODS======================================\n    /**\n     * @notice Method for frontend that return pool APR in base of 1e18\n     * @param asset Asset address\n     */\n    function getPoolApr(address asset) external view returns (uint256);\n\n    /**\n     * @notice Reward tokens can be locked for certain period of time.\n     * So user have to wait until at least timestamp to be able to harvest them.\n     * There's no lock or any restriction on withdrawing principle.\n     * This function return end timestamp for that lock.\n     * @param asset Asset address\n     * @param user User address\n     */\n    function getHarvestLockupEndTimestamp(address asset, address user) external view returns (uint256);\n}\n"
    },
    "contracts/makerdao/core/adapters/CoinJoin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"../../../interfaces/IRewardChefV2.sol\";\nimport \"../../../periphery/contracts/access-control/SuAuthenticatedNonUpgradeable.sol\";\nimport \"../../interfaces/ICoin.sol\";\nimport \"../../interfaces/ICoinJoin.sol\";\nimport \"../../interfaces/ICollateralJoin.sol\";\nimport \"../../interfaces/ISafeEngine.sol\";\n\n// CHANGED: in dss all joins contracts are in join.sol. We split and rename them to read this better.\n// In CoinJoin (DaiJoin) we added events and integration with rewardChef during join and exit.\n// Added SuAuthenticated instead of authorizedAccounts.\n\ncontract CoinJoin is ICoinJoin, SuAuthenticatedNonUpgradeable {\n    address public rewardChef;\n    ISafeEngine public safeEngine;\n    // Coin created by the system; this is the external, ERC-20 representation, not the internal 'coinBalance'\n    ICoin public systemCoin;\n    mapping (bytes32 => address) public collateralAddress; // CollateralType => address of collateral\n\n    constructor(address accessControlSingleton, address safeEngine_, address systemCoin_, address rewardChef_)\n        SuAuthenticatedNonUpgradeable(accessControlSingleton) public {\n        contractEnabled = 1;\n        safeEngine = ISafeEngine(safeEngine_);\n        systemCoin = ICoin(systemCoin_);\n        rewardChef = rewardChef_;\n    }\n\n    uint public contractEnabled;\n    function disableContract() external onlyDisablerAccess {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    uint constant ONE = 10 ** 27;\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function updateRewardChef(address rewardChef_) external onlyDAO {\n        rewardChef = rewardChef_;\n        emit UpdateRewardChef();\n    }\n\n    function initializeCollateralType(bytes32 _collateralType, address _collateralAddress) external onlyAdmin {\n        collateralAddress[_collateralType] = _collateralAddress;\n    }\n\n    // TODO: secure user, maybe add allowedContracts that can set it.\n    // msg.sender in that case will be a proxy contract, so we need to add create proxy in DSSProxyActions?\n    function join(bytes32 collateralType, address user, address cdp, uint wad) external {\n        safeEngine.transferInternalCoins(address(this), cdp, mul(ONE, wad));\n        systemCoin.burn(msg.sender, wad);\n\n        address colAddr = collateralAddress[collateralType];\n        (bool success,) = rewardChef.call(\n            abi.encodeWithSignature(\"decreaseAmount(address,address,uint256)\", colAddr, user, wad)\n        );\n        if (!success) {\n            emit DecreaseAmountFailed(colAddr, user, wad);\n        }\n\n        emit Join(cdp, wad);\n    }\n    function joinNoReward(address cdp, uint wad) external {\n        safeEngine.transferInternalCoins(address(this), cdp, mul(ONE, wad));\n        systemCoin.burn(msg.sender, wad);\n        emit JoinNoReward(cdp, wad);\n    }\n\n    function exit(bytes32 collateralType, address user, uint256 lockupPeriodSeconds, address cdp, uint wad) external {\n        require(contractEnabled == 1, \"CoinJoin/not-contractEnabled\");\n        safeEngine.transferInternalCoins(msg.sender, address(this), mul(ONE, wad));\n        systemCoin.mint(cdp, wad);\n\n        address colAddr = collateralAddress[collateralType];\n        uint256 userLockupPeriod = IRewardChefV2(rewardChef).getUserLockupPeriodsSeconds(colAddr, user);\n        if (userLockupPeriod != 0 && userLockupPeriod != lockupPeriodSeconds) revert BadLockupPeriod();\n        (bool success,) = rewardChef.call(\n            abi.encodeWithSignature(\n                \"increaseAmount(address,address,uint256,uint256)\", colAddr, user, wad, lockupPeriodSeconds\n            )\n        );\n        if (!success) {\n            emit IncreaseAmountFailed(colAddr, user, wad, 1);\n        }\n\n        emit Exit(cdp, wad);\n    }\n\n    function exitNoReward(address cdp, uint wad) external {\n        require(contractEnabled == 1, \"CoinJoin/not-contractEnabled\");\n        safeEngine.transferInternalCoins(msg.sender, address(this), mul(ONE, wad));\n        systemCoin.mint(cdp, wad);\n        emit ExitNoReward(cdp, wad);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(ICoinJoin).interfaceId || interfaceId == type(IERC165).interfaceId || ACCESS_CONTROL_SINGLETON.supportsInterface(interfaceId);\n    }\n}\n\n"
    },
    "contracts/makerdao/externalContracts/DssProxyActions.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// DssProxyActions.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n// CHANGED: removed some functions. As default this contract was too large to deploy. Also\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IDssCdpManager.sol\";\nimport \"../interfaces/ITaxCollector.sol\";\nimport \"../interfaces/ICoinJoin.sol\";\nimport \"../interfaces/ICollateralJoin.sol\";\n\npragma solidity ^0.8.0;\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nabstract contract Math {\n    uint256 constant RAY = 10 ** 27;\n\n    // Internal functions\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    function toInt(uint x) internal pure returns (int y) {\n        y = int(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    function toRad(uint wad) internal pure returns (uint rad) {\n        rad = mul(wad, 10 ** 27);\n    }\n\n    function convertTo18(ICollateralJoin collateralJoin, uint256 amt) internal returns (uint256 wad) {\n        // For those collaterals that have less than 18 decimals precision we need to do the conversion\n        // before passing to modifySAFECollateralization function\n        // Adapters will automatically handle the difference of precision\n        wad = mul(\n            amt,\n            10 ** (18 - collateralJoin.decimals())\n        );\n    }\n}\n\ncontract DssProxyActions is Math {\n    // Internal functions\n    function _getGeneratedDeltaDebt(\n        ISafeEngine safeEngine,\n        address taxCollector,\n        address safe,\n        bytes32 collateralType,\n        uint wad\n    ) internal returns (int deltaDebt) {\n        // Updates stability fee rate\n        uint rate = ITaxCollector(taxCollector).taxSingle(collateralType);\n\n        // Gets StablePro balance of the safe in the safeEngine\n        uint stableProBalance = safeEngine.coinBalance(safe);\n\n        // If there was already enough StablePro in the safeEngine balance, just exits it without adding more debt\n        if (stableProBalance < mul(wad, RAY)) {\n            // Calculates the needed deltaDebt so together with the existing StablePro in the safeEngine\n            // is enough to exit wad amount of StablePro tokens\n            deltaDebt = toInt(sub(mul(wad, RAY), stableProBalance) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei\n            // (for the given StablePro wad amount)\n            deltaDebt = mul(uint(deltaDebt), rate) < mul(wad, RAY) ? deltaDebt + 1 : deltaDebt;\n        }\n    }\n\n    function _getRepaidDeltaDebt(\n        ISafeEngine safeEngine,\n        uint stablePro,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (int deltaDebt) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,,,,) = safeEngine.collateralTypes(collateralType);\n        // Gets actual safeDebt value of the safe\n        (, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        // Uses the whole StablePro balance in the safeEngine to reduce the debt\n        deltaDebt = toInt(stablePro / rate);\n        // Checks the calculated deltaDebt is not higher than safe.safeDebt (total debt), otherwise uses its value\n        deltaDebt = uint(deltaDebt) <= safeDebt ? - deltaDebt : - toInt(safeDebt);\n    }\n\n    function _getRepaidAllWad(\n        ISafeEngine safeEngine,\n        address usr,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (uint wad) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,,,,) = safeEngine.collateralTypes(collateralType);\n        // Gets actual safeDebt value of the safe\n        (, uint safeDebt) = safeEngine.safes(collateralType, safe);\n        // Gets actual StablePro amount in the safe\n        uint stablePro = safeEngine.coinBalance(usr);\n\n        uint rad = sub(mul(safeDebt, rate), stablePro);\n        wad = rad / RAY;\n\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n    }\n\n//    function transfer(address gem, address dst, uint amt) public {\n//        GemLike(gem).transfer(dst, amt);\n//    }\n\n    // We make it internal to save some gas\n    // Also we need more args instead of MakerDAO version, because of RewardChef during join/exit\n    function _coinJoin_join(bytes32 collateralType, address apt, address cdp, uint wad) internal {\n        // Gets StablePro from the user's wallet\n        ICoinJoin(apt).systemCoin().transferFrom(msg.sender, address(this), wad);\n        // Approves adapter to take the StablePro amount\n        ICoinJoin(apt).systemCoin().approve(address(apt), wad);\n        // Joins StablePro into the safeEngine\n        ICoinJoin(apt).join(collateralType, msg.sender, cdp, wad);\n    }\n\n    // we make it internal to save some gas\n    function _collateralJoin_join(ICollateralJoin apt, address safe, uint amt) internal {\n        // Gets token from the user's wallet\n        apt.collateral().transferFrom(msg.sender, address(this), amt);\n        // Approves adapter to take the token amount\n        apt.collateral().approve(address(apt), amt);\n        // Joins token collateral into the safeEngine\n        apt.join(safe, amt);\n    }\n\n    /**\n     * For main flow we don't need that functions:\n    function approveSAFEModification(address obj, address usr) public {\n        ISafeEngine(obj).approveSAFEModification(usr);\n    }\n\n    function denySAFEModification(address obj, address usr) public {\n        ISafeEngine(obj).denySAFEModification(usr);\n    }\n\n    function transferSAFEOwnership(address manager, uint cdp, address usr) public {\n        IDssCdpManager(manager).transferSAFEOwnership(cdp, usr);\n    }\n\n    function giveToProxy(address proxyRegistry, address manager, uint cdp, address dst) public {\n        // Gets actual proxy address\n        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n        // Checks if the proxy address already existed and dst address is still the owner\n        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n            uint csize;\n            assembly {\n                csize := extcodesize(dst)\n            }\n            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the CDP\n            require(csize == 0, \"Dst-is-a-contract\");\n            // Creates the proxy for the dst address\n            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n        }\n        // Transfers CDP to the dst proxy\n        give(manager, cdp, proxy);\n    }\n\n    function cdpAllow(address manager, uint cdp, address usr, uint ok) public {\n        IDssCdpManager(manager).cdpAllow(cdp, usr, ok);\n    }\n\n    function allowHandler(address manager, address usr, uint ok) public {\n        IDssCdpManager(manager).allowHandler(usr, ok);\n    }\n\n    function quit(address manager, uint cdp, address dst) public {\n        IDssCdpManager(manager).quit(cdp, dst);\n    }\n\n    function enter(address manager, address src, uint cdp) public {\n        IDssCdpManager(manager).enter(src, cdp);\n    }\n\n    function moveSAFE(address manager, uint cdpSrc, uint cdpOrg) public {\n        IDssCdpManager(manager).shift(cdpSrc, cdpOrg);\n    }\n    **/\n\n    // We also make this functions internal to save gas\n    function transferCollateral(address manager, uint cdp, address dst, uint wad) internal {\n        IDssCdpManager(manager).transferCollateral(cdp, dst, wad);\n    }\n\n    function transferInternalCoins(address manager, uint cdp, address dst, uint rad) internal {\n        IDssCdpManager(manager).transferInternalCoins(cdp, dst, rad);\n    }\n\n    function modifySAFECollateralization(address manager, uint cdp, int deltaCollateral, int deltaDebt) internal {\n        IDssCdpManager(manager).modifySAFECollateralization(cdp, deltaCollateral, deltaDebt);\n    }\n\n    function openSafe(address manager, bytes32 collateralType, address usr) internal returns (uint cdp) {\n        cdp = IDssCdpManager(manager).openSafe(collateralType, usr);\n    }\n\n    // Public functions\n\n    /**\n    // We don't have GNT and don't need ETH as collateral, so we commented this functions\n    function makeGemBag(address gemJoin) public returns (address bag) {\n        bag = GNTJoinLike(gemJoin).make(address(this));\n    }\n\n    function lockETH(address manager, address ethJoin, uint cdp) public payable {\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, address(this));\n        // Locks WETH amount into the CDP\n        IDssCdpManager(manager).safeEngine().modifySAFECollateralization(\n            IDssCdpManager(manager).collateralTypes(cdp),\n            IDssCdpManager(manager).safes(cdp),\n            address(this),\n            address(this),\n            toInt(msg.value),\n            0\n        );\n    }\n\n    function safeLockETH(address manager, address ethJoin, uint cdp, address owner) public payable {\n        require(IDssCdpManager(manager).owns(cdp) == owner, \"bad-owner\");\n        lockETH(manager, ethJoin, cdp);\n    }\n    **/\n\n    function lockTokenCollateral(address manager, ICollateralJoin collateralJoin, uint cdp, uint amt) external {\n        // Takes token amount from user's wallet and joins into the safeEngine\n        _collateralJoin_join(collateralJoin, address(this), amt);\n        // Locks token amount into the CDP\n        IDssCdpManager(manager).safeEngine().modifySAFECollateralization(\n            IDssCdpManager(manager).collateralTypes(cdp),\n            IDssCdpManager(manager).safes(cdp),\n            address(this),\n            address(this),\n            toInt(convertTo18(collateralJoin, amt)),\n            0\n        );\n    }\n\n    /**\n     * Don't see any additional security because attacker could potentially call safeLockGem\n     * with the correct owner address (just get IDssCdpManager(manager).owns(cdp))\n     * and bypass the intended security check\n    function safeLockTokenCollateral(address manager,address collateralJoin,uint cdp,uint amt,address owner) public {\n        require(IDssCdpManager(manager).owns(cdp) == owner, \"bad-owner\");\n        lockTokenCollateral(manager, collateralJoin, cdp, amt);\n    }\n\n    function freeETH(address manager, address ethJoin, uint cdp, uint wad) public {\n        // Unlocks WETH amount from the CDP\n        frob(manager, cdp, -toInt(wad), 0);\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n    **/\n\n    function freeTokenCollateral(address manager, ICollateralJoin collateralJoin, uint cdp, uint amt) external {\n        uint wad = convertTo18(collateralJoin, amt);\n        // Unlocks token amount from the CDP\n        modifySAFECollateralization(manager, cdp, -toInt(wad), 0);\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wad);\n        // Exits token amount to the user's wallet as a token\n        collateralJoin.exit(msg.sender, amt);\n    }\n    \n    /**\n    function exitETH(address manager, address ethJoin, uint cdp, uint wad) public {\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad);\n\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n    **/\n\n    function exitTokenCollateral(address manager, ICollateralJoin collateralJoin, uint cdp, uint amt) external {\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), convertTo18(collateralJoin, amt));\n\n        // Exits token amount to the user's wallet as a token\n        collateralJoin.exit(msg.sender, amt);\n    }\n\n    function generateDebt(\n        address manager, address taxCollector, address coinJoin, uint cdp, uint wad, uint256 lockupPeriod\n    ) external {\n        address safe = IDssCdpManager(manager).safes(cdp);\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n        bytes32 collateralType = IDssCdpManager(manager).collateralTypes(cdp);\n        // Generates debt in the CDP\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            0,\n            _getGeneratedDeltaDebt(safeEngine, taxCollector, safe, collateralType, wad)\n        );\n        // Moves the StablePro amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, cdp, address(this), toRad(wad));\n        // Allows adapter to access to proxy's StablePro balance in the safeEngine\n        if (safeEngine.cdpRights(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // Exits StablePro to the user's wallet as a token\n        ICoinJoin(coinJoin).exit(collateralType, msg.sender, lockupPeriod, msg.sender, wad);\n    }\n\n    function repayDebt(address manager, address coinJoin, uint cdp, uint wad) external {\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n        address safe = IDssCdpManager(manager).safes(cdp);\n        bytes32 collateralType = IDssCdpManager(manager).collateralTypes(cdp);\n\n        address own = IDssCdpManager(manager).owns(cdp);\n        if (own == address(this) || IDssCdpManager(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins StablePro amount into the safeEngine\n            _coinJoin_join(collateralType, coinJoin, safe, wad);\n            // Paybacks debt to the CDP\n            modifySAFECollateralization(\n                manager,\n                cdp,\n                0,\n                _getRepaidDeltaDebt(safeEngine, safeEngine.coinBalance(safe), safe, collateralType)\n            );\n        } else {\n            // Joins StablePro amount into the safeEngine\n            _coinJoin_join(collateralType, coinJoin, address(this), wad);\n            // Paybacks debt to the CDP\n            safeEngine.modifySAFECollateralization(\n                collateralType,\n                safe,\n                address(this),\n                address(this),\n                0,\n                _getRepaidDeltaDebt(safeEngine, wad * RAY, safe, collateralType)\n            );\n        }\n    }\n    \n    /**\n    * Same as in safeLockTokenCollateral\n    function safeRepayDebt(address manager, address daiJoin, uint cdp, uint wad, address owner) public {\n        require(IDssCdpManager(manager).owns(cdp) == owner, \"bad-owner\");\n        repayDebt(manager, daiJoin, cdp, wad);\n    }\n    **/\n\n    function repayAllDebt(address manager, address coinJoin, uint cdp) external {\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n        address safe = IDssCdpManager(manager).safes(cdp);\n        bytes32 collateralType = IDssCdpManager(manager).collateralTypes(cdp);\n        (, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        address own = IDssCdpManager(manager).owns(cdp);\n        if (own == address(this) || IDssCdpManager(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins StablePro amount into the safeEngine\n            _coinJoin_join(collateralType, coinJoin, safe, _getRepaidAllWad(safeEngine, safe, safe, collateralType));\n            // Paybacks debt to the CDP\n            modifySAFECollateralization(manager, cdp, 0, -int(safeDebt));\n        } else {\n            // Joins StablePro amount into the safeEngine\n            _coinJoin_join(\n                collateralType,\n                coinJoin,\n                address(this),\n                _getRepaidAllWad(safeEngine, address(this), safe, collateralType)\n            );\n            // Paybacks debt to the CDP\n            safeEngine.modifySAFECollateralization(\n                collateralType,\n                safe,\n                address(this),\n                address(this),\n                0,\n                -int(safeDebt)\n            );\n        }\n    }\n\n    /**\n    * Same as in safeLockTokenCollateral\n    function safeRepayAllDebt(address manager, address daiJoin, uint cdp, address owner) public {\n        require(IDssCdpManager(manager).owns(cdp) == owner, \"bad-owner\");\n        repayAllDebt(manager, daiJoin, cdp);\n    }\n\n    function lockETHAndDraw(\n        address manager, address jug, address ethJoin, address daiJoin, uint cdp, uint wadD\n    ) public payable {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, urn);\n        // Locks WETH amount into the CDP and generates debt\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }\n\n    function openLockETHAndDraw(\n        address manager, address jug, address ethJoin, address daiJoin, bytes32 ilk, uint wadD\n    ) public payable returns (uint cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\n    }\n    **/\n\n    function lockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        ICollateralJoin collateralJoin,\n        address coinJoin,\n        uint cdp,\n        uint collateralAmount,\n        uint deltaWad,\n        uint256 lockupPeriod\n    ) public {\n        address safeHandler = IDssCdpManager(manager).safes(cdp);\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n        bytes32 collateralType = IDssCdpManager(manager).collateralTypes(cdp);\n        // Takes token amount from user's wallet and joins into the safeEngine\n        _collateralJoin_join(collateralJoin, safeHandler, collateralAmount);\n        // Locks token amount into the SAFE and generates debt\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            toInt(convertTo18(collateralJoin, collateralAmount)),\n            _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, deltaWad)\n        );\n        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, cdp, address(this), toRad(deltaWad));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (safeEngine.cdpRights(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // Exits COIN to the user's wallet as a token\n        ICoinJoin(coinJoin).exit(collateralType, msg.sender, lockupPeriod, msg.sender, deltaWad);\n    }\n\n    function openLockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        ICollateralJoin collateralJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint amtC,\n        uint wadD,\n        uint256 lockupPeriod\n    ) external returns (uint cdp) {\n        cdp = openSafe(manager, collateralType, address(this));\n        lockTokenCollateralAndGenerateDebt(\n            manager, taxCollector, collateralJoin, coinJoin, cdp, amtC, wadD, lockupPeriod\n        );\n    }\n\n    /**\n     * We don't use GNT and ETH\n    function openLockGNTAndDraw(\n        address manager,naddress jug, address gntJoin, address daiJoin, bytes32 ilk, uint wadC, uint wadD\n    ) public returns (address bag, uint cdp) {\n        // Creates bag (if doesn't exist) to hold GNT\n        bag = GNTJoinLike(gntJoin).bags(address(this));\n        if (bag == address(0)) {\n            bag = makeGemBag(gntJoin);\n        }\n        // Transfer funds to the funds which previously were sent to the proxy\n        GemLike(GemJoinLike(gntJoin).gem()).transfer(bag, wadC);\n        cdp = openLockGemAndDraw(manager, jug, gntJoin, daiJoin, ilk, wadC, wadD, false);\n    }\n\n    function wipeAndFreeETH(address manager, address ethJoin, address daiJoin, uint cdp, uint wadC, uint wadD) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, wadD);\n        // Paybacks debt to the CDP and unlocks WETH amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wadC),\n            _getWipeDart(ManagerLike(manager).vat(), VatLike(ManagerLike(manager).vat()).dai(urn), urn, ManagerLike(manager).ilks(cdp))\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wadC);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n    }\n\n    function wipeAllAndFreeETH(address manager, address ethJoin, address daiJoin, uint cdp, uint wadC) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n        // Paybacks debt to the CDP and unlocks WETH amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wadC),\n            -int(art)\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wadC);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n    }\n    **/\n\n    function repayDebtAndFreeTokenCollateral(\n        address manager,\n        ICollateralJoin collateralJoin,\n        address coinJoin,\n        uint cdp,\n        uint amtC,\n        uint wadD\n    ) external {\n        address safe = IDssCdpManager(manager).safes(cdp);\n        bytes32 collateralType = IDssCdpManager(manager).collateralTypes(cdp);\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n        // Joins StablePro amount into the safeEngine\n        _coinJoin_join(collateralType, coinJoin, safe, wadD);\n        uint wadC = convertTo18(collateralJoin, amtC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            -toInt(wadC),\n            _getRepaidDeltaDebt(\n                safeEngine,\n                safeEngine.coinBalance(safe),\n                safe,\n                collateralType\n            )\n        );\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wadC);\n        // Exits token amount to the user's wallet as a token\n        collateralJoin.exit(msg.sender, amtC);\n    }\n\n    function repayAllDebtAndFreeTokenCollateral(\n        address manager,\n        ICollateralJoin collateralJoin,\n        address coinJoin,\n        uint cdp,\n        uint amtC\n    ) external {\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n        address safe = IDssCdpManager(manager).safes(cdp);\n        bytes32 collateralType = IDssCdpManager(manager).collateralTypes(cdp);\n        (, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        // Joins StablePro amount into the safeEngine\n        _coinJoin_join(collateralType, coinJoin, safe, _getRepaidAllWad(safeEngine, safe, safe, collateralType));\n        uint wadC = convertTo18(collateralJoin, amtC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            cdp,\n            -toInt(wadC),\n            -int(safeDebt)\n        );\n        // Moves the amount from the CDP safe to proxy's address\n        transferCollateral(manager, cdp, address(this), wadC);\n        // Exits token amount to the user's wallet as a token\n        collateralJoin.exit(msg.sender, amtC);\n    }\n\n    // Public view functions. There is no such functions in original MakerDAO version.\n\n    // @notice Returns cdpId of users cdp that is stored in DssCdpManager.\n    // TODO: We need to optimize it.\n    function getCdpId(address manager, address user, bytes32 collateralType) public view returns(uint) {\n        uint256 cdpCount = IDssCdpManager(manager).cdpCount(user);\n        uint256 cdpId = IDssCdpManager(manager).firstCdpId(user);\n        IDssCdpManager managerContract = IDssCdpManager(manager);\n\n        for (uint256 i; i < cdpCount; ++i) {\n            if (managerContract.collateralTypes(cdpId) == collateralType) {\n                return cdpId;\n            }\n            (, uint256 nextCdpId) = managerContract.list(cdpId);\n            cdpId = nextCdpId;\n        }\n\n        return type(uint256).max;\n    }\n\n    // @notice UI function to get cdp info of user.\n    function getCdpInfo(address manager, address user, bytes32 collateralType) public view returns(uint, uint) {\n        uint256 cdpId = getCdpId(manager, user, collateralType);\n        if (cdpId == type(uint256).max) return (0,0);\n\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n        address safe = IDssCdpManager(manager).safes(cdpId);\n        return safeEngine.safes(collateralType, safe);\n    }\n\n    // @notice UI function that returns how much user is available to withdraw collateral.\n    function getAvailableToWithdraw(address manager, address user, bytes32 collateralType) external view returns(uint) {\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n\n        (uint256 lockedCollateral, uint256 generatedDebt) = getCdpInfo(manager, user, collateralType);\n        (, uint rate,,, uint safetyPrice,,,) = safeEngine.collateralTypes(collateralType);\n\n        // If safetyPrice is not set, then answer is 0\n        if (safetyPrice == 0) return 0;\n\n        // 1e18 * 1e27 / 1e27 = 1e18\n        uint256 minCollateralAmount = mul(generatedDebt, rate) / safetyPrice; // result in base of 1e27\n        return lockedCollateral > minCollateralAmount ? sub(lockedCollateral, minCollateralAmount) : 0;\n    }\n\n    // @notice UI function that returns how much user is available to borrow stablePro using collateral.\n    function getAvailableToBorrow(address manager, address user, bytes32 collateralType) external view returns(uint) {\n        ISafeEngine safeEngine = IDssCdpManager(manager).safeEngine();\n\n        (uint256 lockedCollateral, uint256 generatedDebt) = getCdpInfo(manager, user, collateralType);\n        (\n            uint256 debtAmount, uint256 rate, uint256 debtCeiling,, uint safetyPrice,,,\n        ) = safeEngine.collateralTypes(collateralType);\n\n        uint256 usdLimitE18 = mul(lockedCollateral, safetyPrice) / rate; // 1e18 * 1e27 / 1e27 = 1e18\n        if (usdLimitE18 > generatedDebt) {\n            uint256 availableToBorrow = sub(usdLimitE18, generatedDebt); // 1e18\n\n            uint256 globalAvailableToBorrow = sub(safeEngine.globalDebtCeiling(), safeEngine.globalDebt()); // 1e45\n            if (globalAvailableToBorrow < toRad(availableToBorrow)) return globalAvailableToBorrow  / RAY;\n\n            uint256 collateralAvailableToBorrow = sub(debtCeiling, toRad(debtAmount)); // 1e45\n            if (collateralAvailableToBorrow < toRad(add(debtAmount, availableToBorrow))) {\n                return collateralAvailableToBorrow / RAY;\n            }\n\n            return availableToBorrow;\n        }\n\n        return 0;\n    }\n}\n\n// We also don't need DssProxyActionsEnd and DssProxyActionsDsr contracts\n"
    },
    "contracts/makerdao/interfaces/ICoin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICoin is IERC20 {\n    function mint(address account, uint256 amount) external;\n    function burn(address account, uint256 amount) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ICoinJoin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport {IDisable} from \"./IDisable.sol\";\nimport {ICoin} from \"./ICoin.sol\";\n\n/**\n * @title ITaxCollector\n **/\ninterface ICoinJoin is IDisable {\n    /* ==================== EVENTS ==================== */\n    event Join(address indexed usr, uint256 wad);\n    event JoinNoReward(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n    event ExitNoReward(address indexed usr, uint256 wad);\n    event UpdateRewardChef();\n    event DecreaseAmountFailed(address indexed collateralType, address indexed user, uint amount);\n    event IncreaseAmountFailed(\n        address indexed collateralType,\n        address indexed user,\n        uint amount,\n        uint256 lockupPeriodSeconds\n    );\n\n    /* ===================== ERRORS ==================== */\n    error BadLockupPeriod();\n\n    /* ====================== VARS ===================== */\n    function systemCoin() external returns (ICoin);\n\n    /* ==================== METHODS ==================== */\n\n    /**\n    * @notice Join pegged-coins in the system\n    * @dev Exited coins have 18 decimals but inside the system they have 45 (rad) decimals.\n           When we join, the amount (wad) is multiplied by 10**27 (ray).\n           Can only be called by authorized contracts.\n    * @param collateralType Collateral that will be used for borrow\n    * @param user Account that call borrow/repay function and will receive rewards in RewardChef\n    * @param cdp Account that will receive the joined coins\n    * @param wad Amount of external coins to join (18 decimal number)\n    **/\n    function join(bytes32 collateralType, address user, address cdp, uint wad) external;\n\n    /**\n    * @notice Simple version of join(). Don't have Rewards, it is useful for our smart-contracts.\n    * @param cdp Account that will receive the joined coins\n    * @param wad Amount of external coins to join (18 decimal number)\n    **/\n    function joinNoReward(address cdp, uint wad) external;\n\n    /**\n    * @notice Exit pegged-coins from the system and inside 'Coin.sol'\n    * @dev Inside the system, coins have 45 (rad) decimals but outside they have 18 decimals (wad).\n           When we exit, we specify a wad amount of coins and then the contract automatically multiplies\n           wad by 10**27 to move the correct 45 decimal coin amount to this adapter.\n           Can only be called by authorized contracts.\n    * @param collateralType Collateral that will be used for repay\n    * @param user Account that call borrow/repay function and will receive rewards in RewardChef\n    * @param lockupPeriodSeconds Lockup period for rewardChef that calculate user rewards\n    * @param cdp Account that will receive the exited coins\n    * @param wad Amount of internal coins to join (18 decimal number that will be multiplied by ray)\n    **/\n    function exit(bytes32 collateralType, address user, uint256 lockupPeriodSeconds, address cdp, uint wad) external;\n\n    /**\n    * @notice Simple version of exit(). Don't have Rewards, it is useful for our smart-contracts.\n    * @param cdp Account that will receive the joined coins\n    * @param wad Amount of external coins to join (18 decimal number)\n    **/\n    function exitNoReward(address cdp, uint wad) external;\n\n    /**\n    * @notice We use rewardChef to increaseAmount/decreaseAmount during join and exit,\n    * so admin should be able to change RewardChef contract's address.\n    * @param rewardChef New address of RewardChef contract.\n    **/\n    function updateRewardChef(address rewardChef) external;\n\n    /**\n    * @notice We need to save mapping of collateralType => collateralAddress to work with RewardChef.\n    * @param _collateralType Collateral type as bytes32, that we use in our protocol.\n    * @param _collateralAddress Address of collateral\n    **/\n    function initializeCollateralType(bytes32 _collateralType, address _collateralAddress) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ICollateralJoin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IDisable} from \"./IDisable.sol\";\n\n/**\n * @title ITaxCollector\n **/\ninterface ICollateralJoin is IDisable {\n\n    /* ===================== EVENTS ===================== */\n\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n\n    /* ====================== VARS ===================== */\n    function decimals() external returns (uint);\n    function collateral() external view returns(IERC20Metadata);\n\n    /* ==================== METHODS ==================== */\n\n    /**\n    * @notice Join collateral in the system\n    * @param usr Account from which we transferFrom collateral and add it in the system\n    * @param wad Amount of collateral to transfer in the system (represented as a number with 18 decimals)\n    **/\n    function join(address usr, uint wad) external;\n\n    /**\n    * @notice Exit collateral from the system\n    * @param usr Account to which we transfer the collateral\n    * @param wad Amount of collateral to transfer to 'account' (represented as a number with 18 decimals)\n    **/\n    function exit(address usr, uint wad) external;\n}\n"
    },
    "contracts/makerdao/interfaces/IDisable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface IDisable {\n    event DisableContract();\n\n    function disableContract() external;\n}\n"
    },
    "contracts/makerdao/interfaces/IDssCdpManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISafeEngine.sol\";\n\n/**\n * @title IDssMiddleware\n **/\ninterface IDssCdpManager {\n\n    /* ==================== STRUCTS ==================== */\n\n    struct List {\n        uint prev;\n        uint next;\n    }\n\n    /* ==================== EVENTS ===================== */\n\n    event NewCdp(address indexed usr, address indexed own, uint indexed cdp);\n\n\n    /* ===================== VARS ====================== */\n\n    // @notice CDPId => CollateralType\n    function collateralTypes(uint cdp) external view returns (bytes32);\n    // @notice CDPId => CdpHandler\n    function safes(uint cdp) external view returns (address);\n    // @notice Address of safeEngine\n    function safeEngine() external view returns (ISafeEngine);\n    // @notice CDPId => Owner\n    function owns(uint cdp) external view returns (address);\n    // @notice Owner => CDPId => Allowed Addr => True/False\n    function cdpCan(address owner, uint cdp, address allowedAddress) external view returns (uint);\n    // @notice Owner => Amount of CDPs\n    function cdpCount(address owner) external view returns (uint);\n    // @notice Owner => First CDPId\n    function firstCdpId(address owner) external view returns (uint);\n    // @notice Owner => Last CDPId\n    function lastCdpId(address owner) external view returns (uint);\n    // @notice CDPId => Prev & Next CDPIds (double linked list)\n    function list(uint cdp) external view returns (uint prev, uint next);\n\n    /* ==================== METHODS ==================== */\n\n    // @notice Allow/disallow a usr address to manage the cdp.\n    function cdpAllow(uint cdp, address usr, uint ok) external;\n\n    // @notice Allow/disallow a usr address to quit to the the sender urn.\n    function allowHandler(address usr, uint ok) external;\n\n    // @notice Open a new cdp for a given usr address.\n    function openSafe(bytes32 collateralType, address usr) external returns (uint);\n\n    // @notice Give the cdp ownership to a dst address.\n    function transferSafeOwnership(uint cdp, address dst) external;\n\n    // @notice Modify the cdp keeping the generated StablePro or collateral freed in the cdp urn address.\n    function modifySAFECollateralization(uint cdp, int deltaCollateral, int deltaDebt) external;\n\n    // @notice Transfer wad amount of cdp collateral from the cdp address to a dst address.\n    function transferCollateral(uint cdp, address dst, uint wad) external;\n\n    // @notice Transfer wad amount of any type of collateral (ilk) from the cdp address to a dst address.\n    // This function has the purpose to take away collateral from the system that doesn't correspond to the cdp\n    // but was sent there wrongly.\n    function transferCollateral(bytes32 ilk, uint cdp, address dst, uint wad) external;\n\n    // @notice Transfer wad amount of StablePro from the cdp address to a dst address.\n    function transferInternalCoins(uint cdp, address dst, uint rad) external;\n\n    // @notice Quit the system, migrating the cdp (lockedCollateral, generatedDebt) to a different dst urn\n    function quit(uint cdp, address dst) external;\n\n    // @notice Import a position from src urn to the urn owned by cdp\n    function enter(address src, uint cdp) external;\n\n    // @notice Move a position from cdpSrc urn to the cdpDst urn\n    function moveSAFE(uint cdpSrc, uint cdpDst) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ISafeEngine.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// TODO: check how to operate with license and use one for all contracts\n\npragma solidity ^0.8.0;\n\nimport \"./IDisable.sol\";\n\n/**\n * @title SafeEngine\n * @notice The single source of truth for the Maker Protocol. It contains the accounting system of the core Vault,\n * Internal StablePro balances, and collateral state. It houses the public interface for Vault management,\n * allowing safe(= CDP or Vault) owners to adjust their Vault state balances. It also contains the public interface\n * for Vault fungibility, allowing safe (Vault) owners to transfer, split, and merge Vaults.\n * Excluding these interfaces, SAFEEngine is accessed through trusted smart contract modules.\n **/\ninterface ISafeEngine is IDisable {\n    /* ==================== METHODS ==================== */\n\n    // --- Data ---\n    struct CollateralType {\n        uint256 debtAmount;        // Total debt issued for this specific collateral type                          [wad]\n        uint256 accumulatedRate;   // Accumulator for interest accrued on this collateral type                     [ray]\n        uint256 debtCeiling;       // Maximum amount of debt that can be generated with this collateral type       [rad]\n        uint256 debtFloor;         // Minimum amount of debt that must be generated by a CDP using this collateral [rad]\n        uint256 safetyPrice;       // Floor price at which a CDP is allowed to generate debt                       [ray]\n        uint256 liquidationRatio;  // Liquidation ratio to calculate safety price                                  [ray]\n        address collateralAddress; // Address of collateral\n        uint256 safetyPriceBlockNumber; // Block when safetyPrice was updated\n    }\n    struct SAFE {\n        uint256 lockedCollateral; // Total amount of collateral locked in a SAFE/CDP  [wad]\n        uint256 generatedDebt;    // Total amount of debt generated by a SAFE/CDP     [wad]\n    }\n\n    // --- VARS ---\n\n    function safes(bytes32, address) external view returns (uint, uint);\n\n    function collateralTypes(bytes32) external view returns (\n        uint256 debtAmount,       // [wad]\n        uint256 accumulatedRate,  // [ray]\n        uint256 debtCeiling,      // [rad]\n        uint256 debtFloor,        // [rad]\n        uint256 safetyPrice,      // [ray]\n        uint256 liquidationRatio, // [ray]\n        address collateralAddress,\n        uint256 safetyPriceBlockNumber\n);\n\n    function tokenCollateral(bytes32, address) external view returns (uint256);\n\n    function coinBalance(address) external view returns (uint256);\n\n    function debtBalance(address) external view returns (uint256);\n\n    function cdpRights(address, address) external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function globalDebt() external view returns (uint256);\n\n    // --- Auth ---\n    /**\n     * @notice Allow an address to modify your CDP.\n     * For example coinAdapter should be able to modify your CDP to withdraw all correctly.\n     * @param usr Account to give CDP permissions to\n     */\n    function approveSAFEModification(address usr) external;\n\n    /**\n     * @notice Deny an address the rights to modify your CDP\n     * @param usr Account to give CDP permissions to\n     */\n    function denySAFEModification(address usr) external;\n\n    // --- Administration ---\n\n    function initializeCollateralType(bytes32 collateralType, address collateralAddress) external;\n\n    /**\n     * @notice Method to modify some global variables\n     * @param what - name of variable we want to change\n     * @param data - new value of this variable\n     */\n    function modifyParameters(bytes32 what, uint data) external;\n    /**\n     * @notice Method to modify values in struct of collateralTypes\n     * @param collateralType - collateral type we want to modify (collateralTypes[collateralType])\n     * @param what - name of variable in struct we want to change\n     * @param data - new value of this variable\n     */\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n\n    // --- Fungibility ---\n    function modifyCollateralBalance(bytes32 collateralType, address usr, int256 wad) external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) external;\n    function transferInternalCoins(address src, address dst, uint256 rad) external;\n\n    // --- SafetyPrice Manipulation ---\n    /**\n     * @notice Method to update safetyPrice, it's called each time, when function need actual safetyPrice\n     * @param collateralType - safetyPrice's collateral type we want to update\n     */\n    function updateSafetyPrice(bytes32 collateralType) external;\n\n    // --- CDP Manipulation ---\n    /**\n     * @notice Add/remove collateral or put back/generate more debt in a CDP\n     * @param collateralType Type of collateral to withdraw/deposit in and from the CDP\n     * @param cdp Target CDP\n     * @param collateralSource Account we take collateral from/put collateral into\n     * @param debtDestination Account from which we credit/debit coins and debt\n     * @param deltaCollateral Amount of collateral added/extract from the CDP\n     * @param deltaDebt Amount of debt to generate/repay\n     */\n    function modifySAFECollateralization(\n        bytes32 collateralType,\n        address cdp,\n        address collateralSource,\n        address debtDestination,\n        int deltaCollateral,\n        int deltaDebt\n    ) external;\n\n    // --- CDP Fungibility ---\n    /**\n     * @notice Transfer collateral and/or debt between CDPs\n     * @param collateralType Collateral type transferred between CDPs\n     * @param src Source CDP\n     * @param dst Destination CDP\n     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst\n     * @param deltaDebt Amount of debt to take/add into src and give/take from dst\n     */\n    function transferSAFECollateralAndDebt(\n        bytes32 collateralType,\n        address src,\n        address dst,\n        int deltaCollateral,\n        int deltaDebt\n    ) external;\n\n    // --- CDP Confiscation ---\n    /**\n     * @notice Normally used by the LiquidationEngine in order to confiscate collateral and\n       debt from a CDP and give them to someone else\n     * @param collateralType Collateral type the CDP has locked inside\n     * @param cdp Target CDP\n     * @param collateralCounterparty Who we take/give collateral to\n     * @param debtCounterparty Who we take/give debt to\n     * @param deltaCollateral Amount of collateral taken/added into the CDP\n     * @param deltaDebt Amount of debt taken/added into the CDP\n     */\n    function confiscateSAFECollateralAndDebt(\n        bytes32 collateralType,\n        address cdp,\n        address collateralCounterparty,\n        address debtCounterparty,\n        int deltaCollateral,\n        int deltaDebt\n    ) external;\n\n    // --- Settlement ---\n    /**\n     * @notice Nullify an amount of coins with an equal amount of debt\n     * @param rad Amount of debt & coins to destroy (expressed as a number with 45 decimals)\n     */\n    function settleDebt(uint rad) external;\n\n    /**\n     * @notice Usually called by CoinSavingsAccount in order to create unbacked debt\n     * @param debtDestination Usually AccountingEngine that can settle decreaseSoldAmount with surplus\n     * @param coinDestination Usually CoinSavingsAccount who passes the new coins to depositors\n     * @param rad Amount of debt to create (expressed as a number with 45 decimals)\n     */\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint rad) external;\n\n    // --- Rates ---\n    /**\n     * @notice Usually called by TaxCollector in order to accrue interest on a specific collateral type\n     * @param collateralType Collateral type we accrue interest for\n     * @param surplusDst Destination for amount of surplus created by applying the interest rate\n       to debt created by CDPs with 'collateralType'\n     * @param accumulatedRate Multiplier applied to the debtAmount in order to calculate the surplus\n     */\n    function updateAccumulatedRate(bytes32 collateralType, address surplusDst, int accumulatedRate) external;\n}\n"
    },
    "contracts/makerdao/interfaces/ITaxCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @title ITaxCollector\n **/\ninterface ITaxCollector {\n    /* ==================== EVENTS ==================== */\n    event DisableContract();\n\n    /* ==================== STRUCTS ==================== */\n\n    struct CollateralType {\n        uint256 stabilityFee;      // Collateral-specific, per-second stability fee contribution [ray]\n        uint256 latestUpdateTime;  // Time of last taxSingle [unix epoch time]\n    }\n\n\n    /* ==================== METHODS ==================== */\n\n    // --- Administration ---\n    function initializeCollateralType(bytes32 collateralType) external;\n    function modifyParameters(bytes32 collateralType, bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, uint data) external;\n    function modifyParameters(bytes32 what, address data) external;\n\n\n    // --- Stability Fee Collection ---\n    /**\n     * @notice Collect tax from a single collateral type\n     * @param collateralType Collateral type to tax\n     */\n    function taxSingle(bytes32 collateralType) external returns (uint rate);\n}\n"
    },
    "contracts/periphery/contracts/access-control/SuAccessControlSingleton.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/access-control/ISuAccessControl.sol\";\nimport \"./SuAccessRoles.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title SuAccessControl\n * @dev Access control for contracts. SuVaultParameters can be inherited from it.\n * see hierarchy in SuAccessRoles.sol\n */\ncontract SuAccessControlSingleton is AccessControlUpgradeable, SuAccessRoles, ISuAccessControl {\n    /**\n     * @dev Initialize the contract with initial owner to be deployer\n     */\n    function initialize(address dao) public initializer {\n        __AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(DAO_ROLE, dao);\n\n        // Now we set hierarchy - what roles can give/revoke other roles\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        // Only DAO role can set Admin and System roles\n        _setRoleAdmin(ADMIN_ROLE, DAO_ROLE);\n\n        // Only DAO role can set System roles\n        _setRoleAdmin(MINT_ACCESS_ROLE, DAO_ROLE);\n        _setRoleAdmin(LIQUIDATION_ACCESS_ROLE, DAO_ROLE);\n        _setRoleAdmin(REWARD_ACCESS_ROLE, DAO_ROLE);\n        _setRoleAdmin(DISABLER_ROLE, DAO_ROLE);\n        _setRoleAdmin(VOTING_ESCROW_ROLE, DAO_ROLE);\n        _setRoleAdmin(CDP_ACCESS_ROLE, DAO_ROLE);\n        _setRoleAdmin(PROXY_ACTIONS_ROLE, DAO_ROLE);\n\n        // Only Admin role can set Alerter role\n        _setRoleAdmin(ALERTER_ROLE, ADMIN_ROLE);\n    }\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) public onlyRole(DAO_ROLE) {\n        _setRoleAdmin(role, adminRole);\n    }\n}\n"
    },
    "contracts/periphery/contracts/access-control/SuAccessRoles.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title SuAccessRoles Library\n * @dev SuAuthenticated and SuAccessControlSingleton need to have this constants\n * Hierarchy:\n *      1. DAO - can give admins and system roles\n *      2.1. Admin - can set Alerters\n *      2.2. System - includes Minter, Liquidation, Reward and Disabler roles, don't have access to give some roles.\n *      3. Alerter - can send alerts and trigger rate limits, don't have access to give some roles.\n */\nabstract contract SuAccessRoles {\n    bytes32 public constant ADMIN_ROLE = 0x00;\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n\n    bytes32 public constant ALERTER_ROLE = keccak256(\"ALERTER_ROLE\");\n\n    // system roles\n    bytes32 public constant MINT_ACCESS_ROLE = keccak256(\"MINT_ACCESS_ROLE\");\n    bytes32 public constant LIQUIDATION_ACCESS_ROLE = keccak256(\"LIQUIDATION_ACCESS_ROLE\");\n    bytes32 public constant REWARD_ACCESS_ROLE = keccak256(\"REWARD_ACCESS_ROLE\");\n    // bytes32 public constant SYSTEM_ROLE = keccak256(\"SYSTEM_ROLE\");\n    bytes32 public constant DISABLER_ROLE = keccak256(\"DISABLER_ROLE\");\n    bytes32 public constant CDP_ACCESS_ROLE = keccak256(\"CDP_ACCESS_ROLE\");\n    bytes32 public constant VOTING_ESCROW_ROLE = keccak256(\"VOTING_ESCROW_ROLE\");\n    bytes32 public constant PROXY_ACTIONS_ROLE = keccak256(\"PROXY_ACTIONS_ROLE\");\n}\n"
    },
    "contracts/periphery/contracts/access-control/SuAuthenticated.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/access-control/ISuAccessControl.sol\";\nimport \"./SuAccessRoles.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @title SuAuthenticated\n * @dev other contracts should inherit to be authenticated.\n * The address of SuAccessControlSingleton should be one for all contract that inherits SuAuthenticated\n */\nabstract contract SuAuthenticated is Initializable, SuAccessRoles, IERC165Upgradeable {\n    ISuAccessControl public ACCESS_CONTROL_SINGLETON;\n\n    error OnlyDAOError();\n    error OnlyAdminError();\n    error OnlyAlerterError();\n    error OnlyVaultAccessError();\n    error OnlyLiquidationAccessError();\n    error OnlyMintAccessError();\n    error OnlyRewardAccessError();\n    error OnlyDisablerAccessError();\n    error OnlyVotingEscrowError();\n    error OnlyProxyActionsError();\n    error OnlyRoleError();\n    error OnlyCDPAccessError();\n    error BadAccessControlSingleton();\n\n    /**\n     * @dev should be passed in constructor\n     */\n    function __suAuthenticatedInit(address _accessControlSingleton) internal onlyInitializing {\n        ACCESS_CONTROL_SINGLETON = ISuAccessControl(_accessControlSingleton);\n        if (\n            _accessControlSingleton == address(0) ||\n            !ISuAccessControl(_accessControlSingleton).supportsInterface(type(IAccessControlUpgradeable).interfaceId)\n        ) revert BadAccessControlSingleton();\n    }\n\n    /** CORE ROLES */\n\n    modifier onlyDAO() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(DAO_ROLE, msg.sender)) revert OnlyDAOError();\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ADMIN_ROLE, msg.sender)) revert OnlyAdminError();\n        _;\n    }\n\n    modifier onlyAlerter() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ALERTER_ROLE, msg.sender)) revert OnlyAlerterError();\n        _;\n    }\n\n    /** SYSTEM ROLES */\n\n    modifier onlyLiquidationAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(LIQUIDATION_ACCESS_ROLE, msg.sender)) revert OnlyLiquidationAccessError();\n        _;\n    }\n\n    modifier onlyMintAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(MINT_ACCESS_ROLE, msg.sender)) revert OnlyMintAccessError();\n        _;\n    }\n\n    modifier onlyRewardAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(REWARD_ACCESS_ROLE, msg.sender)) revert OnlyRewardAccessError();\n        _;\n    }\n\n    modifier onlyRewardOrAdminAccess() {\n        if (\n            !ACCESS_CONTROL_SINGLETON.hasRole(REWARD_ACCESS_ROLE, msg.sender) &&\n            !ACCESS_CONTROL_SINGLETON.hasRole(ADMIN_ROLE, msg.sender)\n        ) revert OnlyRewardAccessError();\n        _;\n    }\n\n    // @notice This modifier check if user/contract have access to \"disable\" contracts.\n    // All main contracts in our lending protocol have disableContract() method that stops contracts main functions.\n    modifier onlyDisablerAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(DISABLER_ROLE, msg.sender)) revert OnlyDisablerAccessError();\n        _;\n    }\n\n    modifier onlyCDPAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(CDP_ACCESS_ROLE, msg.sender)) revert OnlyCDPAccessError();\n        _;\n    }\n\n    modifier onlyVotingEscrow() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(VOTING_ESCROW_ROLE, msg.sender)) revert OnlyVotingEscrowError();\n        _;\n    }\n\n    modifier onlyProxyActions() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(PROXY_ACTIONS_ROLE, msg.sender)) revert OnlyProxyActionsError();\n        _;\n    }\n\n    // syntax sugar under ACCESS_CONTROL_SINGLETON\n    modifier onlyRole(bytes32 role) {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(role, msg.sender)) revert OnlyRoleError();\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return ACCESS_CONTROL_SINGLETON.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/periphery/contracts/access-control/SuAuthenticatedNonUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BSL 1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/access-control/ISuAccessControl.sol\";\nimport \"./SuAccessRoles.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title SuAuthenticated\n * @dev other contracts should inherit to be authenticated.\n * The address of SuAccessControlSingleton should be one for all contract that inherits SuAuthenticated\n */\nabstract contract SuAuthenticatedNonUpgradeable is SuAccessRoles, IERC165 {\n    ISuAccessControl public ACCESS_CONTROL_SINGLETON;\n\n    error OnlyDAOError();\n    error OnlyAdminError();\n    error OnlyAlerterError();\n    error OnlyVaultAccessError();\n    error OnlyLiquidationAccessError();\n    error OnlyMintAccessError();\n    error OnlyRewardAccessError();\n    error OnlyDisablerAccessError();\n    error OnlyVotingEscrowError();\n    error OnlyProxyActionsError();\n    error OnlyRoleError();\n    error OnlyCDPAccessError();\n    error BadAccessControlSingleton();\n\n    constructor (address _accessControlSingleton) internal {\n        ACCESS_CONTROL_SINGLETON = ISuAccessControl(_accessControlSingleton);\n        if (\n            _accessControlSingleton == address(0) ||\n            !ISuAccessControl(_accessControlSingleton).supportsInterface(type(IAccessControlUpgradeable).interfaceId)\n        ) revert BadAccessControlSingleton();\n    }\n\n    /** CORE ROLES */\n\n    modifier onlyDAO() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(DAO_ROLE, msg.sender)) revert OnlyDAOError();\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ADMIN_ROLE, msg.sender)) revert OnlyAdminError();\n        _;\n    }\n\n    modifier onlyAlerter() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(ALERTER_ROLE, msg.sender)) revert OnlyAlerterError();\n        _;\n    }\n\n    /** SYSTEM ROLES */\n\n    modifier onlyLiquidationAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(LIQUIDATION_ACCESS_ROLE, msg.sender)) revert OnlyLiquidationAccessError();\n        _;\n    }\n\n    modifier onlyMintAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(MINT_ACCESS_ROLE, msg.sender)) revert OnlyMintAccessError();\n        _;\n    }\n\n    modifier onlyRewardAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(REWARD_ACCESS_ROLE, msg.sender)) revert OnlyRewardAccessError();\n        _;\n    }\n\n    modifier onlyRewardOrAdminAccess() {\n        if (\n            !ACCESS_CONTROL_SINGLETON.hasRole(REWARD_ACCESS_ROLE, msg.sender) &&\n        !ACCESS_CONTROL_SINGLETON.hasRole(ADMIN_ROLE, msg.sender)\n        ) revert OnlyRewardAccessError();\n        _;\n    }\n\n    // @notice This modifier check if user/contract have access to \"disable\" contracts.\n    // All main contracts in our lending protocol have disableContract() method that stops contracts main functions.\n    modifier onlyDisablerAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(DISABLER_ROLE, msg.sender)) revert OnlyDisablerAccessError();\n        _;\n    }\n\n    modifier onlyCDPAccess() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(CDP_ACCESS_ROLE, msg.sender)) revert OnlyCDPAccessError();\n        _;\n    }\n\n    modifier onlyVotingEscrow() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(VOTING_ESCROW_ROLE, msg.sender)) revert OnlyVotingEscrowError();\n        _;\n    }\n\n    modifier onlyProxyActions() {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(PROXY_ACTIONS_ROLE, msg.sender)) revert OnlyProxyActionsError();\n        _;\n    }\n\n    // syntax sugar under ACCESS_CONTROL_SINGLETON\n    modifier onlyRole(bytes32 role) {\n        if (!ACCESS_CONTROL_SINGLETON.hasRole(role, msg.sender)) revert OnlyRoleError();\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return ACCESS_CONTROL_SINGLETON.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/periphery/contracts/interfaces/access-control/ISuAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"../../access-control/SuAccessRoles.sol\";\n\n/**\n * @notice Access control for contracts\n * @dev External interface of AccessControl declared to support ERC165 detection.\n **/\ninterface ISuAccessControl is IAccessControlUpgradeable, IERC165Upgradeable {\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n}\n"
    },
    "contracts/periphery/contracts/interfaces/oracle/ISuChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport \"./ISuOracle.sol\";\n\ninterface ISuChainlinkOracle is ISuOracle {\n    /* ===================== ERRORS ===================== */\n    error BadPriceAnswer(); // In case if the answer from feed is <= 0\n    error BadFeed(); // In case if we the feed for asset is not specified\n    error BadETHPrice(); // In case if there is no price for ETH or it's 0\n    error BadDecimals(); // In case if price decimals is >77 that overflow uint for 10^78\n    error StalePrice(); // If price from feed is not actual\n\n    /* ===================== EVENTS ===================== */\n    event AssetFeedUpdated(address indexed asset, address indexed feed, uint8 decimals);\n    event PriceBaseUpdated(address indexed asset, bool isPriceInETH);\n\n    /* ====================== VARS ====================== */\n    /**\n     * @notice Data feeds addresses from https://docs.chain.link/docs/ethereum-addresses/#Goerli%20Testnet\n     * each chainlink data feed has own decimals, see the link above\n     **/\n    function assetToFeed (address asset) external view returns ( address );\n    function assetToFeedDecimals (address asset) external view returns ( uint8 );\n\n    /* ==================== METHODS ==================== */\n    /**\n     * @notice Add ChainLink data for asset\n     * @param asset Address of asset\n     * @param chainlinkDataFeed Address of asset feed to receive latestRoundData() in getFiatPrice\n     * @param chainlinkDataFeedDecimals Decimals in ChainLink answer of feed\n     **/\n    function setAssetFeed(address asset, address chainlinkDataFeed, uint8 chainlinkDataFeedDecimals) external;\n\n    /**\n     * @notice Set if the price for `asset` is in ETH or not (in USDT otherwise)\n     * @param asset Address of asset\n     * @param isPriceInETH Boolean, true if the price of `asset` is in ETH, false if is in USDT\n     **/\n    function setPriceBase(address asset, bool isPriceInETH) external;\n}\n"
    },
    "contracts/periphery/contracts/interfaces/oracle/ISuOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// solhint-disable compiler-version\npragma solidity >=0.7.6;\n\ninterface ISuOracle {\n    /**\n     * @notice WARNING! Read this description very carefully!\n     *     function getFiatPrice1e18(address asset) returns (uint256) that:\n     *         basicAmountOfAsset * getFiatPrice1e18(asset) / 1e18 === $$ * 1e18\n     *     in other words, it doesn't matter what's the erc20.decimals is,\n     *     you just multiply token balance in basic units on value from oracle and get dollar amount multiplied on 1e18.\n     *\n     * different assets have different deviation threshold (errors)\n     *     for wBTC it's <= 0.5%, read more https://data.chain.link/ethereum/mainnet/crypto-usd/btc-usd\n     *     for other asset is can be larger based on particular oracle implementation.\n     *\n     * examples:\n     *     market price of btc = $30k,\n     *     for 0.1 wBTC the unit256 amount is 0.1 * 1e18\n     *     0.1 * 1e18 * (price1e18 / 1e18) == $3000 == uint256(3000*1e18)\n     *     => price1e18 = 30000 * 1e18;\n     *\n     *     market price of usdt = $0.97,\n     *     for 1 usdt uint256 = 1 * 1e6\n     *     so 1*1e6 * price1e18 / 1e18 == $0.97 == uint256(0.97*1e18)\n     *     => 1*1e6 * (price1e18 / 1e18) / (0.97*1e18)   = 1\n     *     =>  price1e18 = 0.97 * (1e18/1e6) * 1e18\n     *\n     *    assume market price of wBTC = $31,503.77, oracle error = $158\n     *\n     *     case #1: small amount of wBTC\n     *         we have 0.0,000,001 wBTC that is worth v = $0.00315 ± $0.00001 = 0.00315*1e18 = 315*1e13 ± 1*1e13\n     *         actual balance on the asset b = wBTC.balanceOf() =  0.0000001*1e18 = 1e11\n     *         oracle should return or = oracle.getFiatPrice1e18(wBTC) <=>\n     *         <=> b*or = v => v/b = 315*1e13 / 1e11 = 315*1e2 ± 1e2\n     *         error = or.error * b = 1e2 * 1e11 = 1e13 => 1e13/1e18 usd = 1e-5 = 0.00001 usd\n     *\n     *     case #2: large amount of wBTC\n     *         v = 2,000,000 wBTC = $31,503.77 * 2m ± 158*2m = $63,007,540,000 ± $316,000,000 = 63,007*1e24 ± 316*1e24\n     *         for calc convenience we increase error on 0.05 and have v = 63,000*24 ± 300*1e24 = (630 ± 3)*1e26\n     *         b = 2*1e6 * 1e18 = 2*1e24\n     *         or = v/b = (630 ± 3)*1e26 / 2*1e24 = 315*1e2 ± 1.5*1e2\n     *         error = or.error * b = 1.5*100 * 2*1e24 = 3*1e26 = 3*1e8*1e18 = $300,000,000 ~ $316,000,000\n     *\n     *     assume the market price of USDT = $0.97 ± $0.00485,\n     *\n     *     case #3: little amount of USDT\n     *         v = USDT amount 0.005 = 0.005*(0.97 ± 0.00485) = 0.00485*1e18 ± 0.00002425*1e18 = 485*1e13 ± 3*1e13\n     *         we rounded error up on (3000-2425)/2425 ~= +24% for calculation convenience.\n     *         b = USDT.balanceOf() = 0.005*1e6 = 5*1e3\n     *         b*or = v => or = v/b = (485*1e13 ± 3*1e13) / 5*1e3 = 970*1e9 ± 6*1e9\n     *         error = 6*1e9 * 5*1e3 / 1e18 = 30*1e12/1e18 = 3*1e-5 = $0,00005\n     *\n     *     case #4: lot of USDT\n     *         v = we have 100,000,000,000 USDT = $97B = 97*1e9*1e18 ± 0.5*1e9*1e18\n     *         b = USDT.balanceOf() = 1e11*1e6 = 1e17\n     *         or = v/b = (97*1e9*1e18 ± 0.5*1e9*1e18) / 1e17 = 970*1e9 ± 5*1e9\n     *         error = 5*1e9 * 1e17 = 5*1e26 = 0.5 * 1e8*1e18\n     *\n     * @param asset - address of erc20 token contract\n     * @return usdPrice1e18 such that asset.balanceOf() * getFiatPrice1e18(asset) / 1e18 == $$ * 1e18\n     **/\n    function getFiatPrice1e18(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/periphery/contracts/mocks/MockAuth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../access-control/SuAuthenticated.sol\";\n\n/**\n * @notice This Mock contract is to test some SuAuthenticated features.\n * For that we need some method with onlyRole modifier.\n * We have internal variable `a` that can be changed only by user with `SOME_NEW_ROLE` role.\n**/\ncontract MockAuth is SuAuthenticated {\n    uint256 internal a;\n    bytes32 public SOME_NEW_ROLE;\n\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n        a = 0;\n        SOME_NEW_ROLE = keccak256(\"SOME_NEW_ROLE\");\n    }\n\n    function changeA(uint256 _newValue) public onlyRole(SOME_NEW_ROLE) {\n        a = _newValue;\n    }\n\n    function getA() public view returns(uint256) {\n        return a;\n    }\n\n    function funcForDao() external onlyDAO {}\n    function funcForAdmin() external onlyAdmin {}\n    function funcForAlerter() external onlyAlerter {}\n    function funcForLiquidation() external onlyLiquidationAccess {}\n    function funcForMint() external onlyMintAccess {}\n    function funcForReward() external onlyRewardAccess {}\n    function funcForRewardOrAdmin() external onlyRewardOrAdminAccess {}\n    function funcForDisabler() external onlyDisablerAccess {}\n    function funcForVotingEscrow() external onlyVotingEscrow {}\n    function funcForProxyActions() external onlyProxyActions {}\n    function funcForCDPAccess() external onlyCDPAccess {}\n}\n"
    },
    "contracts/periphery/contracts/oracle/SuChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/oracle/ISuChainlinkOracle.sol\";\nimport \"../access-control/SuAuthenticated.sol\";\n\n/**\n * @title SuChainlinkOracle\n * @notice Oracle that use Chainlink prices\n * @dev See ISuChainlinkOracle interface for full details.\n */\ncontract SuChainlinkOracle is ISuChainlinkOracle, SuAuthenticated {\n    mapping (address => address) public assetToFeed;\n    mapping (address => uint8) public assetToFeedDecimals;\n    mapping (address => bool) public isPriceInETH; // We need to know is the feed price in USD or in ETH\n\n    function initialize(address _authControl) public initializer {\n        __suAuthenticatedInit(_authControl);\n    }\n\n    function setPriceBase(address asset, bool _isPriceInETH) external onlyAdmin {\n        isPriceInETH[asset] = _isPriceInETH;\n        emit PriceBaseUpdated(asset, _isPriceInETH);\n    }\n\n    function setAssetFeed(address asset, address chainlinkDataFeed, uint8 chainlinkDataFeedDecimals) external onlyAdmin {\n        assetToFeed[asset] = chainlinkDataFeed;\n        // some decimals are different from real token decimals, so we need to store them\n        assetToFeedDecimals[asset] = chainlinkDataFeedDecimals;\n        emit AssetFeedUpdated(asset, chainlinkDataFeed, chainlinkDataFeedDecimals);\n    }\n\n    function getFiatPrice1e18(address asset) public view returns (uint256) {\n        address feed = assetToFeed[asset];\n        if (feed == address(0)) revert BadFeed();\n        uint8 decimals = assetToFeedDecimals[asset];\n        (\n            uint80 roundId,\n            int256 answer,\n        /*uint256 startedAt*/,\n        /*uint256 updatedAt*/,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(feed).latestRoundData();\n        // Should we use that? What is the standart for the PRICE_STALENESS_THRESHOLD?\n        // if (answeredInRound < roundId) revert StalePrice();\n        // if (block.timestamp - updatedAt >= PRICE_STALENESS_THRESHOLD) revert StalePrice();\n        if (answer <= 0) revert BadPriceAnswer();\n        // examples of answers and what we want to get:\n        // ETH/USD = 134165000000 = 1341.65*1e8 =>(want) 1341*1e18\n        // BTC/USD = 1928068190485 = 19,280.68190485*1e8 =>(want) 19k*1e18 * (18-8)[for asset decimals]\n        // USDC/USD = 99990000 = 0.99990000*1e8 =>(want) => 0.9(9) * 1e18 * (18-6)[for asset decimals]\n        uint256 priceFeed1e18 = scaleToE18(uint256(answer), decimals);\n        if (asset == address(0)) {\n            return priceFeed1e18;\n        } else {\n            uint8 assetDecimals = IERC20Metadata(asset).decimals();\n            uint256 scaledPrice1e18 = scaleToE18(priceFeed1e18, assetDecimals);\n            if (isPriceInETH[asset]) {\n                // address(0) mean ETH, that should be added in chainlink config\n                uint256 ethPrice = getFiatPrice1e18(address(0));\n                if (ethPrice == 0) revert BadETHPrice();\n                return scaledPrice1e18 * ethPrice / 1e18;\n            } else {\n                return scaledPrice1e18;\n            }\n        }\n    }\n\n    /**\n     * @dev Adjusts the `price` to have 18 decimals.\n     * @param price The original price to adjust.\n     * @param priceDecimals The number of decimals in the original price.\n     * @return The price adjusted to the desired number of decimals.\n     */\n    function scaleToE18(uint256 price, uint8 priceDecimals) internal pure returns (uint256) {\n        if (price == 0) return 0;\n        // This is because 10 ** 78 exceeds uint256's maximum value.\n        if (priceDecimals >= 77) revert BadDecimals();\n\n        if (priceDecimals < 18) {\n            return price * (10 ** (18 - priceDecimals));\n        } else if (priceDecimals > 18) {\n            return price / (10 ** (priceDecimals - 18));\n        }\n        return price;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}